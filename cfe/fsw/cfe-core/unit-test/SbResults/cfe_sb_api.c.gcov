        -:    0:Source:/Users/rmcgraw/Projects/cFE/fsw/cfe-core/src/sb/cfe_sb_api.c
        -:    0:Graph:cfe_sb_api.gcno
        -:    0:Data:cfe_sb_api.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/******************************************************************************
        -:    2:** File: cfe_sb_api.c
        -:    3:**
        -:    4:**      Copyright (c) 2004-2006, United States government as represented by the
        -:    5:**      administrator of the National Aeronautics Space Administration.
        -:    6:**      All rights reserved. This software(cFE) was created at NASA's Goddard
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This software may be used only pursuant to a United States government
        -:   10:**      sponsored project and the United States government may not be charged
        -:   11:**      for use thereof.
        -:   12:**
        -:   13:**
        -:   14:** Purpose:
        -:   15:**      This file contains the source code for the SB API's.
        -:   16:**
        -:   17:** Author:   R.McGraw/SSI
        -:   18:**
        -:   19:** $Log: cfe_sb_api.c.gcov  $
        -:   19:** Revision 1.3 2009/05/07 15:22:40EDT rmcgraw 
        -:   19:** DCR7366:1 Unit test results for post 5.2 build
        -:   20:** Revision 1.16 2009/04/29 10:04:33EDT rmcgraw 
        -:   21:** DCR5801:11 Changed subscription return value when buf allocation fails
        -:   22:** Revision 1.15 2009/03/30 10:45:01EDT rmcgraw 
        -:   23:** DCR5801:2 Fixed infinite loop when deleting a pipe with subscriptions
        -:   24:** Revision 1.14 2009/02/26 17:57:39EST rmcgraw 
        -:   25:** DCR6805:1 Corrected note under SendMsg API prolog regarding seq count
        -:   26:** Revision 1.13 2009/02/10 16:53:23EST rmcgraw 
        -:   27:** DCR1700:1 Decrement pipes-in-use counter in DeletePipe API
        -:   28:** Revision 1.12 2009/02/10 12:29:07EST rmcgraw 
        -:   29:** DCR6956:1 In Create Pipe API, set user's pipe id to invalid for error cases
        -:   30:** Revision 1.11 2009/02/10 11:25:56EST rmcgraw 
        -:   31:** DCR1699:1 Removed pipe owner in five events
        -:   32:** Revision 1.10 2009/02/06 15:35:08EST rmcgraw 
        -:   33:** DCR5801:3 Moved Total Msg Size test before the lock in the send api
        -:   34:** Revision 1.9 2009/02/06 11:29:04EST rmcgraw 
        -:   35:** DCR5801:2 General Cleanup
        -:   36:** Revision 1.8 2009/02/03 16:33:29EST rmcgraw 
        -:   37:** DCR5801:2 Fixed DestPtr errors in Send API
        -:   38:** Revision 1.7 2009/02/03 11:06:58EST rmcgraw 
        -:   39:** DCR5801:2 Changed destination desciptors from array based to linked list
        -:   40:** Revision 1.6 2009/01/30 12:27:07EST rmcgraw 
        -:   41:** DCR5801:5 Removed call to GetPipePtr in send API inside loop
        -:   42:** Revision 1.5 2009/01/30 11:50:07EST rmcgraw 
        -:   43:** DCR5801:8 Set users ptr to null only when readqueue fails in rcv API
        -:   44:** Revision 1.4 2009/01/30 11:45:06EST rmcgraw 
        -:   45:** DCR5801:9 Removed unused calls to GetAppID in send and rcv APIs
        -:   46:** Revision 1.3 2009/01/30 11:07:03EST rmcgraw 
        -:   47:** DCR5801:3 Moved the semaphore lock in the send and rcv API's
        -:   48:** Revision 1.2 2009/01/30 10:34:57EST rmcgraw 
        -:   49:** DCR5801:1 Began tracking subsribers with 'destinations' counter.
        -:   50:** Revision 1.1 2008/04/17 08:05:30EDT ruperera 
        -:   51:** Initial revision
        -:   52:** Member added to cfe project on tlserver3
        -:   53:** Revision 1.74 2007/09/19 14:38:48EDT rjmcgraw 
        -:   54:** DCR4421 Removed use count err events and reworded buf allocation error event
        -:   55:** Revision 1.73 2007/09/19 12:01:46EDT rjmcgraw
        -:   56:** Return code in unsubscribe changed from no subscribers to cfe success
        -:   57:** Revision 1.72 2007/09/13 09:34:09EDT rjmcgraw
        -:   58:** DCR4861:2 Added check in SendMsg to prevent recursive event problem
        -:   59:** Revision 1.71 2007/08/17 15:59:51EDT rjmcgraw
        -:   60:** Changes to free semaphore before calling SendEventWithAppId
        -:   61:** Revision 1.70 2007/07/12 16:58:22EDT rjmcgraw
        -:   62:** DCR4680:1 Removed SB event log related items
        -:   63:** Revision 1.69 2007/07/06 13:34:17EDT rjmcgraw
        -:   64:** DCR469:1 Added GetLastSender code
        -:   65:** Revision 1.68 2007/04/24 11:07:18EDT rjmcgraw
        -:   66:** Added PipeId to PipeDepthStats
        -:   67:** Revision 1.67 2007/04/24 09:34:04EDT rjmcgraw
        -:   68:** DCR3294 - Added pipe depth stats to several SB api's
        -:   69:** Revision 1.66 2007/03/28 14:17:37EST rjmcgraw
        -:   70:** Sending TskId instead of AppId in call to LogSBEvent - DCR2654
        -:   71:** Revision 1.65 2007/03/27 13:42:28EST rjmcgraw
        -:   72:** Added step to increment new duplicate subscription counter
        -:   73:**
        -:   74:******************************************************************************/
        -:   75:
        -:   76:/*
        -:   77:** Include Files
        -:   78:*/
        -:   79:#include "common_types.h"
        -:   80:#include "cfe_sb_events.h"
        -:   81:#include "cfe_sb_priv.h"
        -:   82:#include "cfe_sb.h"
        -:   83:#include "osapi.h"
        -:   84:#include "cfe_es.h"
        -:   85:#include "cfe_error.h"
        -:   86:#include <string.h>
        -:   87:
        -:   88:/*
        -:   89:** External Globals
        -:   90:*/
        -:   91:extern cfe_sb_t CFE_SB;
        -:   92:
        -:   93:
        -:   94:/******************************************************************************
        -:   95:** Name:    CFE_SB_CreatePipe
        -:   96:**
        -:   97:** Purpose: API to create a pipe for receiving messages
        -:   98:**
        -:   99:** Assumptions, External Events, and Notes:
        -:  100:**
        -:  101:**          Note: Zero is a valid PipeId
        -:  102:**
        -:  103:** Date Written:
        -:  104:**          04/25/2005
        -:  105:**
        -:  106:** Inputs:
        -:  107:**          PipeIdPtr - Ptr to users empty PipeId variable, to be filled by
        -:  108:**                      this function.
        -:  109:**          Depth     - The depth of the pipe, synonymous to the max number
        -:  110:**                      of messages the pipe can hold at any time.
        -:  111:**          PipeName  - The name of the pipe displayed in event messages
        -:  112:**
        -:  113:** Outputs:
        -:  114:**          PipeId    - The handle of the pipe to be used when receiving
        -:  115:**                      messages.
        -:  116:**
        -:  117:** Return Values:
        -:  118:**          Status
        -:  119:**
        -:  120:******************************************************************************/
        -:  121:int32  CFE_SB_CreatePipe(CFE_SB_PipeId_t *PipeIdPtr, uint16  Depth, char *PipeName)
      179:  122:{
      179:  123:    uint32          AppId = 0;
      179:  124:    uint32          TskId = 0;
      179:  125:    uint32          SysQueueId = 0;
        -:  126:    int32           Status;
        -:  127:    CFE_SB_PipeId_t PipeTblIdx;
      179:  128:    char            AppName[OS_MAX_API_NAME] = {'\0'};
        -:  129:
        -:  130:    /* take semaphore to prevent a task switch during this call */
      179:  131:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -:  132:    
      179:  133:    TskId = OS_TaskGetId();
        -:  134:
        -:  135:    /* set user's pipe id value to 'invalid' for error cases below */
      179:  136:    if(PipeIdPtr != NULL){
      178:  137:        *PipeIdPtr = CFE_SB_INVALID_PIPE;
        -:  138:    }/* end if */
        -:  139:
        -:  140:    /* check input parameters */
      179:  141:    if((PipeIdPtr == NULL)||(Depth > CFE_SB_MAX_PIPE_DEPTH)||(Depth == 0)){
        4:  142:        CFE_SB.HKTlmMsg.CreatePipeErrCnt++;
        4:  143:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        4:  144:        CFE_EVS_SendEventWithAppID(CFE_SB_CR_PIPE_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  145:          "CreatePipeErr:Bad Input Arg:app=%s,ptr=0x%x,depth=%d,maxdepth=%d",
        -:  146:                CFE_SB_GetAppTskName(TskId),(uint32)PipeIdPtr,Depth,CFE_SB_MAX_PIPE_DEPTH);
        4:  147:        return CFE_SB_BAD_ARGUMENT;
        -:  148:    }/*end if*/
        -:  149:
        -:  150:    /* get first available entry in pipe table */
      175:  151:    PipeTblIdx = CFE_SB_GetAvailPipeIdx();
        -:  152:
        -:  153:    /* if pipe table is full, send event and return error */
      175:  154:    if(PipeTblIdx == CFE_SB_INVALID_PIPE){
        1:  155:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  156:        CFE_EVS_SendEventWithAppID(CFE_SB_MAX_PIPES_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  157:          "CreatePipeErr:Max Pipes(%d)In Use.app %s",
        -:  158:          CFE_SB_MAX_PIPES,CFE_SB_GetAppTskName(TskId));
        1:  159:        return CFE_SB_MAX_PIPES_MET;
        -:  160:    }/* end if */
        -:  161:
        -:  162:    /* create the queue */
      174:  163:    Status = OS_QueueCreate(&SysQueueId,PipeName,Depth,sizeof(CFE_SB_BufferD_t *),0);
      174:  164:    if (Status != OS_SUCCESS) {
        4:  165:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        4:  166:        CFE_EVS_SendEventWithAppID(CFE_SB_CR_PIPE_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  167:                "CreatePipeErr:OS_QueueCreate returned %d,app %s",
        -:  168:                Status,CFE_SB_GetAppTskName(TskId));
        4:  169:        return CFE_SB_PIPE_CR_ERR;
        -:  170:    }/* end if */
        -:  171:
        -:  172:    /* get callers AppId */
      170:  173:    CFE_ES_GetAppID(&AppId);
        -:  174:    
        -:  175:    /* get callers name */
      170:  176:    CFE_ES_GetAppName(AppName, AppId, OS_MAX_API_NAME);
        -:  177:    
        -:  178:    /* Hardcode a NULL terminator, in case rcvd name was too long */
      170:  179:    AppName[OS_MAX_API_NAME-1]= '\0';
        -:  180:
        -:  181:    /* fill in the pipe table fields */
      170:  182:    CFE_SB.PipeTbl[PipeTblIdx].InUse       = CFE_SB_IN_USE;
      170:  183:    CFE_SB.PipeTbl[PipeTblIdx].SysQueueId  = SysQueueId;
      170:  184:    CFE_SB.PipeTbl[PipeTblIdx].PipeId      = PipeTblIdx;
      170:  185:    CFE_SB.PipeTbl[PipeTblIdx].QueueDepth  = Depth;
      170:  186:    CFE_SB.PipeTbl[PipeTblIdx].AppId       = AppId;
      170:  187:    CFE_SB.PipeTbl[PipeTblIdx].SendErrors  = 0;
      170:  188:    CFE_SB.PipeTbl[PipeTblIdx].CurrentBuff = NULL;
      170:  189:    strcpy(&CFE_SB.PipeTbl[PipeTblIdx].AppName[0],&AppName[0]);
      170:  190:    strncpy(&CFE_SB.PipeTbl[PipeTblIdx].PipeName[0],PipeName,OS_MAX_API_NAME);
      170:  191:    CFE_SB.PipeTbl[PipeTblIdx].PipeName[OS_MAX_API_NAME-1]='\0';
        -:  192:
        -:  193:    /* Increment the Pipes in use ctr and if it's > the high water mark,*/
        -:  194:    /* adjust the high water mark */
      170:  195:    CFE_SB.StatTlmMsg.PipesInUse++;
      170:  196:    if(CFE_SB.StatTlmMsg.PipesInUse > CFE_SB.StatTlmMsg.PeakPipesInUse){
      170:  197:       CFE_SB.StatTlmMsg.PeakPipesInUse = CFE_SB.StatTlmMsg.PipesInUse;
        -:  198:    }/* end if */
        -:  199:
        -:  200:    /* Reset the pipe depth parameters in the statistics pkt */
      170:  201:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PipeId = PipeTblIdx;
      170:  202:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].Depth = Depth;
      170:  203:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].InUse = 0;
      170:  204:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PeakInUse = 0;
        -:  205:
        -:  206:    /* give the pipe handle to the caller */
      170:  207:    *PipeIdPtr = PipeTblIdx;
        -:  208:
      170:  209:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -:  210:
        -:  211:    /* send debug event */
      170:  212:    CFE_EVS_SendEventWithAppID(CFE_SB_PIPE_ADDED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  213:          "Pipe Created:name %s,id %d,app %s",
        -:  214:          CFE_SB_GetPipeName(CFE_SB.PipeTbl[PipeTblIdx].PipeId),
        -:  215:          CFE_SB.PipeTbl[PipeTblIdx].PipeId,
        -:  216:          CFE_SB_GetAppTskName(TskId));
        -:  217:
      170:  218:    return CFE_SUCCESS;
        -:  219:
      179:  220:}/* end CFE_SB_CreatePipe */
        -:  221:
        -:  222:
        -:  223:/******************************************************************************
        -:  224:**  Function:  CFE_SB_DeletePipe()
        -:  225:**
        -:  226:**  Purpose:
        -:  227:**    Will unsubscribe to all routes associated with the given pipe id, then remove
        -:  228:**    pipe from the pipe table.
        -:  229:**
        -:  230:**  Arguments:
        -:  231:**    PipeId - The ID of the pipe to delete.
        -:  232:**
        -:  233:**  Return:
        -:  234:**    CFE_SUCCESS or cFE Error Code
        -:  235:*/
        -:  236:int32 CFE_SB_DeletePipe(CFE_SB_PipeId_t PipeId)
      168:  237:{
      168:  238:    uint32  CallerId = 0;
      168:  239:    int32   Status = 0;
        -:  240:
        -:  241:    /* get the callers Application Id */
      168:  242:    CFE_ES_GetAppID(&CallerId);
        -:  243:
      168:  244:    Status = CFE_SB_DeletePipeFull(PipeId,CallerId);
        -:  245:
      168:  246:    return Status;
        -:  247:
      168:  248:}/* end CFE_SB_DeletePipe */
        -:  249:
        -:  250:
        -:  251:
        -:  252:/******************************************************************************
        -:  253:**  Function:  CFE_SB_DeletePipeWithAppId()
        -:  254:**
        -:  255:**  Purpose:
        -:  256:**
        -:  257:**
        -:  258:**  Arguments:
        -:  259:**    PipeId - The ID of the pipe to delete.
        -:  260:**
        -:  261:**  Return:
        -:  262:**    CFE_SUCCESS or cFE Error Code
        -:  263:*/
        -:  264:int32 CFE_SB_DeletePipeWithAppId(CFE_SB_PipeId_t PipeId, uint32 AppId)
        2:  265:{
        2:  266:    int32   Status = 0;
        -:  267:
        2:  268:    Status = CFE_SB_DeletePipeFull(PipeId,AppId);
        -:  269:
        2:  270:    return Status;
        -:  271:
        2:  272:}/* end CFE_SB_DeletePipeWithAppId */
        -:  273:
        -:  274:
        -:  275:
        -:  276:/******************************************************************************
        -:  277:**  Function:  CFE_SB_DeletePipeFull()
        -:  278:**
        -:  279:**  Purpose:
        -:  280:**    Will unsubscribe to all routes associated with the given pipe id, then remove
        -:  281:**    pipe from the pipe table.
        -:  282:**
        -:  283:**  NOTE:This function cannot be called directly, it would not be semaphore protected
        -:  284:**
        -:  285:**  Arguments:
        -:  286:**    PipeId - The ID of the pipe to delete.
        -:  287:**
        -:  288:**  Return:
        -:  289:**    CFE_SUCCESS or cFE Error Code
        -:  290:*/
        -:  291:int32 CFE_SB_DeletePipeFull(CFE_SB_PipeId_t PipeId,uint32 AppId)
      170:  292:{
        -:  293:    uint8         PipeTblIdx;
        -:  294:    int32         RtnFromVal,i,Stat;
        -:  295:    uint32        Owner;
      170:  296:    uint32        TskId = 0;
        -:  297:    CFE_SB_Msg_t  *PipeMsgPtr;
      170:  298:    CFE_SB_DestinationD_t *DestPtr = NULL;
        -:  299:
        -:  300:    /* take semaphore to prevent a task switch during this call */
      170:  301:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -:  302:
        -:  303:    /* get TaskId of caller for events */
      170:  304:    TskId = OS_TaskGetId();
        -:  305:
        -:  306:    /* check input parameter */
      170:  307:    PipeTblIdx = CFE_SB_GetPipeIdx(PipeId);
      170:  308:    RtnFromVal = CFE_SB_ValidatePipeId(PipeId);
      170:  309:    if((RtnFromVal != CFE_SUCCESS)||(PipeTblIdx == CFE_SB_INVALID_PIPE))
        -:  310:    {
        2:  311:        CFE_SB.HKTlmMsg.CreatePipeErrCnt++;
        2:  312:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        2:  313:        CFE_EVS_SendEventWithAppID(CFE_SB_DEL_PIPE_ERR1_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  314:          "Pipe Delete Error:Bad Argument,PipedId %d,Requestor %s,Idx %d,Stat %d",
        -:  315:          PipeId,CFE_SB_GetAppTskName(TskId),PipeTblIdx,RtnFromVal);
        2:  316:        return CFE_SB_BAD_ARGUMENT;
        -:  317:    }/* end if */
        -:  318:
      168:  319:    Owner = CFE_SB.PipeTbl[PipeTblIdx].AppId;
        -:  320:
        -:  321:    /* check that the given AppId is the owner of the pipe */
      168:  322:    if(AppId != Owner){
        1:  323:        CFE_SB.HKTlmMsg.CreatePipeErrCnt++;
        1:  324:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  325:        CFE_EVS_SendEventWithAppID(CFE_SB_DEL_PIPE_ERR2_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  326:          "Pipe Delete Error:Caller(%s) is not the owner of pipe %d",
        -:  327:          CFE_SB_GetAppTskName(TskId),PipeId);
        1:  328:        return CFE_SB_BAD_ARGUMENT;
        -:  329:    }/* end if */
        -:  330:
        -:  331:    /* check destination list of every in-use MsgId, for the given pipeid. */
        -:  332:    /* when found, remove the pipe ID from the destination list via 'unsubscribe' */
    42919:  333:    for(i=0;i<CFE_SB_MAX_MSG_IDS;i++){
    42752:  334:        if(CFE_SB.RoutingTbl[i].MsgId != CFE_SB_INVALID_MSG_ID){
        -:  335:            
      928:  336:            DestPtr = CFE_SB.RoutingTbl[i].ListHeadPtr;
        -:  337:        
     2920:  338:            while(DestPtr != NULL){
        -:  339:            
     1064:  340:                if(DestPtr -> PipeId == PipeId){
        -:  341:                    /* release the semaphore, unsubscribe will need to take it */
      399:  342:                    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
      399:  343:                    CFE_SB_UnsubscribeWithAppId(CFE_SB.RoutingTbl[i].MsgId,
        -:  344:                                       PipeId,AppId);
      399:  345:                    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -:  346:                }/* end if */
        -:  347:                
     1064:  348:                DestPtr = DestPtr -> Next;
        -:  349:                
        -:  350:            }/* end while */
        -:  351:
        -:  352:        }/* end if */
        -:  353:    }/* end for */
        -:  354:
        -:  355:
        -:  356:    /* remove any messages that might be on the pipe */
        -:  357:    /* this step will free the memory used to store the message */
        -:  358:    do{
      170:  359:      CFE_SB_UnlockSharedData(__FILE__,__LINE__);
      170:  360:      Stat = CFE_SB_RcvMsg(&PipeMsgPtr,PipeId,CFE_SB_POLL);
      170:  361:      CFE_SB_LockSharedData(__FILE__,__LINE__);
      170:  362:    }while(Stat == CFE_SUCCESS);
        -:  363:
        -:  364:    /* Delete the underlying OS queue */
      167:  365:    OS_QueueDelete(CFE_SB.PipeTbl[PipeTblIdx].SysQueueId);
        -:  366:
        -:  367:    /* remove the pipe from the pipe table */
      167:  368:    CFE_SB.PipeTbl[PipeTblIdx].InUse         = CFE_SB_NOT_IN_USE;
      167:  369:    CFE_SB.PipeTbl[PipeTblIdx].SysQueueId    = CFE_SB_UNUSED_QUEUE;
      167:  370:    CFE_SB.PipeTbl[PipeTblIdx].PipeId        = CFE_SB_INVALID_PIPE;
      167:  371:    CFE_SB.PipeTbl[PipeTblIdx].CurrentBuff   = NULL;
      167:  372:    OS_MemSet(&CFE_SB.PipeTbl[PipeTblIdx].PipeName[0],0,OS_MAX_API_NAME);
        -:  373:
        -:  374:    /* zero out the pipe depth stats */
      167:  375:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PipeId = 0;
      167:  376:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].Depth = 0;
      167:  377:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].InUse = 0;
      167:  378:    CFE_SB.StatTlmMsg.PipeDepthStats[PipeTblIdx].PeakInUse = 0;
        -:  379:    
      167:  380:    CFE_SB.StatTlmMsg.PipesInUse--;
        -:  381:
      167:  382:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -:  383:
      167:  384:    CFE_EVS_SendEventWithAppID(CFE_SB_PIPE_DELETED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  385:          "Pipe Deleted:id %d,owner %s",PipeId, CFE_SB_GetAppTskName(Owner));
        -:  386:
      167:  387:    return CFE_SUCCESS;
        -:  388:
      170:  389:}/* end CFE_SB_DeletePipeFull */
        -:  390:
        -:  391:
        -:  392:/******************************************************************************
        -:  393:** Name:    CFE_SB_SubscribeEx
        -:  394:**
        -:  395:** Purpose: API to globally subscribe to a message when QOS and MsgLim defaults
        -:  396:**          are insufficient.
        -:  397:**
        -:  398:** Assumptions, External Events, and Notes:
        -:  399:**
        -:  400:**          Note: Qos default: priority is low, reliability is low
        -:  401:**          Note: MsgLim default: 4, see Input Arguments below for more detail
        -:  402:**          Note: Qos parameter is currently unused by the fsw. It is recommended
        -:  403:**                to give a value of zero for Quality.Priority and Quality.Reliability
        -:  404:**
        -:  405:** Date Written:
        -:  406:**          04/25/2005
        -:  407:**
        -:  408:** Input Arguments:
        -:  409:**          MsgId   - The requesting message
        -:  410:**          PipeId  - The Pipe ID to send the message to
        -:  411:**          Quality - Quality of Service (Qos) - priority and reliability,
        -:  412:**                    see note above for recommended settings
        -:  413:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  414:**                    pipe at any time.
        -:  415:**
        -:  416:** Output Arguments:
        -:  417:**          None
        -:  418:**
        -:  419:** Return Values:
        -:  420:**          Status
        -:  421:**
        -:  422:******************************************************************************/
        -:  423:int32  CFE_SB_SubscribeEx(CFE_SB_MsgId_t   MsgId,
        -:  424:                          CFE_SB_PipeId_t  PipeId,
        -:  425:                          CFE_SB_Qos_t     Quality,
        -:  426:                          uint16           MsgLim)
        3:  427:{
        3:  428:    return CFE_SB_SubscribeFull(MsgId,PipeId,Quality,MsgLim,(uint8)CFE_SB_GLOBAL);
        -:  429:
        3:  430:}/* end CFE_SB_SubscribeEx */
        -:  431:
        -:  432:
        -:  433:
        -:  434:
        -:  435:/******************************************************************************
        -:  436:** Name:    CFE_SB_SubscribeLocal
        -:  437:**
        -:  438:** Purpose: CFE Internal API to locally subscribe to a message when QOS and
        -:  439:**          MsgLim defaults are insufficient.
        -:  440:**
        -:  441:** Assumptions, External Events, and Notes:
        -:  442:**
        -:  443:**          Note: Qos default: priority is low, reliability is low
        -:  444:**                MsgLim default: 4 - meaning at most 4 messages of given
        -:  445:**                                    MsgId allowed on the given PipeId.
        -:  446:**
        -:  447:** Date Written:
        -:  448:**          04/25/2005
        -:  449:**
        -:  450:** Input Arguments:
        -:  451:**          MsgId   - The requesting message
        -:  452:**          PipeId  - The Pipe ID to send the message to
        -:  453:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  454:**                    pipe at any time.
        -:  455:**
        -:  456:** Output Arguments:
        -:  457:**          None
        -:  458:**
        -:  459:** Return Values:
        -:  460:**          Status
        -:  461:**
        -:  462:******************************************************************************/
        -:  463:int32 CFE_SB_SubscribeLocal(CFE_SB_MsgId_t   MsgId,
        -:  464:                            CFE_SB_PipeId_t  PipeId,
        -:  465:                            uint16           MsgLim)
        3:  466:{
        3:  467:    return CFE_SB_SubscribeFull(MsgId,PipeId,CFE_SB_Default_Qos,MsgLim,
        -:  468:                                (uint8)CFE_SB_LOCAL);
        -:  469:
        3:  470:}/* end CFE_SB_SubscribeLocal */
        -:  471:
        -:  472:
        -:  473:
        -:  474:
        -:  475:/******************************************************************************
        -:  476:** Name:    CFE_SB_Subscribe
        -:  477:**
        -:  478:** Purpose: API to locally subscribe to a message when QOS and MsgLim defaults
        -:  479:**          are sufficient.
        -:  480:**
        -:  481:** Assumptions, External Events, and Notes:
        -:  482:**
        -:  483:**          Note: Qos default: priority is low, reliability is low
        -:  484:**                MsgLim default: 4 - meaning at most 4 messages of given
        -:  485:**                                    MsgId allowed on the given PipeId.
        -:  486:**
        -:  487:** Date Written:
        -:  488:**          04/25/2005
        -:  489:**
        -:  490:** Input Arguments:
        -:  491:**          MsgId   - The requesting message
        -:  492:**          PipeId  - The Pipe ID to send the message to
        -:  493:**
        -:  494:** Output Arguments:
        -:  495:**          None
        -:  496:**
        -:  497:** Return Values:
        -:  498:**          Status
        -:  499:**
        -:  500:******************************************************************************/
        -:  501:int32 CFE_SB_Subscribe(CFE_SB_MsgId_t   MsgId,
        -:  502:                       CFE_SB_PipeId_t  PipeId)
      407:  503:{
      407:  504:    return CFE_SB_SubscribeFull(MsgId,PipeId,CFE_SB_Default_Qos,
        -:  505:                               (uint16)CFE_SB_DEFAULT_MSG_LIMIT,
        -:  506:                               (uint8)CFE_SB_GLOBAL);
        -:  507:
      407:  508:}/* end CFE_SB_Subscribe */
        -:  509:
        -:  510:
        -:  511:/******************************************************************************
        -:  512:** Name:    CFE_SB_SubscribeFull
        -:  513:**
        -:  514:** Purpose: CFE Internal API used to subscribe to a message. Contains an input
        -:  515:**          parameter for all possible subscription choices. This function is
        -:  516:**          called by CFE_SB_SubscribeEx, CFE_SB_Subscribe and
        -:  517:**          CFE_SB_SubscribeLocal.
        -:  518:**
        -:  519:** Assumptions, External Events, and Notes:
        -:  520:**          None
        -:  521:**
        -:  522:** Date Written:
        -:  523:**          04/25/2005
        -:  524:**
        -:  525:** Input Arguments:
        -:  526:**          MsgId   - The requesting message
        -:  527:**          PipeId  - The Pipe ID to send the message to
        -:  528:**          Quality - Quality of Service (Qos) - priority and reliability
        -:  529:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  530:**                    pipe at any time.
        -:  531:**          Scope   - Local subscription or broadcasted to peers
        -:  532:**
        -:  533:** Output Arguments:
        -:  534:**          None
        -:  535:**
        -:  536:** Return Values:
        -:  537:**          Status
        -:  538:**
        -:  539:******************************************************************************/
        -:  540:int32  CFE_SB_SubscribeFull(CFE_SB_MsgId_t   MsgId,
        -:  541:                            CFE_SB_PipeId_t  PipeId,
        -:  542:                            CFE_SB_Qos_t     Quality,
        -:  543:                            uint16           MsgLim,
        -:  544:                            uint8            Scope)
      413:  545:{
        -:  546:    uint16 Idx;
        -:  547:    int32  Stat;
      413:  548:    uint32 TskId = 0;
      413:  549:    uint32 AppId = 0;
        -:  550:    uint8  PipeIdx;
      413:  551:    CFE_SB_DestinationD_t *DestBlkPtr = NULL;
        -:  552:
        -:  553:    /* take semaphore to prevent a task switch during this call */
      413:  554:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -:  555:
        -:  556:    /* get task id for events */
      413:  557:    TskId = OS_TaskGetId();
        -:  558:
        -:  559:    /* get the callers Application Id */
      413:  560:    CFE_ES_GetAppID(&AppId);
        -:  561:
        -:  562:    /* check that the pipe has been created */
      413:  563:    PipeIdx = CFE_SB_GetPipeIdx(PipeId);
      413:  564:    if(PipeIdx==CFE_SB_INVALID_PIPE){
        2:  565:      CFE_SB.HKTlmMsg.SubscribeErrCnt++;
        2:  566:      CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        2:  567:      CFE_EVS_SendEventWithAppID(CFE_SB_SUB_INV_PIPE_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  568:          "Subscribe Err:Invalid Pipe Id,Msg=0x%x,PipeId=%d,App %s",MsgId,PipeId,
        -:  569:          CFE_SB_GetAppTskName(TskId));
        2:  570:      return CFE_SB_BAD_ARGUMENT;
        -:  571:    }/* end if */
        -:  572:
        -:  573:    /* check that the requestor is the owner of the pipe */
      411:  574:    if(CFE_SB.PipeTbl[PipeIdx].AppId != AppId){
        1:  575:      CFE_SB.HKTlmMsg.SubscribeErrCnt++;
        1:  576:      CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  577:      CFE_EVS_SendEventWithAppID(CFE_SB_SUB_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  578:          "Subscribe Err:Caller(%s) is not the owner of pipe %d,Msg=0x%x",
        -:  579:          CFE_SB_GetAppTskName(TskId),PipeId,MsgId);
        1:  580:      return CFE_SB_BAD_ARGUMENT;
        -:  581:    }/* end if */
        -:  582:
        -:  583:    /* check message id and scope */
      410:  584:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||(Scope > 1))
        -:  585:    {
        1:  586:        CFE_SB.HKTlmMsg.SubscribeErrCnt++;
        1:  587:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  588:        CFE_EVS_SendEventWithAppID(CFE_SB_SUB_ARG_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  589:          "Subscribe Err:Bad Arg,MsgId 0x%x,PipeId %d,app %s,scope %d",
        -:  590:          MsgId,PipeId,CFE_SB_GetAppTskName(TskId),Scope);
        1:  591:        return CFE_SB_BAD_ARGUMENT;
        -:  592:    }/* end if */
        -:  593:
        -:  594:    /* check for duplicate subscription */
      409:  595:    if(CFE_SB_DuplicateSubscribeCheck(MsgId,PipeId)==CFE_SB_DUPLICATE){
        1:  596:        CFE_SB.HKTlmMsg.DupSubscriptionsCnt++;
        1:  597:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  598:        CFE_EVS_SendEventWithAppID(CFE_SB_DUP_SUBSCRIP_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -:  599:          "Duplicate Subscription,MsgId 0x%x on %s pipe,app %s",
        -:  600:           MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId));
        1:  601:        return CFE_SUCCESS;
        -:  602:    }/* end if */
        -:  603:
        -:  604:    /*
        -:  605:    ** If there has been a subscription for this message id earlier,
        -:  606:    ** get the element number in the routing table.
        -:  607:    */
      408:  608:    Idx = CFE_SB_GetRoutingTblIdx(MsgId);
        -:  609:
        -:  610:    /* if first subscription for this message... */
      408:  611:    if(Idx==CFE_SB_AVAILABLE){
        -:  612:
        -:  613:        /* Get the index to the first available element in the routing table */
      375:  614:        Idx = CFE_SB_GetAvailRoutingIdx();
        -:  615:
        -:  616:        /* if all routing table elements are used, send event */
      375:  617:        if(Idx >= CFE_SB_MAX_MSG_IDS){
        1:  618:            CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  619:            CFE_EVS_SendEventWithAppID(CFE_SB_MAX_MSGS_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  620:              "Subscribe Err:Max Msgs(%d)In Use,MsgId 0x%x,pipe %s,app %s",
        -:  621:              CFE_SB_MAX_MSG_IDS,MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId));
        1:  622:            return CFE_SB_MAX_MSGS_MET;
        -:  623:        }/* end if */
        -:  624:
        -:  625:        /* Increment the MsgIds in use ctr and if it's > the high water mark,*/
        -:  626:        /* adjust the high water mark */
      374:  627:        CFE_SB.StatTlmMsg.MsgIdsInUse++;
      374:  628:        if(CFE_SB.StatTlmMsg.MsgIdsInUse > CFE_SB.StatTlmMsg.PeakMsgIdsInUse){
      374:  629:           CFE_SB.StatTlmMsg.PeakMsgIdsInUse = CFE_SB.StatTlmMsg.MsgIdsInUse;
        -:  630:        }/* end if */
        -:  631:
        -:  632:        /* populate the look up table with the routing table index */
      374:  633:        CFE_SB_SetRoutingTblIdx(MsgId,Idx);
        -:  634:
        -:  635:        /* label the new routing block with the message identifier */
      374:  636:        CFE_SB.RoutingTbl[Idx].MsgId = MsgId;
        -:  637:
        -:  638:    }/* end if */
        -:  639:
      407:  640:    if(CFE_SB.RoutingTbl[Idx].Destinations >= CFE_SB_MAX_DEST_PER_PKT){
        1:  641:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  642:        CFE_EVS_SendEventWithAppID(CFE_SB_MAX_DESTS_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  643:            "Subscribe Err:Max Dests(%d)In Use For Msg 0x%x,pipe %s,app %s",
        -:  644:             CFE_SB_MAX_DEST_PER_PKT,MsgId,CFE_SB_GetPipeName(PipeId),
        -:  645:             CFE_SB_GetAppTskName(TskId));
        1:  646:        return CFE_SB_MAX_DESTS_MET;
        -:  647:    }/* end if */        
        -:  648:
      406:  649:    DestBlkPtr = CFE_SB_GetDestinationBlk();
      406:  650:    if(DestBlkPtr == NULL){
        2:  651:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        2:  652:        CFE_EVS_SendEventWithAppID(CFE_SB_DEST_BLK_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  653:            "Subscribe Err:Request for Destination Blk failed for Msg 0x%x",
        -:  654:             CFE_SB_MAX_DEST_PER_PKT,MsgId,CFE_SB_GetPipeName(PipeId),
        -:  655:             CFE_SB_GetAppTskName(TskId));
        2:  656:        return CFE_SB_BUF_ALOC_ERR;
        -:  657:    }/* end if */
        -:  658:    
        -:  659:    /* initialize destination block */
      404:  660:    DestBlkPtr -> PipeId = PipeId;
      404:  661:    DestBlkPtr -> MsgId2PipeLim = (uint16)MsgLim;
      404:  662:    DestBlkPtr -> Active = CFE_SB_ACTIVE;
      404:  663:    DestBlkPtr -> BuffCount = 0;
      404:  664:    DestBlkPtr -> DestCnt = 0;
      404:  665:    DestBlkPtr -> Scope = Scope;
      404:  666:    DestBlkPtr -> Prev = NULL;
      404:  667:    DestBlkPtr -> Next = NULL;
        -:  668:
        -:  669:    /* add destination block to head of list */
      404:  670:    CFE_SB_AddDest(Idx, DestBlkPtr);
        -:  671:    
      404:  672:    CFE_SB.RoutingTbl[Idx].Destinations++;
        -:  673:
      404:  674:    CFE_SB.StatTlmMsg.SubscriptionsInUse++;
      404:  675:    if(CFE_SB.StatTlmMsg.SubscriptionsInUse > CFE_SB.StatTlmMsg.PeakSubscriptionsInUse)
        -:  676:    {
      404:  677:       CFE_SB.StatTlmMsg.PeakSubscriptionsInUse = CFE_SB.StatTlmMsg.SubscriptionsInUse;
        -:  678:    }/* end if */
        -:  679:
      404:  680:    if((CFE_SB.SubscriptionReporting == CFE_SB_ENABLE)&&(Scope==CFE_SB_GLOBAL)){
        1:  681:      CFE_SB.SubRprtMsg.MsgId = MsgId;
        1:  682:      CFE_SB.SubRprtMsg.Pipe = PipeId;
        1:  683:      CFE_SB.SubRprtMsg.Qos.Priority = Quality.Priority;
        1:  684:      CFE_SB.SubRprtMsg.Qos.Reliability = Quality.Reliability;
        1:  685:      CFE_SB.SubRprtMsg.SubType = CFE_SB_SUBSCRIPTION;
        1:  686:      CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  687:      Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.SubRprtMsg);
        1:  688:      CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_RPT_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  689:            "Sending Subscription Report Msg=0x%x,Pipe=%d,Stat=0x%x",
        -:  690:             MsgId,PipeId,Stat);
        1:  691:      CFE_SB_LockSharedData(__FILE__,__LINE__);/* to prevent back-to-back unlock */
        -:  692:    }/* end if */
        -:  693:
        -:  694:    /* release the semaphore */
      404:  695:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -:  696:
      404:  697:    CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_RCVD_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  698:        "Subscription Rcvd:MsgId 0x%x on %s(%d),app %s",
        -:  699:         MsgId,CFE_SB_GetPipeName(PipeId),PipeId,CFE_SB_GetAppTskName(TskId));
        -:  700:
      404:  701:    return CFE_SUCCESS;
        -:  702:
      413:  703:}/* end CFE_SB_SubscribeFull */
        -:  704:
        -:  705:
        -:  706:/******************************************************************************
        -:  707:** Name:    CFE_SB_Unsubscribe
        -:  708:**
        -:  709:** Purpose: API used to unsubscribe to a message.
        -:  710:**
        -:  711:** Date Written:
        -:  712:**          04/25/2005
        -:  713:**
        -:  714:** Input Arguments:
        -:  715:**          MsgId
        -:  716:**          PipeId
        -:  717:**
        -:  718:** Output Arguments:
        -:  719:**          None
        -:  720:**
        -:  721:** Return Values:
        -:  722:**          Status
        -:  723:**
        -:  724:******************************************************************************/
        -:  725:int32 CFE_SB_Unsubscribe(CFE_SB_MsgId_t MsgId, CFE_SB_PipeId_t PipeId)
        8:  726:{
        8:  727:    uint32  CallerId = 0;
        8:  728:    int32   Status = 0;
        -:  729:
        -:  730:    /* get the callers Application Id */
        8:  731:    CFE_ES_GetAppID(&CallerId);
        -:  732:
        8:  733:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_GLOBAL,CallerId);
        -:  734:
        8:  735:    return Status;
        -:  736:
        8:  737:}/* end CFE_SB_Unsubscribe */
        -:  738:
        -:  739:
        -:  740:/******************************************************************************
        -:  741:** Name:    CFE_SB_UnsubscribeLocal
        -:  742:**
        -:  743:** Purpose: CFE Internal API used to locally unsubscribe to a message. This
        -:  744:**          request to cancel a subscription will not be sent to peers.
        -:  745:**
        -:  746:** Date Written:
        -:  747:**          04/25/2005
        -:  748:**
        -:  749:** Input Arguments:
        -:  750:**          MsgId
        -:  751:**          PipeId
        -:  752:**
        -:  753:** Output Arguments:
        -:  754:**          None
        -:  755:**
        -:  756:** Return Values:
        -:  757:**          Status
        -:  758:**
        -:  759:******************************************************************************/
        -:  760:int32 CFE_SB_UnsubscribeLocal(CFE_SB_MsgId_t MsgId, CFE_SB_PipeId_t PipeId)
        1:  761:{
        1:  762:    uint32  CallerId = 0;
        1:  763:    int32   Status = 0;
        -:  764:
        -:  765:    /* get the callers Application Id */
        1:  766:    CFE_ES_GetAppID(&CallerId);
        -:  767:
        1:  768:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_LOCAL,CallerId);
        -:  769:
        1:  770:    return Status;
        -:  771:
        1:  772:}/* end CFE_SB_UnsubscribeLocal */
        -:  773:
        -:  774:
        -:  775:/******************************************************************************
        -:  776:** Name:    CFE_SB_UnsubscribeAppId
        -:  777:**
        -:  778:** Purpose: CFE Internal API intented to be called by CFE_ES when an applications
        -:  779:**          SB resources need to be freed. The regular unsibscribe api won't work
        -:  780:**          because it does a check to ensure the caller is the owner of the pipe.
        -:  781:**
        -:  782:** Date Written:
        -:  783:**          03/15/2007
        -:  784:**
        -:  785:** Input Arguments:
        -:  786:**          MsgId
        -:  787:**          PipeId
        -:  788:**          AppId
        -:  789:**
        -:  790:** Output Arguments:
        -:  791:**          None
        -:  792:**
        -:  793:** Return Values:
        -:  794:**          Status
        -:  795:**
        -:  796:******************************************************************************/
        -:  797:int32 CFE_SB_UnsubscribeWithAppId(CFE_SB_MsgId_t MsgId,
        -:  798:                              CFE_SB_PipeId_t PipeId,
        -:  799:                              uint32 AppId)
      399:  800:{
      399:  801:    int32   Status = 0;
        -:  802:
      399:  803:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_LOCAL, AppId);
        -:  804:
      399:  805:    return Status;
        -:  806:
      399:  807:}/* end CFE_SB_UnsubscribeWithAppId */
        -:  808:
        -:  809:
        -:  810:/******************************************************************************
        -:  811:** Name:    CFE_SB_UnsubscribeFull
        -:  812:**
        -:  813:** Purpose: CFE Internal API used to unsubscribe to a message.
        -:  814:**
        -:  815:** Assumptions, External Events, and Notes:
        -:  816:**
        -:  817:**
        -:  818:** Notes:This function cannot be called directly,it would not be semaphore protected.
        -:  819:**       Also,if more than one subscription is found, this function will remove all
        -:  820:**       entries that match.
        -:  821:**
        -:  822:** Date Written:
        -:  823:**          04/25/2005
        -:  824:**
        -:  825:** Input Arguments:
        -:  826:**          MsgId
        -:  827:**          PipeId
        -:  828:**          Scope
        -:  829:**          AppId
        -:  830:**
        -:  831:** Output Arguments:
        -:  832:**          None
        -:  833:**
        -:  834:** Return Values:
        -:  835:**          Status
        -:  836:**
        -:  837:******************************************************************************/
        -:  838:int32 CFE_SB_UnsubscribeFull(CFE_SB_MsgId_t MsgId,CFE_SB_PipeId_t PipeId,
        -:  839:                             uint8 Scope,uint32 AppId)
      408:  840:{
        -:  841:    uint16  Idx;
        -:  842:    uint32  PipeIdx;
      408:  843:    uint32  TskId = 0;
      408:  844:    uint32  MatchFound = FALSE;
        -:  845:    int32   Stat;
      408:  846:    CFE_SB_DestinationD_t   *DestPtr = NULL;
        -:  847:    
        -:  848:
        -:  849:    /* take semaphore to prevent a task switch during this call */
      408:  850:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -:  851:
        -:  852:    /* get task id for events */
      408:  853:    TskId = OS_TaskGetId();
        -:  854:
        -:  855:    /* check that the pipe has been created */
      408:  856:    PipeIdx = CFE_SB_GetPipeIdx(PipeId);
      408:  857:    if(PipeIdx==CFE_SB_INVALID_PIPE){
        1:  858:      CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  859:      CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_INV_PIPE_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  860:            "Unsubscribe Err:Invalid Pipe Id Msg=0x%x,Pipe=%d,app=%s",
        -:  861:            MsgId,PipeId,CFE_SB_GetAppTskName(TskId));
        1:  862:      return CFE_SB_BAD_ARGUMENT;
        -:  863:    }/* end if */
        -:  864:
        -:  865:    /* if given 'AppId' is not the owner of the pipe, send error event and return */
      407:  866:    if(CFE_SB.PipeTbl[PipeIdx].AppId != AppId){
        1:  867:      CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  868:      CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  869:            "Unsubscribe Err:Caller(%s) is not the owner of pipe %d,Msg=0x%x",
        -:  870:            CFE_SB_GetAppTskName(TskId),PipeId,MsgId);
        1:  871:      return CFE_SB_BAD_ARGUMENT;
        -:  872:    }/* end if */
        -:  873:
        -:  874:    /* check input parameters */
      406:  875:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||
        -:  876:       (CFE_SB_ValidatePipeId(PipeId) != CFE_SUCCESS)||
        -:  877:       (Scope > 1))
        -:  878:    {
        1:  879:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  880:        CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_ARG_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  881:            "UnSubscribe Err:Bad Arg,MsgId 0x%x,PipeId %d,app %s,scope %d",
        -:  882:            MsgId,PipeId,CFE_SB_GetAppTskName(TskId),Scope);
        1:  883:        return CFE_SB_BAD_ARGUMENT;
        -:  884:    }/* end if */
        -:  885:
        -:  886:    /* get index into routing table */
      405:  887:    Idx = CFE_SB_GetRoutingTblIdx(MsgId);
        -:  888:
        -:  889:    /* if there are no subscriptions for this message id... */
      405:  890:    if(Idx == CFE_SB_AVAILABLE){
        1:  891:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  892:        CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_NO_SUBS_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -:  893:            "Unsubscribe Err:No subs for Msg 0x%x on %s,app %s",
        -:  894:            MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId));
        1:  895:        return CFE_SUCCESS;
        -:  896:    }/* end if */
        -:  897:    
        -:  898:    /* At this point, there must be at least one destination. */
        -:  899:    /* So the value of 'ListHeadPtr' will not be NULL by design */
        -:  900:    
        -:  901:    /* search the list for a matching pipe id */
      404:  902:    DestPtr = CFE_SB.RoutingTbl[Idx].ListHeadPtr;
        -:  903:        
        -:  904:    do{
        -:  905:        
      543:  906:        if(DestPtr->PipeId == PipeId){
        -:  907:            /* match found, remove node from list */
      404:  908:            CFE_SB_RemoveDest(Idx,DestPtr);
        -:  909:            
        -:  910:            /* return node to memory pool */
      404:  911:            CFE_SB_PutDestinationBlk(DestPtr);
        -:  912:            
      404:  913:            CFE_SB.RoutingTbl[Idx].Destinations--;
      404:  914:            CFE_SB.StatTlmMsg.SubscriptionsInUse--;
        -:  915:            
      404:  916:            MatchFound = TRUE;
        -:  917:        
        -:  918:        }/* end if */
        -:  919:        
      543:  920:        DestPtr = DestPtr->Next;
        -:  921:        
      543:  922:    }while((MatchFound == FALSE)&&(DestPtr != NULL));
        -:  923:
        -:  924:    /* if 'Destinations' was decremented to zero above... */
      404:  925:    if(CFE_SB.RoutingTbl[Idx].Destinations==0){
      372:  926:        CFE_SB.StatTlmMsg.MsgIdsInUse--;
      372:  927:        CFE_SB.RoutingTbl[Idx].MsgId = CFE_SB_INVALID_MSG_ID;
      372:  928:        CFE_SB_SetRoutingTblIdx(MsgId,CFE_SB_AVAILABLE);
        -:  929:
        -:  930:        /* Send unsubscribe report only if there are zero requests for this pkt */
      372:  931:        if((CFE_SB.SubscriptionReporting == CFE_SB_ENABLE)&&
        -:  932:          (Scope == CFE_SB_GLOBAL))
        -:  933:        {
        1:  934:          CFE_SB.SubRprtMsg.MsgId = MsgId;
        1:  935:          CFE_SB.SubRprtMsg.Pipe = PipeId;
        1:  936:          CFE_SB.SubRprtMsg.Qos.Priority = 0;
        1:  937:          CFE_SB.SubRprtMsg.Qos.Reliability = 0;
        1:  938:          CFE_SB.SubRprtMsg.SubType = CFE_SB_UNSUBSCRIPTION;
        1:  939:          CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1:  940:          Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.SubRprtMsg);
        1:  941:          CFE_EVS_SendEventWithAppID(CFE_SB_UNSUBSCRIPTION_RPT_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  942:            "Sending Unsubscription Report Msg=0x%x,Pipe=%d,Stat=0x%x",
        -:  943:            MsgId,PipeId,Stat);
        1:  944:          CFE_SB_LockSharedData(__FILE__,__LINE__);
        -:  945:        }/* end if */
        -:  946:
        -:  947:    }/* end if */
        -:  948:
      404:  949:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -:  950:
      404:  951:    CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_REMOVED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  952:            "Subscription Removed:Msg 0x%x on pipe %d,app %s",
        -:  953:            MsgId,PipeId,CFE_SB_GetAppTskName(TskId));
        -:  954:
      404:  955:    return CFE_SUCCESS;
        -:  956:
      408:  957:}/* end CFE_SB_UnsubscribeFull */
        -:  958:
        -:  959:
        -:  960:
        -:  961:/******************************************************************************
        -:  962:** Name:    CFE_SB_SendMsg
        -:  963:**
        -:  964:** Purpose: API used to send a message on the software bus.
        -:  965:**
        -:  966:** Assumptions, External Events, and Notes:
        -:  967:**
        -:  968:**          Note: This function increments and tracks the source sequence
        -:  969:**                counter for all telemetry messages.
        -:  970:**
        -:  971:** Date Written:
        -:  972:**          04/25/2005
        -:  973:**
        -:  974:** Input Arguments:
        -:  975:**          MsgPtr
        -:  976:**
        -:  977:** Output Arguments:
        -:  978:**          None
        -:  979:**
        -:  980:** Return Values:
        -:  981:**          Status
        -:  982:**
        -:  983:******************************************************************************/
        -:  984:int32  CFE_SB_SendMsg(CFE_SB_Msg_t    *MsgPtr)
       23:  985:{
        -:  986:    CFE_SB_MsgId_t          MsgId;
        -:  987:    int32                   Status;
       23:  988:    CFE_SB_DestinationD_t   *DestPtr = NULL;
        -:  989:    CFE_SB_PipeD_t          *PipeDscPtr;
        -:  990:    CFE_SB_RouteEntry_t     *RtgTblPtr;
        -:  991:    CFE_SB_BufferD_t        *BufDscPtr;
        -:  992:    uint16                  TotalMsgSize;
        -:  993:    uint16                  RtgTblIdx;
       23:  994:    uint32                  TskId = 0;
        -:  995:    uint16                  i;
        -:  996:
        -:  997:    /* get task id for events and Sender Info*/
       23:  998:    TskId = OS_TaskGetId();
        -:  999:
        -: 1000:    /* check input parameter */
       23: 1001:    if(MsgPtr == NULL){
        1: 1002:        CFE_SB_LockSharedData(__FILE__,__LINE__);
        1: 1003:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        1: 1004:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1: 1005:        CFE_EVS_SendEventWithAppID(CFE_SB_SEND_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1006:            "Send Err:Bad input argument,Arg 0x%x,App %s",
        -: 1007:            (uint32)MsgPtr,CFE_SB_GetAppTskName(TskId));
        1: 1008:        return CFE_SB_BAD_ARGUMENT;
        -: 1009:    }/* end if */
        -: 1010:
       22: 1011:    MsgId = CFE_SB_GetMsgId(MsgPtr);
        -: 1012:
        -: 1013:    /* validate the msgid in the message */
       22: 1014:    if(CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS){
        1: 1015:        CFE_SB_LockSharedData(__FILE__,__LINE__);
        1: 1016:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        1: 1017:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1: 1018:        CFE_EVS_SendEventWithAppID(CFE_SB_SEND_INV_MSGID_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1019:            "Send Err:Invalid MsgId(0x%x)in msg,App %s",
        -: 1020:            MsgId,CFE_SB_GetAppTskName(TskId));
        1: 1021:        return CFE_SB_BAD_ARGUMENT;
        -: 1022:    }/* end if */
        -: 1023:
       21: 1024:    TotalMsgSize = CFE_SB_GetTotalMsgLength(MsgPtr);
        -: 1025:
        -: 1026:    /* Verify the size of the pkt is < or = the mission defined max */
       21: 1027:    if(TotalMsgSize > CFE_SB_MAX_SB_MSG_SIZE){
        1: 1028:        CFE_SB_LockSharedData(__FILE__,__LINE__);
        1: 1029:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        1: 1030:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1: 1031:        CFE_EVS_SendEventWithAppID(CFE_SB_MSG_TOO_BIG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1032:            "Send Err:Msg Too Big MsgId=0x%x,app=%s,size=%d,MaxSz=%d",
        -: 1033:            MsgId,CFE_SB_GetAppTskName(TskId),TotalMsgSize,CFE_SB_MAX_SB_MSG_SIZE);
        1: 1034:        return CFE_SB_MSG_TOO_BIG;
        -: 1035:    }/* end if */
        -: 1036:
        -: 1037:    /* take semaphore to prevent a task switch during this call */
       20: 1038:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -: 1039:
       20: 1040:    RtgTblIdx = CFE_SB_GetRoutingTblIdx(MsgId);
        -: 1041:
        -: 1042:    /* if there have been no subscriptions for this pkt, */
        -: 1043:    /* increment the dropped pkt cnt, send event and return success */      
       20: 1044:    if(RtgTblIdx == CFE_SB_AVAILABLE){
        -: 1045:    
        9: 1046:        CFE_SB.HKTlmMsg.NoSubscribersCnt++;
        9: 1047:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1048:
        -: 1049:        /* Determine if event can be sent without causing recursive event problem */
        9: 1050:        if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_SEND_NO_SUBS_EID_BIT) == CFE_SB_GRANTED){
        -: 1051:
        9: 1052:           CFE_EVS_SendEventWithAppID(CFE_SB_SEND_NO_SUBS_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -: 1053:              "No subscribers for MsgId 0x%x,sender %s",
        -: 1054:              MsgId,CFE_SB_GetAppTskName(TskId));
        -: 1055:
        -: 1056:           /* clear the bit so the task may send this event again */
        9: 1057:           CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_SEND_NO_SUBS_EID_BIT);
        -: 1058:        }/* end if */
        -: 1059:
        9: 1060:        return CFE_SUCCESS;
        -: 1061:    }/* end if */
        -: 1062:
        -: 1063:    /* Allocate a new buffer. */
       11: 1064:    BufDscPtr = CFE_SB_GetBufferFromPool(MsgId, TotalMsgSize);
       11: 1065:    if (BufDscPtr == NULL){
        2: 1066:        CFE_SB.HKTlmMsg.MsgSendErrCnt++;
        2: 1067:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1068:
        -: 1069:        /* Determine if event can be sent without causing recursive event problem */
        2: 1070:        if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_GET_BUF_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1071:
        2: 1072:            CFE_EVS_SendEventWithAppID(CFE_SB_GET_BUF_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1073:              "Send Err:Request for Buffer Failed. MsgId 0x%x,app %s,size %d",
        -: 1074:              MsgId,CFE_SB_GetAppTskName(TskId),TotalMsgSize);
        -: 1075:
        -: 1076:            /* clear the bit so the task may send this event again */
        2: 1077:            CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_GET_BUF_ERR_EID_BIT);
        -: 1078:        }/* end if */
        -: 1079:
        2: 1080:        return CFE_SB_BUF_ALOC_ERR;
        -: 1081:    }/* end if */
        -: 1082:
        -: 1083:    /* Copy the packet into the SB memory space */
        9: 1084:    OS_MemCpy( BufDscPtr->Buffer, MsgPtr, (uint16)TotalMsgSize );
        -: 1085:
        -: 1086:    /* For Tlm packets, increment the seq count */
        9: 1087:    if(CFE_SB_GetPktType(MsgId)==CFE_SB_TLM){
        9: 1088:        CFE_SB.RoutingTbl[RtgTblIdx].SeqCnt++;
        9: 1089:        CFE_SB_SetMsgSeqCnt((CFE_SB_Msg_t *)BufDscPtr->Buffer,
        -: 1090:                              CFE_SB.RoutingTbl[RtgTblIdx].SeqCnt);
        -: 1091:    }/* end if */
        -: 1092:
        -: 1093:    /* store the sender information */
        9: 1094:    BufDscPtr->Sender.ProcessorId = OS_BSPGetProcessorId();
        9: 1095:    strncpy(&BufDscPtr->Sender.AppName[0],CFE_SB_GetAppTskName(TskId),OS_MAX_API_NAME);
        -: 1096:
        9: 1097:    RtgTblPtr = &CFE_SB.RoutingTbl[RtgTblIdx];
        -: 1098:
        -: 1099:    /* At this point there must be at least one destination for pkt */
        -: 1100:    
        9: 1101:    DestPtr = RtgTblPtr -> ListHeadPtr;
        -: 1102:
        -: 1103:    /* Send the packet to all destinations  */
       18: 1104:    for (i=0; i < RtgTblPtr -> Destinations; i++) {
        -: 1105:
        9: 1106:        if (DestPtr->Active == CFE_SB_INACTIVE)    /* destination is inactive */             
        -: 1107:        {            
        1: 1108:            DestPtr = DestPtr -> Next;
        1: 1109:            continue;
        -: 1110:        }
        -: 1111:
        8: 1112:        PipeDscPtr = &CFE_SB.PipeTbl[DestPtr->PipeId]; 
        -: 1113:
        -: 1114:        /* if MsgId-to-Pipe limit exceeded, send an event, increment counter */
        -: 1115:        /* and go to next destination */
        8: 1116:        if(DestPtr->BuffCount >= DestPtr->MsgId2PipeLim){
        1: 1117:            CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1118:
        -: 1119:            /* Determine if event can be sent without causing recursive event problem */
        1: 1120:            if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_MSGID_LIM_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1121:
        1: 1122:              CFE_EVS_SendEventWithAppID(CFE_SB_MSGID_LIM_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1123:                "Send Err:MsgId-to-Pipe Lim Exceeded MsgId 0x%x,pipe %s,sender %s",
        -: 1124:                RtgTblPtr->MsgId,CFE_SB_GetPipeName(DestPtr->PipeId),CFE_SB_GetAppTskName(TskId));
        -: 1125:
        -: 1126:              /* clear the bit so the task may send this event again */
        1: 1127:              CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_MSGID_LIM_ERR_EID_BIT);
        -: 1128:            }/* end if */
        -: 1129:
        1: 1130:            CFE_SB_LockSharedData(__FILE__,__LINE__);
        1: 1131:            CFE_SB.HKTlmMsg.MsgIdToPipeErrCnt++;
        1: 1132:            PipeDscPtr->SendErrors++;
        1: 1133:            DestPtr = DestPtr -> Next;
        1: 1134:            continue;
        -: 1135:        }
        -: 1136:
        -: 1137:        /*
        -: 1138:        ** Write the buffer to the queue of the pipe.  If the write
        -: 1139:        ** failed, release the buffer and increment the pipe's error counter.
        -: 1140:        */
        7: 1141:        Status = CFE_SB_WriteQueue(PipeDscPtr, TskId, BufDscPtr, RtgTblPtr->MsgId);
        -: 1142:
        7: 1143:        if (Status == CFE_SUCCESS) {
        5: 1144:            BufDscPtr->UseCount++;    /* used for releasing buffer  */
        5: 1145:            DestPtr->BuffCount++; /* used for checking MsgId2PipeLimit */
        5: 1146:            DestPtr->DestCnt++;   /* used for statistics */
        5: 1147:            CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].InUse++;
        5: 1148:            if(CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].InUse >
        -: 1149:               CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].PeakInUse){
        5: 1150:                CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].PeakInUse =
        -: 1151:                CFE_SB.StatTlmMsg.PipeDepthStats[DestPtr->PipeId].InUse;
        -: 1152:            }/* end if */
        -: 1153:
        -: 1154:        }/*end if */
        -: 1155:
        7: 1156:        DestPtr = DestPtr -> Next;
        -: 1157:
        -: 1158:    } /* end loop over destinations */
        -: 1159:    
        -: 1160:    /*
        -: 1161:    ** Decrement the buffer UseCount and free buffer if cnt=0. This decrement is done
        -: 1162:    ** because the use cnt is initialized to 1 in CFE_SB_GetBufferFromPool.
        -: 1163:    ** Initializing the count to 1 (as opposed to zero) and decrementing it here are
        -: 1164:    ** done to ensure the buffer gets released when there are destinations that have
        -: 1165:    ** been disabled via ground command.
        -: 1166:    */
        9: 1167:    CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1168:
        -: 1169:    /* release the semaphore */
        9: 1170:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1171:
        9: 1172:    return CFE_SUCCESS;
        -: 1173:
       23: 1174:}/* end CFE_SB_SendMsg */
        -: 1175:
        -: 1176:
        -: 1177:
        -: 1178:/******************************************************************************
        -: 1179:** Name:    CFE_SB_RcvMsg
        -: 1180:**
        -: 1181:** Purpose: API used to receive a message from the software bus.
        -: 1182:**
        -: 1183:** Assumptions, External Events, and Notes:
        -: 1184:**          Notes:
        -: 1185:**
        -: 1186:**
        -: 1187:** Date Written:
        -: 1188:**          04/25/2005
        -: 1189:**
        -: 1190:** Input Arguments:
        -: 1191:**          PipeId
        -: 1192:**          BufPtr
        -: 1193:**          timeOut - CFE_SB_PEND, CFE_SB_POLL or millisecond timeout
        -: 1194:**
        -: 1195:** Output Arguments:
        -: 1196:**          None
        -: 1197:**
        -: 1198:** Return Values:
        -: 1199:**          Status
        -: 1200:**
        -: 1201:******************************************************************************/
        -: 1202:int32  CFE_SB_RcvMsg(CFE_SB_MsgPtr_t    *BufPtr,
        -: 1203:                     CFE_SB_PipeId_t    PipeId,
        -: 1204:                     int32              TimeOut)
      178: 1205:{
        -: 1206:    int32                  Status;
        -: 1207:    CFE_SB_BufferD_t       *Message;
        -: 1208:    CFE_SB_PipeD_t         *PipeDscPtr;
      178: 1209:    CFE_SB_DestinationD_t  *DestPtr = NULL;
      178: 1210:    uint32                 TskId = 0;
        -: 1211:
        -: 1212:    /* get task id for events */
      178: 1213:    TskId = OS_TaskGetId();
        -: 1214:
        -: 1215:    /* Check input parameters */
      178: 1216:    if((BufPtr == NULL)||(TimeOut < (-1))){
        1: 1217:        CFE_SB_LockSharedData(__FILE__,__LINE__);
        1: 1218:        CFE_SB.HKTlmMsg.MsgReceiveErrCnt++;
        1: 1219:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1: 1220:        CFE_EVS_SendEventWithAppID(CFE_SB_RCV_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1221:            "Rcv Err:Bad Input Arg:BufPtr 0x%x,pipe %d,t/o %d,app %s",
        -: 1222:            (uint32)BufPtr,PipeId,TimeOut,CFE_SB_GetAppTskName(TskId));
        1: 1223:        return CFE_SB_BAD_ARGUMENT;
        -: 1224:    }/* end if */
        -: 1225:
        -: 1226:    /* take semaphore to prevent a task switch during this call */
      177: 1227:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -: 1228:
      177: 1229:    PipeDscPtr = CFE_SB_GetPipePtr(PipeId);
        -: 1230:    /* If the pipe does not exist or PipeId is out of range... */
      177: 1231:    if (PipeDscPtr == NULL) {
        1: 1232:        CFE_SB.HKTlmMsg.MsgReceiveErrCnt++;
        1: 1233:        CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1: 1234:        CFE_EVS_SendEventWithAppID(CFE_SB_BAD_PIPEID_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1235:            "Rcv Err:PipeId %d does not exist,app %s",
        -: 1236:            PipeId,CFE_SB_GetAppTskName(TskId));
        1: 1237:        return CFE_SB_BAD_ARGUMENT;
        -: 1238:    }/* end if */
        -: 1239:
        -: 1240:    /*
        -: 1241:    ** If a buffer is currently in use by the pipe, decrement the
        -: 1242:    ** use count and if its zero, return the buffer to the pool.
        -: 1243:    */
      176: 1244:    if (PipeDscPtr->CurrentBuff != NULL) {
        -: 1245:
        -: 1246:        /* Decrement the Buffer Use Count and Free buffer if cnt=0) */
        5: 1247:        CFE_SB_DecrBufUseCnt(PipeDscPtr->CurrentBuff);
        -: 1248:
        5: 1249:        PipeDscPtr->CurrentBuff = NULL;
        -: 1250:
        -: 1251:    }/* end if */
        -: 1252:
        -: 1253:    /* release the semaphore since the read queue call will likely block */
      176: 1254:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1255:
        -: 1256:    /*
        -: 1257:    ** Read a new buffer from the queue of the pipe, using the
        -: 1258:    ** specified timeout option.  If a buffer was obtained, return the
        -: 1259:    ** packet to the task according to mode.  Otherwise, return a status
        -: 1260:    ** code indicating that no buffer was read.
        -: 1261:    */
      176: 1262:    Status = CFE_SB_ReadQueue(PipeDscPtr, TskId, TimeOut, &Message);
        -: 1263:
        -: 1264:    /* take semaphore again to protect the remaining code in this call */
      176: 1265:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -: 1266:
      176: 1267:    if (Status == CFE_SUCCESS) {
        -: 1268:
        -: 1269:        /*
        -: 1270:        ** Load the pipe tables 'CurrentBuff' with the buffer descriptor
        -: 1271:        ** ptr corresponding to the message just read. This is done so that
        -: 1272:        ** the buffer can be released on the next RcvMsg call for this pipe.
        -: 1273:        */
        5: 1274:        PipeDscPtr->CurrentBuff = Message;
        -: 1275:
        -: 1276:        /* Set the Receivers pointer to the address of the actual message */
        5: 1277:        *BufPtr = (CFE_SB_MsgPtr_t) Message->Buffer;
        -: 1278:
        -: 1279:        /* get pointer to destination to be used in decrementing msg limit cnt*/
        5: 1280:        DestPtr = CFE_SB_GetDestPtr(PipeDscPtr->CurrentBuff->MsgId, PipeDscPtr->PipeId);
        -: 1281:
        -: 1282:        /*
        -: 1283:        ** Also decrement the message limit count in the destination descriptor
        -: 1284:        ** used for the MsgId-to-Pipe limit check.
        -: 1285:        ** Note:There is a chance that this call to CFE_SB_DecrMsgLimCnt will return
        -: 1286:        ** a failure status.It may happen if a msg is unsubscribed to while it is on
        -: 1287:        ** the pipe (DestPtr will be NULL). The code is designed to handle this
        -: 1288:        ** situation without a problem. See DCR3217 for more detail.
        -: 1289:        */
        5: 1290:        CFE_SB_DecrMsgLimCnt(DestPtr);
        -: 1291:
        5: 1292:        CFE_SB.StatTlmMsg.PipeDepthStats[PipeDscPtr->PipeId].InUse--;
        -: 1293:    
        -: 1294:    }else{
        -: 1295:    
        -: 1296:        /* Set the users pointer to NULL indicating the CFE_SB_ReadQueue failed */
      171: 1297:        *BufPtr = NULL;
        -: 1298:    
        -: 1299:    }/* end if */
        -: 1300:
        -: 1301:    /* release the semaphore */
      176: 1302:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1303:
        -: 1304:    /*
        -: 1305:    ** If status is not CFE_SUCCESS, then no packet was received.  If this was
        -: 1306:    ** caused by an unexpected error, then CFE_SB_ReadQueue() will report the
        -: 1307:    ** error.
        -: 1308:    */
      176: 1309:    return Status;
        -: 1310:
      178: 1311:}/* end CFE_SB_RcvMsg */
        -: 1312:
        -: 1313:
        -: 1314:/******************************************************************************
        -: 1315:** Name:    CFE_SB_GetLastSenderId
        -: 1316:**
        -: 1317:** Purpose: API used for receiving sender Information of the last message received on
        -: 1318:**          the given pipe.
        -: 1319:**
        -: 1320:** Assumptions, External Events, and Notes:
        -: 1321:**          None
        -: 1322:**
        -: 1323:** Date Written:
        -: 1324:**          06/13/2007
        -: 1325:**
        -: 1326:** Input Arguments:
        -: 1327:**          Ptr -     caller declares a ptr of type CFE_SB_SenderId_t then gives the
        -: 1328:**                    address of that pointer.
        -: 1329:**          PipeId -  the Pipe Id that the message was received on.
        -: 1330:**
        -: 1331:** Output Arguments:
        -: 1332:**          None
        -: 1333:**
        -: 1334:** Return Values:
        -: 1335:**          Status
        -: 1336:**
        -: 1337:******************************************************************************/
        -: 1338:uint32  CFE_SB_GetLastSenderId(CFE_SB_SenderId_t **Ptr,CFE_SB_PipeId_t  PipeId)
        4: 1339:{
        -: 1340:
        -: 1341:    CFE_SB_BufferD_t *Ptr2BufDescriptor;
        4: 1342:    uint32            TskId = 0;
        4: 1343:    uint32            AppId = 0;
        -: 1344:
        4: 1345:    TskId = OS_TaskGetId();
        -: 1346:
        -: 1347:    /* validate ptr  - note: must validate ptr before pipe id validation  */
        -: 1348:    /* because an invalid pipe id sets the callers pointer to NULL */
        4: 1349:    if(Ptr == NULL){
        1: 1350:      CFE_EVS_SendEventWithAppID(CFE_SB_LSTSNDER_ERR1_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1351:          "SB GetLastSender Err:Rcvd Null Ptr,Pipe=%d,App=%s",
        -: 1352:          PipeId,CFE_SB_GetAppTskName(TskId));
        1: 1353:      return CFE_SB_BAD_ARGUMENT;
        -: 1354:    }/* end if */
        -: 1355:
        -: 1356:    /* validate pipe id */
        3: 1357:    if(CFE_SB_ValidatePipeId(PipeId)!=CFE_SUCCESS){
        1: 1358:      *Ptr = NULL;
        1: 1359:      CFE_EVS_SendEventWithAppID(CFE_SB_LSTSNDER_ERR2_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1360:          "SB GetLastSender Err:Rcvd Invalid Pipe=%d,App=%s",
        -: 1361:          PipeId,CFE_SB_GetAppTskName(TskId));
        1: 1362:      return CFE_SB_BAD_ARGUMENT;
        -: 1363:    }/* end if */
        -: 1364:
        2: 1365:    CFE_ES_GetAppID(&AppId);
        -: 1366:
        2: 1367:    CFE_SB_LockSharedData(__FILE__,__LINE__);
        -: 1368:
        -: 1369:    /* verify requestor is owner of pipe */
        2: 1370:    if(CFE_SB.PipeTbl[PipeId].AppId != AppId){
        1: 1371:      *Ptr = NULL;
        1: 1372:      CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        1: 1373:      CFE_EVS_SendEventWithAppID(CFE_SB_GLS_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1374:          "SB GetLastSender Err:Caller(%s) is not the owner of pipe %d",
        -: 1375:          CFE_SB_GetAppTskName(TskId),PipeId);
        1: 1376:      return CFE_SB_BAD_ARGUMENT;
        -: 1377:    }/* end if */
        -: 1378:
        -: 1379:    /* Get ptr to buffer descriptor for the last msg received on the given pipe */
        1: 1380:    Ptr2BufDescriptor = CFE_SB.PipeTbl[PipeId].CurrentBuff;
        -: 1381:
        -: 1382:    /* Set the receivers pointer to the adr of 'Sender' struct in buf descriptor */
        1: 1383:    *Ptr = (CFE_SB_SenderId_t *) &Ptr2BufDescriptor -> Sender;
        -: 1384:
        1: 1385:    CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1386:
        1: 1387:    return CFE_SUCCESS;
        -: 1388:
        4: 1389:}/* end CFE_SB_GetLastSenderId */
        -: 1390:
        -: 1391:
        -: 1392:/******************************************************************************
        -: 1393:** Name:    CFE_SB_ZeroCopyGetPtr
        -: 1394:**
        -: 1395:** Purpose: API used for for getting a pointer to a buffer (for zero copy mode
        -: 1396:**          only)
        -: 1397:**
        -: 1398:** Assumptions, External Events, and Notes:
        -: 1399:**          None
        -: 1400:**
        -: 1401:** Date Written:
        -: 1402:**          04/25/2005
        -: 1403:**
        -: 1404:** Input Arguments:
        -: 1405:**          MsgSize
        -: 1406:**
        -: 1407:** Output Arguments:
        -: 1408:**          None
        -: 1409:**
        -: 1410:** Return Values:
        -: 1411:**          Pointer to an empty buffer in SB Memory space
        -: 1412:**
        -: 1413:******************************************************************************/
        -: 1414:CFE_SB_Msg_t  *CFE_SB_ZeroCopyGetPtr(uint16 MsgSize)
        1: 1415:{
        1: 1416:    return NULL;
        -: 1417:
        1: 1418:}/* end CFE_SB_ZeroCopyGetPtr */
        -: 1419:
        -: 1420:
        -: 1421:
        -: 1422:/******************************************************************************
        -: 1423:** Name:    CFE_SB_ZeroCopyReleasePtr
        -: 1424:**
        -: 1425:** Purpose: API used for releasing a pointer to a buffer (for zero copy mode
        -: 1426:**          only) This function is typically not needed for zero copy transfers.
        -: 1427:**          This function is needed only when a ptr is received via
        -: 1428:**          CFE_SB_ZeroCopyGetPtr, but never used in a send.
        -: 1429:**
        -: 1430:** Assumptions, External Events, and Notes:
        -: 1431:**          None
        -: 1432:**
        -: 1433:** Date Written:
        -: 1434:**          04/25/2005
        -: 1435:**
        -: 1436:** Input Arguments:
        -: 1437:**          Ptr2Release
        -: 1438:**
        -: 1439:** Output Arguments:
        -: 1440:**          None
        -: 1441:**
        -: 1442:** Return Values:
        -: 1443:**          Status
        -: 1444:**
        -: 1445:******************************************************************************/
        -: 1446:int32 CFE_SB_ZeroCopyReleasePtr(CFE_SB_Msg_t  *Ptr2Release)
        1: 1447:{
        1: 1448:    return CFE_SB_NOT_IMPLEMENTED;
        -: 1449:
        1: 1450:}/* end CFE_SB_ZeroCopyReleasePtr */
        -: 1451:
        -: 1452:
        -: 1453:/******************************************************************************
        -: 1454:** Name:    CFE_SB_ZeroCopySend
        -: 1455:**
        -: 1456:** Purpose: API for sending messages in zero copy mode
        -: 1457:**
        -: 1458:** Assumptions, External Events, and Notes:
        -: 1459:**          None
        -: 1460:**
        -: 1461:** Date Written:
        -: 1462:**          04/25/2005
        -: 1463:**
        -: 1464:** Input Arguments:
        -: 1465:**          MsgPtr - Pointer to message to be sent
        -: 1466:**
        -: 1467:** Output Arguments:
        -: 1468:**          None
        -: 1469:**
        -: 1470:** Return Values:
        -: 1471:**          Status
        -: 1472:**
        -: 1473:******************************************************************************/
        -: 1474:int32 CFE_SB_ZeroCopySend(CFE_SB_Msg_t   *MsgPtr)
        1: 1475:{
        1: 1476:    return CFE_SB_NOT_IMPLEMENTED;
        -: 1477:
        1: 1478:}/* end CFE_SB_ZeroCopySend */
        -: 1479:
        -: 1480:
        -: 1481:/******************************************************************************
        -: 1482:**  Function:  CFE_SB_ReadQueue()
        -: 1483:**
        -: 1484:**  Purpose:
        -: 1485:**    Read an SB message from the system queue.  The message is represented
        -: 1486:**    by a pointer to the buffer descriptor of the message.  Several options
        -: 1487:**    are available for the timeout, as described below.
        -: 1488:**
        -: 1489:**  Arguments:
        -: 1490:**    PipeDscPtr: Pointer to pipe descriptor.
        -: 1491:**    AppId     : Application ID of the receiving task (used for error messages).
        -: 1492:**    Time_Out  : Timeout option; one of the following:
        -: 1493:**                  CFE_SB_PEND_FOREVER  = wait forever until a packet arrives
        -: 1494:**                  CFE_SB_POLL = check the pipe for packets but don't wait
        -: 1495:**                  value in milliseconds = wait up to a specified time
        -: 1496:**    Message   : Pointer to a variable that will receive the buffer
        -: 1497:**                descriptor of the message.
        -: 1498:**
        -: 1499:**  Return:
        -: 1500:**    CFE_SB status code indicating the result of the operation:
        -: 1501:**      CFE_SUCCESS         = message was successfully read
        -: 1502:**      CFE_SB_NO_MESSAGE   = no message is present (for CFE_SB_POLL option)
        -: 1503:**      CFE_SB_TIME_OUT     = timeout expired (for timeout option)
        -: 1504:**      CFE_SB_PIPE_RD_ERR  = an unexpected queue read error occurred
        -: 1505:*/
        -: 1506:
        -: 1507:int32  CFE_SB_ReadQueue (CFE_SB_PipeD_t         *PipeDscPtr,
        -: 1508:                         uint32                 TskId,
        -: 1509:                         CFE_SB_TimeOut_t       Time_Out,
        -: 1510:                         CFE_SB_BufferD_t       **Message)
      176: 1511:{
        -: 1512:    int32              Status,TimeOut;
        -: 1513:    uint32             Nbytes;
        -: 1514:
        -: 1515:    /* translate the given Time_Out value */
      176: 1516:    switch(Time_Out){
        -: 1517:
        -: 1518:      case CFE_SB_PEND_FOREVER:
        4: 1519:          TimeOut = OS_PEND;
        4: 1520:          break;
        -: 1521:
        -: 1522:      case CFE_SB_POLL:
      171: 1523:          TimeOut = OS_CHECK;
      171: 1524:          break;
        -: 1525:
        -: 1526:      default:
        1: 1527:          TimeOut = Time_Out;
        -: 1528:          break;
        -: 1529:
        -: 1530:    }/* end switch */
        -: 1531:
        -: 1532:    /* Read the buffer descriptor address from the queue.  */
      176: 1533:    Status = OS_QueueGet(PipeDscPtr->SysQueueId,
        -: 1534:                        (void *)Message,
        -: 1535:                        sizeof(CFE_SB_BufferD_t *),
        -: 1536:                        &Nbytes,
        -: 1537:                        TimeOut);
        -: 1538:
        -: 1539:    /* translate the return value */
      176: 1540:    switch(Status){
        -: 1541:
        -: 1542:      case OS_SUCCESS:
        5: 1543:          return CFE_SUCCESS;
        -: 1544:          break;
        -: 1545:
        -: 1546:      case OS_QUEUE_EMPTY:
      168: 1547:          return CFE_SB_NO_MESSAGE;
        -: 1548:          break;
        -: 1549:
        -: 1550:      case OS_QUEUE_TIMEOUT:
        1: 1551:          return CFE_SB_TIME_OUT;
        -: 1552:          break;
        -: 1553:
        -: 1554:      default:
        2: 1555:          CFE_SB_LockSharedData(__FILE__,__LINE__);
        2: 1556:          CFE_SB.HKTlmMsg.InternalErrCnt++;
        2: 1557:          CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1558:          /* Unexpected error while reading the queue. */
        2: 1559:          CFE_EVS_SendEventWithAppID(CFE_SB_Q_RD_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1560:              "Pipe Read Err,pipe %s,app %s,stat 0x%x",
        -: 1561:              CFE_SB_GetPipeName(PipeDscPtr->PipeId),CFE_SB_GetAppTskName(TskId),Status);
        -: 1562:
        2: 1563:          return CFE_SB_PIPE_RD_ERR;
        -: 1564:          break;
        -: 1565:
        -: 1566:    }/* end switch */
        -: 1567:
      176: 1568:}/* end CFE_SB_ReadQueue */
        -: 1569:
        -: 1570:
        -: 1571:/******************************************************************************
        -: 1572:**  Function:  CFE_SB_WriteQueue()
        -: 1573:**
        -: 1574:**  Purpose:
        -: 1575:**    Write an SB message to the system queue.  The message is represented
        -: 1576:**    by a pointer to the buffer descriptor of the message.
        -: 1577:**
        -: 1578:**  Arguments:
        -: 1579:**    PipeDscPtr: Pointer to pipe descriptor.
        -: 1580:**    AppId     : Application ID of the sending task (used for error messages).
        -: 1581:**    BufDscPtr : Pointer to buffer descriptor of the message.
        -: 1582:**    MsgId     : Message ID of the packet (used for error messages).
        -: 1583:**
        -: 1584:**  Return:
        -: 1585:**      CFE_SUCCESS          = message was successfully written
        -: 1586:**      CFE_SB_PIPE_OVERFLOW = pipe is full; no more messages can be accepted
        -: 1587:**      CFE_SB_PIPE_WR_ERR   = an unexpected queue write error occurred
        -: 1588:**
        -: 1589:**  Assumptions:
        -: 1590:**      SB Shared Data semaphore is locked prior to calling this routine.
        -: 1591:*/
        -: 1592:
        -: 1593:int32  CFE_SB_WriteQueue (CFE_SB_PipeD_t            *PipeDscPtr,
        -: 1594:                          uint32                    TskId,
        -: 1595:                          const CFE_SB_BufferD_t    *BufDscPtr,
        -: 1596:                          CFE_SB_MsgId_t            MsgId)
        7: 1597:{
        -: 1598:    int32             Status;
        -: 1599:
        -: 1600:    /* Write the buffer descriptor address to the queue.  */
        7: 1601:    Status = OS_QueuePut(PipeDscPtr->SysQueueId,(void *)&BufDscPtr,sizeof(CFE_SB_BufferD_t *),0);
        -: 1602:
        -: 1603:    /* translate the return value */
        7: 1604:    switch(Status){
        -: 1605:
        -: 1606:      case OS_SUCCESS:
        5: 1607:          return CFE_SUCCESS;
        -: 1608:          break;
        -: 1609:
        -: 1610:      case OS_QUEUE_FULL:
        1: 1611:          CFE_SB.HKTlmMsg.PipeOverflowErrCnt++;
        1: 1612:          PipeDscPtr->SendErrors++;
        1: 1613:          CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1614:
        -: 1615:          /* Determine if event can be sent without causing recursive event problem */
        1: 1616:          if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_Q_FULL_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1617:
        1: 1618:            CFE_EVS_SendEventWithAppID(CFE_SB_Q_FULL_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1619:                "Pipe Overflow,MsgId 0x%x,pipe %s,stat 0x%x,app %s",
        -: 1620:                MsgId,CFE_SB_GetPipeName(PipeDscPtr->PipeId),Status,CFE_SB_GetAppTskName(TskId));
        -: 1621:
        -: 1622:             /* clear the bit so the task may send this event again */
        1: 1623:             CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_Q_FULL_ERR_EID_BIT);
        -: 1624:          }/* end if */
        -: 1625:
        1: 1626:          CFE_SB_LockSharedData(__FILE__,__LINE__);
        1: 1627:          return CFE_SB_PIPE_OVERFLOW;
        -: 1628:          break;
        -: 1629:
        -: 1630:      default:
        -: 1631:          /* Unexpected error while writing to queue. */
        1: 1632:          CFE_SB.HKTlmMsg.InternalErrCnt++;
        1: 1633:          PipeDscPtr->SendErrors++;
        1: 1634:          CFE_SB_UnlockSharedData(__FILE__,__LINE__);
        -: 1635:
        -: 1636:          /* Determine if event can be sent without causing recursive event problem */
        1: 1637:          if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_Q_WR_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1638:
        1: 1639:            CFE_EVS_SendEventWithAppID(CFE_SB_Q_WR_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1640:              "Pipe Write Err,MsgId 0x%x,pipe %s,stat 0x%x,app %s",
        -: 1641:              MsgId,CFE_SB_GetPipeName(PipeDscPtr->PipeId),Status,CFE_SB_GetAppTskName(TskId));
        -: 1642:
        -: 1643:             /* clear the bit so the task may send this event again */
        1: 1644:             CFE_CLR(CFE_SB.StopRecurseFlags[TskId],CFE_SB_Q_WR_ERR_EID_BIT);
        -: 1645:          }/* end if */
        -: 1646:
        1: 1647:          CFE_SB_LockSharedData(__FILE__,__LINE__);
        1: 1648:          return CFE_SB_PIPE_WR_ERR;
        -: 1649:          break;
        -: 1650:
        -: 1651:    }/* end switch */
        -: 1652:
        7: 1653:}/* end CFE_SB_WriteQueue */
        -: 1654:
        -: 1655:/*****************************************************************************/
