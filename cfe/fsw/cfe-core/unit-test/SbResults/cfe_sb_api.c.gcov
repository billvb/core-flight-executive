        -:    0:Source:/home/sstrege/cFE650/cfe/fsw/cfe-core/src/sb/cfe_sb_api.c
        -:    0:Graph:cfe_sb_api.gcno
        -:    0:Data:cfe_sb_api.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/******************************************************************************
        -:    2:** File: cfe_sb_api.c
        -:    3:**
        -:    4:**      Copyright (c) 2004-2012, United States government as represented by the
        -:    5:**      administrator of the National Aeronautics Space Administration.
        -:    6:**      All rights reserved. This software(cFE) was created at NASA's Goddard
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This is governed by the NASA Open Source Agreement and may be used,
        -:   10:**      distributed and modified only pursuant to the terms of that agreement.
        -:   11:**
        -:   12:**
        -:   13:**
        -:   14:** Purpose:
        -:   15:**      This file contains the source code for the SB API's.
        -:   16:**
        -:   17:** Author:   R.McGraw/SSI
        -:   18:**
        -:   19:** $Log: cfe_sb_api.c  $
        -:   20:** Revision 1.40 2014/08/22 16:41:25GMT-05:00 lwalling 
        -:   21:** Change signed loop counters to unsigned
        -:   22:** Revision 1.39 2014/06/17 13:42:34EDT rmcgraw 
        -:   23:** DCR18686:1 Initialized all AppId and CallerID's with 0xFFFFFFFF
        -:   24:** Revision 1.38 2014/05/05 14:47:16EDT rmcgraw
        -:   25:** DCR19498:1 Fixed buffers in use count, was going negative for zero copy transfers
        -:   26:** Revision 1.37 2014/05/05 13:53:09EDT rmcgraw
        -:   27:** DCR19578:1 - Add UnlockSharedData for errors in ZeroCopyReleaseDesc
        -:   28:** Revision 1.36 2014/04/24 10:57:07EDT rmcgraw
        -:   29:** DCR19487:1 - Remove size argument in CFE_SB_GetBufferFromCaller
        -:   30:** Revision 1.35 2012/07/09 15:00:18EDT rmcgraw
        -:   31:** DCR19413:1 Release buf mem for zero cpy send, no subscribers and error cases
        -:   32:** Revision 1.34 2012/01/13 12:15:11EST acudmore
        -:   33:** Changed license text to reflect open source
        -:   34:** Revision 1.33 2012/01/06 09:27:19EST rmcgraw
        -:   35:** DCR16100:1 Added perf markers for msg lim and pipe overflow errors
        -:   36:** Revision 1.32 2011/12/20 10:25:30GMT-05:00 rmcgraw
        -:   37:** DCR15187:1 Removed function CFE_SB_DecrMsgLimCnt and MsgLim Counter error event
        -:   38:** Revision 1.31 2011/12/09 12:22:56EST rmcgraw
        -:   39:** DCR15763:1 Added call to LockSharedData for case of invalid pipe id rcvd in RcvMsg API
        -:   40:** Revision 1.30 2011/09/09 14:25:33EDT aschoeni
        -:   41:** Added fix for ZeroCopy issues
        -:   42:** Revision 1.29 2011/04/29 10:04:48EDT rmcgraw
        -:   43:** Add check for NULL ptr in send loop
        -:   44:** Revision 1.28 2011/04/28 10:37:31EDT rmcgraw
        -:   45:** Fixed compiler error
        -:   46:** Revision 1.27 2011/04/28 10:10:15EDT rmcgraw
        -:   47:** DCR14592:1 Fix for the SB Send semaphore problem
        -:   48:** Revision 1.26 2010/11/04 16:41:53EDT aschoeni
        -:   49:** Added optional sender information storage
        -:   50:** Revision 1.25 2010/11/04 14:27:15EDT aschoeni
        -:   51:** Optimized rcv function
        -:   52:** Revision 1.24 2010/11/03 15:07:01EDT jmdagost
        -:   53:** Added cfe.h include file.
        -:   54:** Revision 1.23 2009/07/29 19:23:26EDT aschoeni
        -:   55:** Updated for ZeroCopyHandle_t and GetPoolBufInfo
        -:   56:** Revision 1.22 2009/07/24 18:27:10EDT aschoeni
        -:   57:** Added Zero Copy Mode
        -:   58:** Revision 1.21 2009/07/20 14:10:54EDT aschoeni
        -:   59:** Made GetAppTskName reentrant
        -:   60:** Revision 1.20 2009/07/17 19:43:01EDT aschoeni
        -:   61:** Added PassMsg API to sb to support sequence count preservation
        -:   62:** Revision 1.19 2009/06/26 17:02:07EDT aschoeni
        -:   63:** Updated SB to use __func__ instead of __FILE__ for lock and unlock errors
        -:   64:** Revision 1.18 2009/06/10 09:17:57EDT acudmore
        -:   65:** Updated OS_Mem* and OS_BSP* to CFE_PSP_*
        -:   66:** Revision 1.17 2009/05/08 11:27:08EDT rmcgraw
        -:   67:** DCR7631:1 Removed index checks in Subscribe and Unsubscribe - dead code and cannot be tested
        -:   68:** Revision 1.16 2009/04/29 10:04:33EDT rmcgraw
        -:   69:** DCR5801:11 Changed subscription return value when buf allocation fails
        -:   70:** Revision 1.15 2009/03/30 10:45:01EDT rmcgraw
        -:   71:** DCR5801:2 Fixed infinite loop when deleting a pipe with subscriptions
        -:   72:** Revision 1.14 2009/02/26 17:57:39EST rmcgraw
        -:   73:** DCR6805:1 Corrected note under SendMsg API prolog regarding seq count
        -:   74:** Revision 1.13 2009/02/10 16:53:23EST rmcgraw
        -:   75:** DCR1700:1 Decrement pipes-in-use counter in DeletePipe API
        -:   76:** Revision 1.12 2009/02/10 12:29:07EST rmcgraw
        -:   77:** DCR6956:1 In Create Pipe API, set user's pipe id to invalid for error cases
        -:   78:** Revision 1.11 2009/02/10 11:25:56EST rmcgraw
        -:   79:** DCR1699:1 Removed pipe owner in five events
        -:   80:** Revision 1.10 2009/02/06 15:35:08EST rmcgraw
        -:   81:** DCR5801:3 Moved Total Msg Size test before the lock in the send api
        -:   82:** Revision 1.9 2009/02/06 11:29:04EST rmcgraw
        -:   83:** DCR5801:2 General Cleanup
        -:   84:** Revision 1.8 2009/02/03 16:33:29EST rmcgraw
        -:   85:** DCR5801:2 Fixed DestPtr errors in Send API
        -:   86:** Revision 1.7 2009/02/03 11:06:58EST rmcgraw
        -:   87:** DCR5801:2 Changed destination desciptors from array based to linked list
        -:   88:** Revision 1.6 2009/01/30 12:27:07EST rmcgraw
        -:   89:** DCR5801:5 Removed call to GetPipePtr in send API inside loop
        -:   90:** Revision 1.5 2009/01/30 11:50:07EST rmcgraw
        -:   91:** DCR5801:8 Set users ptr to null only when readqueue fails in rcv API
        -:   92:** Revision 1.4 2009/01/30 11:45:06EST rmcgraw
        -:   93:** DCR5801:9 Removed unused calls to GetAppID in send and rcv APIs
        -:   94:** Revision 1.3 2009/01/30 11:07:03EST rmcgraw
        -:   95:** DCR5801:3 Moved the semaphore lock in the send and rcv API's
        -:   96:** Revision 1.2 2009/01/30 10:34:57EST rmcgraw
        -:   97:** DCR5801:1 Began tracking subsribers with 'destinations' counter.
        -:   98:** Revision 1.1 2008/04/17 08:05:30EDT ruperera
        -:   99:** Initial revision
        -:  100:** Member added to cfe project on tlserver3
        -:  101:** Revision 1.74 2007/09/19 14:38:48EDT rjmcgraw
        -:  102:** DCR4421 Removed use count err events and reworded buf allocation error event
        -:  103:** Revision 1.73 2007/09/19 12:01:46EDT rjmcgraw
        -:  104:** Return code in unsubscribe changed from no subscribers to cfe success
        -:  105:** Revision 1.72 2007/09/13 09:34:09EDT rjmcgraw
        -:  106:** DCR4861:2 Added check in SendMsg to prevent recursive event problem
        -:  107:** Revision 1.71 2007/08/17 15:59:51EDT rjmcgraw
        -:  108:** Changes to free semaphore before calling SendEventWithAppId
        -:  109:** Revision 1.70 2007/07/12 16:58:22EDT rjmcgraw
        -:  110:** DCR4680:1 Removed SB event log related items
        -:  111:** Revision 1.69 2007/07/06 13:34:17EDT rjmcgraw
        -:  112:** DCR469:1 Added GetLastSender code
        -:  113:** Revision 1.68 2007/04/24 11:07:18EDT rjmcgraw
        -:  114:** Added PipeId to PipeDepthStats
        -:  115:** Revision 1.67 2007/04/24 09:34:04EDT rjmcgraw
        -:  116:** DCR3294 - Added pipe depth stats to several SB api's
        -:  117:** Revision 1.66 2007/03/28 14:17:37EST rjmcgraw
        -:  118:** Sending TskId instead of AppId in call to LogSBEvent - DCR2654
        -:  119:** Revision 1.65 2007/03/27 13:42:28EST rjmcgraw
        -:  120:** Added step to increment new duplicate subscription counter
        -:  121:**
        -:  122:******************************************************************************/
        -:  123:
        -:  124:/*
        -:  125:** Include Files
        -:  126:*/
        -:  127:#include "common_types.h"
        -:  128:#include "private/cfe_private.h"
        -:  129:#include "cfe_sb_events.h"
        -:  130:#include "cfe_sb_priv.h"
        -:  131:#include "cfe_sb.h"
        -:  132:#include "osapi.h"
        -:  133:#include "cfe_es.h"
        -:  134:#include "cfe_psp.h"
        -:  135:#include "cfe_error.h"
        -:  136:#include <string.h>
        -:  137:
        -:  138:/* 
        -:  139: * Macro to reflect size of PipeDepthStats Telemetry array - 
        -:  140: * this may or may not be the same as CFE_SB_MSG_MAX_PIPES
        -:  141: */
        -:  142:#define CFE_SB_TLM_PIPEDEPTHSTATS_SIZE     (sizeof(CFE_SB.StatTlmMsg.Payload.PipeDepthStats) / sizeof(CFE_SB.StatTlmMsg.Payload.PipeDepthStats[0]))
        -:  143:/******************************************************************************
        -:  144:** Name:    CFE_SB_CreatePipe
        -:  145:**
        -:  146:** Purpose: API to create a pipe for receiving messages
        -:  147:**
        -:  148:** Assumptions, External Events, and Notes:
        -:  149:**
        -:  150:**          Note: Zero is a valid PipeId
        -:  151:**
        -:  152:** Date Written:
        -:  153:**          04/25/2005
        -:  154:**
        -:  155:** Inputs:
        -:  156:**          PipeIdPtr - Ptr to users empty PipeId variable, to be filled by
        -:  157:**                      this function.
        -:  158:**          Depth     - The depth of the pipe, synonymous to the max number
        -:  159:**                      of messages the pipe can hold at any time.
        -:  160:**          PipeName  - The name of the pipe displayed in event messages
        -:  161:**
        -:  162:** Outputs:
        -:  163:**          PipeId    - The handle of the pipe to be used when receiving
        -:  164:**                      messages.
        -:  165:**
        -:  166:** Return Values:
        -:  167:**          Status
        -:  168:**
        -:  169:******************************************************************************/
        -:  170:int32  CFE_SB_CreatePipe(CFE_SB_PipeId_t *PipeIdPtr, uint16  Depth, const char *PipeName)
      183:  171:{
      183:  172:    uint32          AppId = 0xFFFFFFFF;
      183:  173:    uint32          TskId = 0;
      183:  174:    uint32          SysQueueId = 0;
        -:  175:    int32           Status;
        -:  176:    CFE_SB_PipeId_t PipeTblIdx;
      183:  177:    char            AppName[OS_MAX_API_NAME] = {'\0'};
        -:  178:    char            FullName[(OS_MAX_API_NAME * 2)];
        -:  179:
        -:  180:    /* take semaphore to prevent a task switch during this call */
      183:  181:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  182:
      183:  183:    TskId = OS_TaskGetId();
        -:  184:
        -:  185:    /* set user's pipe id value to 'invalid' for error cases below */
      183:  186:    if(PipeIdPtr != NULL){
      182:  187:        *PipeIdPtr = CFE_SB_INVALID_PIPE;
        -:  188:    }/* end if */
        -:  189:
        -:  190:    /* check input parameters */
      183:  191:    if((PipeIdPtr == NULL)||(Depth > CFE_SB_MAX_PIPE_DEPTH)||(Depth == 0)){
        4:  192:        CFE_SB.HKTlmMsg.Payload.CreatePipeErrCnt++;
        4:  193:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        4:  194:        CFE_EVS_SendEventWithAppID(CFE_SB_CR_PIPE_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  195:          "CreatePipeErr:Bad Input Arg:app=%s,ptr=0x%lx,depth=%d,maxdepth=%d",
        -:  196:                CFE_SB_GetAppTskName(TskId,FullName),(unsigned long)PipeIdPtr,Depth,CFE_SB_MAX_PIPE_DEPTH);
        4:  197:        return CFE_SB_BAD_ARGUMENT;
        -:  198:    }/*end if*/
        -:  199:
        -:  200:    /* get first available entry in pipe table */
      179:  201:    PipeTblIdx = CFE_SB_GetAvailPipeIdx();
        -:  202:
        -:  203:    /* if pipe table is full, send event and return error */
      179:  204:    if(PipeTblIdx == CFE_SB_INVALID_PIPE){
        1:  205:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  206:        CFE_EVS_SendEventWithAppID(CFE_SB_MAX_PIPES_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  207:          "CreatePipeErr:Max Pipes(%d)In Use.app %s",
        -:  208:          CFE_SB_MAX_PIPES,CFE_SB_GetAppTskName(TskId,FullName));
        1:  209:        return CFE_SB_MAX_PIPES_MET;
        -:  210:    }/* end if */
        -:  211:
        -:  212:    /* create the queue */
      178:  213:    Status = OS_QueueCreate(&SysQueueId,PipeName,Depth,sizeof(CFE_SB_BufferD_t *),0);
      178:  214:    if (Status != OS_SUCCESS) {
        1:  215:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  216:        CFE_EVS_SendEventWithAppID(CFE_SB_CR_PIPE_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  217:                "CreatePipeErr:OS_QueueCreate returned %d,app %s",
        -:  218:                (int)Status,CFE_SB_GetAppTskName(TskId,FullName));
        1:  219:        return CFE_SB_PIPE_CR_ERR;
        -:  220:    }/* end if */
        -:  221:
        -:  222:    /* get callers AppId */
      177:  223:    CFE_ES_GetAppID(&AppId);
        -:  224:
        -:  225:    /* get callers name */
      177:  226:    CFE_ES_GetAppName(AppName, AppId, OS_MAX_API_NAME);
        -:  227:
        -:  228:    /* Hardcode a NULL terminator, in case rcvd name was too long */
      177:  229:    AppName[OS_MAX_API_NAME-1]= '\0';
        -:  230:
        -:  231:    /* fill in the pipe table fields */
      177:  232:    CFE_SB.PipeTbl[PipeTblIdx].InUse       = CFE_SB_IN_USE;
      177:  233:    CFE_SB.PipeTbl[PipeTblIdx].SysQueueId  = SysQueueId;
      177:  234:    CFE_SB.PipeTbl[PipeTblIdx].PipeId      = PipeTblIdx;
      177:  235:    CFE_SB.PipeTbl[PipeTblIdx].QueueDepth  = Depth;
      177:  236:    CFE_SB.PipeTbl[PipeTblIdx].AppId       = AppId;
      177:  237:    CFE_SB.PipeTbl[PipeTblIdx].SendErrors  = 0;
      177:  238:    CFE_SB.PipeTbl[PipeTblIdx].CurrentBuff = NULL;
      177:  239:    CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff = NULL;
      177:  240:    strcpy(&CFE_SB.PipeTbl[PipeTblIdx].AppName[0],&AppName[0]);
      177:  241:    strncpy(&CFE_SB.PipeTbl[PipeTblIdx].PipeName[0],PipeName,OS_MAX_API_NAME);
      177:  242:    CFE_SB.PipeTbl[PipeTblIdx].PipeName[OS_MAX_API_NAME-1]='\0';
        -:  243:
        -:  244:    /* Increment the Pipes in use ctr and if it's > the high water mark,*/
        -:  245:    /* adjust the high water mark */
      177:  246:    CFE_SB.StatTlmMsg.Payload.PipesInUse++;
      177:  247:    if(CFE_SB.StatTlmMsg.Payload.PipesInUse > CFE_SB.StatTlmMsg.Payload.PeakPipesInUse){
      174:  248:       CFE_SB.StatTlmMsg.Payload.PeakPipesInUse = CFE_SB.StatTlmMsg.Payload.PipesInUse;
        -:  249:    }/* end if */
        -:  250:
        -:  251:    /* Reset the pipe depth parameters in the statistics pkt */
      177:  252:    if (PipeTblIdx < CFE_SB_TLM_PIPEDEPTHSTATS_SIZE)
        -:  253:    {
      177:  254:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].PipeId = PipeTblIdx;
      177:  255:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].Depth = Depth;
      177:  256:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].InUse = 0;
      177:  257:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].PeakInUse = 0;
        -:  258:    }
        -:  259:
        -:  260:    /* give the pipe handle to the caller */
      177:  261:    *PipeIdPtr = PipeTblIdx;
        -:  262:
      177:  263:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -:  264:
        -:  265:    /* send debug event */
      177:  266:    CFE_EVS_SendEventWithAppID(CFE_SB_PIPE_ADDED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  267:          "Pipe Created:name %s,id %d,app %s",
        -:  268:          CFE_SB_GetPipeName(CFE_SB.PipeTbl[PipeTblIdx].PipeId),
        -:  269:          (int)CFE_SB.PipeTbl[PipeTblIdx].PipeId,
        -:  270:          CFE_SB_GetAppTskName(TskId,FullName));
        -:  271:
      177:  272:    return CFE_SUCCESS;
        -:  273:
        -:  274:}/* end CFE_SB_CreatePipe */
        -:  275:
        -:  276:
        -:  277:/******************************************************************************
        -:  278:**  Function:  CFE_SB_DeletePipe()
        -:  279:**
        -:  280:**  Purpose:
        -:  281:**    Will unsubscribe to all routes associated with the given pipe id, then remove
        -:  282:**    pipe from the pipe table.
        -:  283:**
        -:  284:**  Arguments:
        -:  285:**    PipeId - The ID of the pipe to delete.
        -:  286:**
        -:  287:**  Return:
        -:  288:**    CFE_SUCCESS or cFE Error Code
        -:  289:*/
        -:  290:int32 CFE_SB_DeletePipe(CFE_SB_PipeId_t PipeId)
      178:  291:{
      178:  292:    uint32  CallerId = 0xFFFFFFFF;
      178:  293:    int32   Status = 0;
        -:  294:
        -:  295:    /* get the callers Application Id */
      178:  296:    CFE_ES_GetAppID(&CallerId);
        -:  297:
      178:  298:    Status = CFE_SB_DeletePipeFull(PipeId,CallerId);
        -:  299:
      178:  300:    return Status;
        -:  301:
        -:  302:}/* end CFE_SB_DeletePipe */
        -:  303:
        -:  304:
        -:  305:
        -:  306:/******************************************************************************
        -:  307:**  Function:  CFE_SB_DeletePipeWithAppId()
        -:  308:**
        -:  309:**  Purpose:
        -:  310:**
        -:  311:**
        -:  312:**  Arguments:
        -:  313:**    PipeId - The ID of the pipe to delete.
        -:  314:**
        -:  315:**  Return:
        -:  316:**    CFE_SUCCESS or cFE Error Code
        -:  317:*/
        -:  318:int32 CFE_SB_DeletePipeWithAppId(CFE_SB_PipeId_t PipeId, uint32 AppId)
        3:  319:{
        3:  320:    int32   Status = 0;
        -:  321:
        3:  322:    Status = CFE_SB_DeletePipeFull(PipeId,AppId);
        -:  323:
        3:  324:    return Status;
        -:  325:
        -:  326:}/* end CFE_SB_DeletePipeWithAppId */
        -:  327:
        -:  328:
        -:  329:
        -:  330:/******************************************************************************
        -:  331:**  Function:  CFE_SB_DeletePipeFull()
        -:  332:**
        -:  333:**  Purpose:
        -:  334:**    Will unsubscribe to all routes associated with the given pipe id, then remove
        -:  335:**    pipe from the pipe table.
        -:  336:**
        -:  337:**  NOTE:This function cannot be called directly, it would not be semaphore protected
        -:  338:**
        -:  339:**  Arguments:
        -:  340:**    PipeId - The ID of the pipe to delete.
        -:  341:**
        -:  342:**  Return:
        -:  343:**    CFE_SUCCESS or cFE Error Code
        -:  344:*/
        -:  345:int32 CFE_SB_DeletePipeFull(CFE_SB_PipeId_t PipeId,uint32 AppId)
      182:  346:{
        -:  347:    uint8         PipeTblIdx;
        -:  348:    int32         RtnFromVal,Stat;
        -:  349:    uint32        Owner,i;
      182:  350:    uint32        TskId = 0;
        -:  351:    CFE_SB_Msg_t  *PipeMsgPtr;
      182:  352:    CFE_SB_DestinationD_t *DestPtr = NULL;
        -:  353:    char          FullName[(OS_MAX_API_NAME * 2)];
        -:  354:
        -:  355:    /* take semaphore to prevent a task switch during this call */
      182:  356:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  357:
        -:  358:    /* get TaskId of caller for events */
      182:  359:    TskId = OS_TaskGetId();
        -:  360:
        -:  361:    /* check input parameter */
      182:  362:    PipeTblIdx = CFE_SB_GetPipeIdx(PipeId);
      182:  363:    RtnFromVal = CFE_SB_ValidatePipeId(PipeId);
      182:  364:    if((RtnFromVal != CFE_SUCCESS)||(PipeTblIdx == CFE_SB_INVALID_PIPE))
        -:  365:    {
        4:  366:        CFE_SB.HKTlmMsg.Payload.CreatePipeErrCnt++;
        4:  367:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        4:  368:        CFE_EVS_SendEventWithAppID(CFE_SB_DEL_PIPE_ERR1_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  369:          "Pipe Delete Error:Bad Argument,PipedId %d,Requestor %s,Idx %d,Stat %d",
        -:  370:          (int)PipeId,CFE_SB_GetAppTskName(TskId,FullName),(int)PipeTblIdx,(int)RtnFromVal);
        4:  371:        return CFE_SB_BAD_ARGUMENT;
        -:  372:    }/* end if */
        -:  373:
      178:  374:    Owner = CFE_SB.PipeTbl[PipeTblIdx].AppId;
        -:  375:
        -:  376:    /* check that the given AppId is the owner of the pipe */
      178:  377:    if(AppId != Owner){
        1:  378:        CFE_SB.HKTlmMsg.Payload.CreatePipeErrCnt++;
        1:  379:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  380:        CFE_EVS_SendEventWithAppID(CFE_SB_DEL_PIPE_ERR2_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  381:          "Pipe Delete Error:Caller(%s) is not the owner of pipe %d",
        -:  382:          CFE_SB_GetAppTskName(TskId,FullName),PipeId);
        1:  383:        return CFE_SB_BAD_ARGUMENT;
        -:  384:    }/* end if */
        -:  385:
        -:  386:    /* check destination list of every in-use MsgId, for the given pipeid. */
        -:  387:    /* when found, remove the pipe ID from the destination list via 'unsubscribe' */
    45489:  388:    for(i=0;i<CFE_SB_MAX_MSG_IDS;i++){
    45312:  389:        if(CFE_SB.RoutingTbl[i].MsgId != CFE_SB_INVALID_MSG_ID){
        -:  390:
      951:  391:            DestPtr = CFE_SB.RoutingTbl[i].ListHeadPtr;
        -:  392:
     2979:  393:            while(DestPtr != NULL){
        -:  394:
     1077:  395:                if(DestPtr -> PipeId == PipeId){
        -:  396:                    /* release the semaphore, unsubscribe will need to take it */
      414:  397:                    CFE_SB_UnlockSharedData(__func__,__LINE__);
      414:  398:                    CFE_SB_UnsubscribeWithAppId(CFE_SB.RoutingTbl[i].MsgId,
        -:  399:                                       PipeId,AppId);
      414:  400:                    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  401:                }/* end if */
        -:  402:
     1077:  403:                DestPtr = DestPtr -> Next;
        -:  404:
        -:  405:            }/* end while */
        -:  406:
        -:  407:        }/* end if */
        -:  408:    }/* end for */
        -:  409:
      177:  410:    if (CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff != NULL) {
        -:  411:
        -:  412:        /* Decrement the Buffer Use Count and Free buffer if cnt=0) */
        1:  413:        CFE_SB_DecrBufUseCnt(CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff);
        1:  414:        CFE_SB.PipeTbl[PipeTblIdx].ToTrashBuff = NULL;
        -:  415:
        -:  416:    }/* end if */
        -:  417:
        -:  418:
        -:  419:    /* remove any messages that might be on the pipe */
        -:  420:    /* this step will free the memory used to store the message */
        -:  421:    do{
      185:  422:      CFE_SB_UnlockSharedData(__func__,__LINE__);
      185:  423:      Stat = CFE_SB_RcvMsg(&PipeMsgPtr,PipeId,CFE_SB_POLL);
      185:  424:      CFE_SB_LockSharedData(__func__,__LINE__);
      185:  425:    }while(Stat == CFE_SUCCESS);
        -:  426:
        -:  427:    /* Delete the underlying OS queue */
      177:  428:    OS_QueueDelete(CFE_SB.PipeTbl[PipeTblIdx].SysQueueId);
        -:  429:
        -:  430:    /* remove the pipe from the pipe table */
      177:  431:    CFE_SB.PipeTbl[PipeTblIdx].InUse         = CFE_SB_NOT_IN_USE;
      177:  432:    CFE_SB.PipeTbl[PipeTblIdx].SysQueueId    = CFE_SB_UNUSED_QUEUE;
      177:  433:    CFE_SB.PipeTbl[PipeTblIdx].PipeId        = CFE_SB_INVALID_PIPE;
      177:  434:    CFE_SB.PipeTbl[PipeTblIdx].CurrentBuff   = NULL;
      177:  435:    CFE_PSP_MemSet(&CFE_SB.PipeTbl[PipeTblIdx].PipeName[0],0,OS_MAX_API_NAME);
        -:  436:
        -:  437:    /* zero out the pipe depth stats */
      177:  438:    if (PipeTblIdx < CFE_SB_TLM_PIPEDEPTHSTATS_SIZE)
        -:  439:    {
      177:  440:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].PipeId = 0;
      177:  441:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].Depth = 0;
      177:  442:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].InUse = 0;
      177:  443:    CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeTblIdx].PeakInUse = 0;
        -:  444:    }
        -:  445:
      177:  446:    CFE_SB.StatTlmMsg.Payload.PipesInUse--;
        -:  447:
      177:  448:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -:  449:
      177:  450:    CFE_EVS_SendEventWithAppID(CFE_SB_PIPE_DELETED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  451:          "Pipe Deleted:id %d,owner %s",PipeId, CFE_SB_GetAppTskName(Owner,FullName));
        -:  452:
      177:  453:    return CFE_SUCCESS;
        -:  454:
        -:  455:}/* end CFE_SB_DeletePipeFull */
        -:  456:
        -:  457:
        -:  458:/******************************************************************************
        -:  459:** Name:    CFE_SB_SubscribeEx
        -:  460:**
        -:  461:** Purpose: API to globally subscribe to a message when QOS and MsgLim defaults
        -:  462:**          are insufficient.
        -:  463:**
        -:  464:** Assumptions, External Events, and Notes:
        -:  465:**
        -:  466:**          Note: Qos default: priority is low, reliability is low
        -:  467:**          Note: MsgLim default: 4, see Input Arguments below for more detail
        -:  468:**          Note: Qos parameter is currently unused by the fsw. It is recommended
        -:  469:**                to give a value of zero for Quality.Priority and Quality.Reliability
        -:  470:**
        -:  471:** Date Written:
        -:  472:**          04/25/2005
        -:  473:**
        -:  474:** Input Arguments:
        -:  475:**          MsgId   - The requesting message
        -:  476:**          PipeId  - The Pipe ID to send the message to
        -:  477:**          Quality - Quality of Service (Qos) - priority and reliability,
        -:  478:**                    see note above for recommended settings
        -:  479:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  480:**                    pipe at any time.
        -:  481:**
        -:  482:** Output Arguments:
        -:  483:**          None
        -:  484:**
        -:  485:** Return Values:
        -:  486:**          Status
        -:  487:**
        -:  488:******************************************************************************/
        -:  489:int32  CFE_SB_SubscribeEx(CFE_SB_MsgId_t   MsgId,
        -:  490:                          CFE_SB_PipeId_t  PipeId,
        -:  491:                          CFE_SB_Qos_t     Quality,
        -:  492:                          uint16           MsgLim)
        4:  493:{
        4:  494:    return CFE_SB_SubscribeFull(MsgId,PipeId,Quality,MsgLim,(uint8)CFE_SB_GLOBAL);
        -:  495:
        -:  496:}/* end CFE_SB_SubscribeEx */
        -:  497:
        -:  498:
        -:  499:
        -:  500:
        -:  501:/******************************************************************************
        -:  502:** Name:    CFE_SB_SubscribeLocal
        -:  503:**
        -:  504:** Purpose: CFE Internal API to locally subscribe to a message when QOS and
        -:  505:**          MsgLim defaults are insufficient.
        -:  506:**
        -:  507:** Assumptions, External Events, and Notes:
        -:  508:**
        -:  509:**          Note: Qos default: priority is low, reliability is low
        -:  510:**                MsgLim default: 4 - meaning at most 4 messages of given
        -:  511:**                                    MsgId allowed on the given PipeId.
        -:  512:**
        -:  513:** Date Written:
        -:  514:**          04/25/2005
        -:  515:**
        -:  516:** Input Arguments:
        -:  517:**          MsgId   - The requesting message
        -:  518:**          PipeId  - The Pipe ID to send the message to
        -:  519:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  520:**                    pipe at any time.
        -:  521:**
        -:  522:** Output Arguments:
        -:  523:**          None
        -:  524:**
        -:  525:** Return Values:
        -:  526:**          Status
        -:  527:**
        -:  528:******************************************************************************/
        -:  529:int32 CFE_SB_SubscribeLocal(CFE_SB_MsgId_t   MsgId,
        -:  530:                            CFE_SB_PipeId_t  PipeId,
        -:  531:                            uint16           MsgLim)
        4:  532:{
        4:  533:    return CFE_SB_SubscribeFull(MsgId,PipeId,CFE_SB_Default_Qos,MsgLim,
        -:  534:                                (uint8)CFE_SB_LOCAL);
        -:  535:
        -:  536:}/* end CFE_SB_SubscribeLocal */
        -:  537:
        -:  538:
        -:  539:
        -:  540:
        -:  541:/******************************************************************************
        -:  542:** Name:    CFE_SB_Subscribe
        -:  543:**
        -:  544:** Purpose: API to locally subscribe to a message when QOS and MsgLim defaults
        -:  545:**          are sufficient.
        -:  546:**
        -:  547:** Assumptions, External Events, and Notes:
        -:  548:**
        -:  549:**          Note: Qos default: priority is low, reliability is low
        -:  550:**                MsgLim default: 4 - meaning at most 4 messages of given
        -:  551:**                                    MsgId allowed on the given PipeId.
        -:  552:**
        -:  553:** Date Written:
        -:  554:**          04/25/2005
        -:  555:**
        -:  556:** Input Arguments:
        -:  557:**          MsgId   - The requesting message
        -:  558:**          PipeId  - The Pipe ID to send the message to
        -:  559:**
        -:  560:** Output Arguments:
        -:  561:**          None
        -:  562:**
        -:  563:** Return Values:
        -:  564:**          Status
        -:  565:**
        -:  566:******************************************************************************/
        -:  567:int32 CFE_SB_Subscribe(CFE_SB_MsgId_t   MsgId,
        -:  568:                       CFE_SB_PipeId_t  PipeId)
      428:  569:{
      428:  570:    return CFE_SB_SubscribeFull(MsgId,PipeId,CFE_SB_Default_Qos,
        -:  571:                               (uint16)CFE_SB_DEFAULT_MSG_LIMIT,
        -:  572:                               (uint8)CFE_SB_GLOBAL);
        -:  573:
        -:  574:}/* end CFE_SB_Subscribe */
        -:  575:
        -:  576:
        -:  577:/******************************************************************************
        -:  578:** Name:    CFE_SB_SubscribeFull
        -:  579:**
        -:  580:** Purpose: CFE Internal API used to subscribe to a message. Contains an input
        -:  581:**          parameter for all possible subscription choices. This function is
        -:  582:**          called by CFE_SB_SubscribeEx, CFE_SB_Subscribe and
        -:  583:**          CFE_SB_SubscribeLocal.
        -:  584:**
        -:  585:** Assumptions, External Events, and Notes:
        -:  586:**          None
        -:  587:**
        -:  588:** Date Written:
        -:  589:**          04/25/2005
        -:  590:**
        -:  591:** Input Arguments:
        -:  592:**          MsgId   - The requesting message
        -:  593:**          PipeId  - The Pipe ID to send the message to
        -:  594:**          Quality - Quality of Service (Qos) - priority and reliability
        -:  595:**          MsgLim  - Max number of messages, with this MsgId, allowed on the
        -:  596:**                    pipe at any time.
        -:  597:**          Scope   - Local subscription or broadcasted to peers
        -:  598:**
        -:  599:** Output Arguments:
        -:  600:**          None
        -:  601:**
        -:  602:** Return Values:
        -:  603:**          Status
        -:  604:**
        -:  605:******************************************************************************/
        -:  606:int32  CFE_SB_SubscribeFull(CFE_SB_MsgId_t   MsgId,
        -:  607:                            CFE_SB_PipeId_t  PipeId,
        -:  608:                            CFE_SB_Qos_t     Quality,
        -:  609:                            uint16           MsgLim,
        -:  610:                            uint8            Scope)
      438:  611:{
        -:  612:    uint16 Idx;
        -:  613:    int32  Stat;
      438:  614:    uint32 TskId = 0;
      438:  615:    uint32 AppId = 0xFFFFFFFF;
        -:  616:    uint8  PipeIdx;
      438:  617:    CFE_SB_DestinationD_t *DestBlkPtr = NULL;
        -:  618:    char   FullName[(OS_MAX_API_NAME * 2)];
        -:  619:
        -:  620:    /* take semaphore to prevent a task switch during this call */
      438:  621:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  622:
        -:  623:    /* get task id for events */
      438:  624:    TskId = OS_TaskGetId();
        -:  625:
        -:  626:    /* get the callers Application Id */
      438:  627:    CFE_ES_GetAppID(&AppId);
        -:  628:
        -:  629:    /* check that the pipe has been created */
      438:  630:    PipeIdx = CFE_SB_GetPipeIdx(PipeId);
      438:  631:    if(PipeIdx==CFE_SB_INVALID_PIPE){
        2:  632:      CFE_SB.HKTlmMsg.Payload.SubscribeErrCnt++;
        2:  633:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  634:      CFE_EVS_SendEventWithAppID(CFE_SB_SUB_INV_PIPE_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  635:          "Subscribe Err:Invalid Pipe Id,Msg=0x%x,PipeId=%d,App %s",MsgId,PipeId,
        -:  636:          CFE_SB_GetAppTskName(TskId,FullName));
        2:  637:      return CFE_SB_BAD_ARGUMENT;
        -:  638:    }/* end if */
        -:  639:
        -:  640:    /* check that the requestor is the owner of the pipe */
      436:  641:    if(CFE_SB.PipeTbl[PipeIdx].AppId != AppId){
        1:  642:      CFE_SB.HKTlmMsg.Payload.SubscribeErrCnt++;
        1:  643:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  644:      CFE_EVS_SendEventWithAppID(CFE_SB_SUB_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  645:          "Subscribe Err:Caller(%s) is not the owner of pipe %d,Msg=0x%x",
        -:  646:          CFE_SB_GetAppTskName(TskId,FullName),PipeId,MsgId);
        1:  647:      return CFE_SB_BAD_ARGUMENT;
        -:  648:    }/* end if */
        -:  649:
        -:  650:    /* check message id and scope */
      435:  651:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||(Scope > 1))
        -:  652:    {
        2:  653:        CFE_SB.HKTlmMsg.Payload.SubscribeErrCnt++;
        2:  654:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  655:        CFE_EVS_SendEventWithAppID(CFE_SB_SUB_ARG_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  656:          "Subscribe Err:Bad Arg,MsgId 0x%x,PipeId %d,app %s,scope %d",
        -:  657:          MsgId,PipeId,CFE_SB_GetAppTskName(TskId,FullName),Scope);
        2:  658:        return CFE_SB_BAD_ARGUMENT;
        -:  659:    }/* end if */
        -:  660:
        -:  661:    /* check for duplicate subscription */
      433:  662:    if(CFE_SB_DuplicateSubscribeCheck(MsgId,PipeId)==CFE_SB_DUPLICATE){
        2:  663:        CFE_SB.HKTlmMsg.Payload.DupSubscriptionsCnt++;
        2:  664:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  665:        CFE_EVS_SendEventWithAppID(CFE_SB_DUP_SUBSCRIP_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -:  666:          "Duplicate Subscription,MsgId 0x%x on %s pipe,app %s",
        -:  667:           MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId,FullName));
        2:  668:        return CFE_SUCCESS;
        -:  669:    }/* end if */
        -:  670:
        -:  671:    /*
        -:  672:    ** If there has been a subscription for this message id earlier,
        -:  673:    ** get the element number in the routing table.
        -:  674:    */
      431:  675:    Idx = CFE_SB_GetRoutingTblIdx(MsgId);
        -:  676:
        -:  677:    /* if first subscription for this message... */
      431:  678:    if(Idx==CFE_SB_AVAILABLE){
        -:  679:
        -:  680:        /* Get the index to the first available element in the routing table */
      399:  681:        Idx = CFE_SB_GetAvailRoutingIdx();
        -:  682:
        -:  683:        /* if all routing table elements are used, send event */
      399:  684:        if(Idx >= CFE_SB_MAX_MSG_IDS){
        1:  685:            CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  686:            CFE_EVS_SendEventWithAppID(CFE_SB_MAX_MSGS_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  687:              "Subscribe Err:Max Msgs(%d)In Use,MsgId 0x%x,pipe %s,app %s",
        -:  688:              CFE_SB_MAX_MSG_IDS,MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId,FullName));
        1:  689:            return CFE_SB_MAX_MSGS_MET;
        -:  690:        }/* end if */
        -:  691:
        -:  692:        /* Increment the MsgIds in use ctr and if it's > the high water mark,*/
        -:  693:        /* adjust the high water mark */
      398:  694:        CFE_SB.StatTlmMsg.Payload.MsgIdsInUse++;
      398:  695:        if(CFE_SB.StatTlmMsg.Payload.MsgIdsInUse > CFE_SB.StatTlmMsg.Payload.PeakMsgIdsInUse){
      394:  696:           CFE_SB.StatTlmMsg.Payload.PeakMsgIdsInUse = CFE_SB.StatTlmMsg.Payload.MsgIdsInUse;
        -:  697:        }/* end if */
        -:  698:
        -:  699:        /* populate the look up table with the routing table index */
      398:  700:        CFE_SB_SetRoutingTblIdx(MsgId,Idx);
        -:  701:
        -:  702:        /* label the new routing block with the message identifier */
      398:  703:        CFE_SB.RoutingTbl[Idx].MsgId = MsgId;
        -:  704:
        -:  705:    }/* end if */
        -:  706:
      430:  707:    if(CFE_SB.RoutingTbl[Idx].Destinations >= CFE_SB_MAX_DEST_PER_PKT){
        1:  708:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  709:        CFE_EVS_SendEventWithAppID(CFE_SB_MAX_DESTS_MET_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  710:            "Subscribe Err:Max Dests(%d)In Use For Msg 0x%x,pipe %s,app %s",
        -:  711:             CFE_SB_MAX_DEST_PER_PKT,MsgId,CFE_SB_GetPipeName(PipeId),
        -:  712:             CFE_SB_GetAppTskName(TskId,FullName));
        1:  713:        return CFE_SB_MAX_DESTS_MET;
        -:  714:    }/* end if */
        -:  715:
      429:  716:    DestBlkPtr = CFE_SB_GetDestinationBlk();
      429:  717:    if(DestBlkPtr == NULL){
        2:  718:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  719:        CFE_EVS_SendEventWithAppID(CFE_SB_DEST_BLK_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  720:            "Subscribe Err:Request for Destination Blk failed for Msg 0x%x", (unsigned int)MsgId);
        2:  721:        return CFE_SB_BUF_ALOC_ERR;
        -:  722:    }/* end if */
        -:  723:
        -:  724:    /* initialize destination block */
      427:  725:    DestBlkPtr -> PipeId = PipeId;
      427:  726:    DestBlkPtr -> MsgId2PipeLim = (uint16)MsgLim;
      427:  727:    DestBlkPtr -> Active = CFE_SB_ACTIVE;
      427:  728:    DestBlkPtr -> BuffCount = 0;
      427:  729:    DestBlkPtr -> DestCnt = 0;
      427:  730:    DestBlkPtr -> Scope = Scope;
      427:  731:    DestBlkPtr -> Prev = NULL;
      427:  732:    DestBlkPtr -> Next = NULL;
        -:  733:
        -:  734:    /* add destination block to head of list */
      427:  735:    CFE_SB_AddDest(Idx, DestBlkPtr);
        -:  736:
      427:  737:    CFE_SB.RoutingTbl[Idx].Destinations++;
        -:  738:
      427:  739:    CFE_SB.StatTlmMsg.Payload.SubscriptionsInUse++;
      427:  740:    if(CFE_SB.StatTlmMsg.Payload.SubscriptionsInUse > CFE_SB.StatTlmMsg.Payload.PeakSubscriptionsInUse)
        -:  741:    {
      408:  742:       CFE_SB.StatTlmMsg.Payload.PeakSubscriptionsInUse = CFE_SB.StatTlmMsg.Payload.SubscriptionsInUse;
        -:  743:    }/* end if */
        -:  744:
      427:  745:    if((CFE_SB.SubscriptionReporting == CFE_SB_ENABLE)&&(Scope==CFE_SB_GLOBAL)){
        2:  746:      CFE_SB.SubRprtMsg.Payload.MsgId = MsgId;
        2:  747:      CFE_SB.SubRprtMsg.Payload.Pipe = PipeId;
        2:  748:      CFE_SB.SubRprtMsg.Payload.Qos.Priority = Quality.Priority;
        2:  749:      CFE_SB.SubRprtMsg.Payload.Qos.Reliability = Quality.Reliability;
        2:  750:      CFE_SB.SubRprtMsg.Payload.SubType = CFE_SB_SUBSCRIPTION;
        2:  751:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  752:      Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.SubRprtMsg);
        2:  753:      CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_RPT_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  754:            "Sending Subscription Report Msg=0x%x,Pipe=%d,Stat=0x%x",
        -:  755:            (unsigned int)MsgId,(int)PipeId,(unsigned int)Stat);
        2:  756:      CFE_SB_LockSharedData(__func__,__LINE__);/* to prevent back-to-back unlock */
        -:  757:    }/* end if */
        -:  758:
        -:  759:    /* release the semaphore */
      427:  760:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -:  761:
      427:  762:    CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_RCVD_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -:  763:        "Subscription Rcvd:MsgId 0x%x on %s(%d),app %s",
        -:  764:         (unsigned int)MsgId,CFE_SB_GetPipeName(PipeId),(int)PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        -:  765:
      427:  766:    return CFE_SUCCESS;
        -:  767:
        -:  768:}/* end CFE_SB_SubscribeFull */
        -:  769:
        -:  770:
        -:  771:/******************************************************************************
        -:  772:** Name:    CFE_SB_Unsubscribe
        -:  773:**
        -:  774:** Purpose: API used to unsubscribe to a message.
        -:  775:**
        -:  776:** Date Written:
        -:  777:**          04/25/2005
        -:  778:**
        -:  779:** Input Arguments:
        -:  780:**          MsgId
        -:  781:**          PipeId
        -:  782:**
        -:  783:** Output Arguments:
        -:  784:**          None
        -:  785:**
        -:  786:** Return Values:
        -:  787:**          Status
        -:  788:**
        -:  789:******************************************************************************/
        -:  790:int32 CFE_SB_Unsubscribe(CFE_SB_MsgId_t MsgId, CFE_SB_PipeId_t PipeId)
       13:  791:{
       13:  792:    uint32  CallerId = 0xFFFFFFFF;
       13:  793:    int32   Status = 0;
        -:  794:
        -:  795:    /* get the callers Application Id */
       13:  796:    CFE_ES_GetAppID(&CallerId);
        -:  797:
       13:  798:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_GLOBAL,CallerId);
        -:  799:
       13:  800:    return Status;
        -:  801:
        -:  802:}/* end CFE_SB_Unsubscribe */
        -:  803:
        -:  804:
        -:  805:/******************************************************************************
        -:  806:** Name:    CFE_SB_UnsubscribeLocal
        -:  807:**
        -:  808:** Purpose: CFE Internal API used to locally unsubscribe to a message. This
        -:  809:**          request to cancel a subscription will not be sent to peers.
        -:  810:**
        -:  811:** Date Written:
        -:  812:**          04/25/2005
        -:  813:**
        -:  814:** Input Arguments:
        -:  815:**          MsgId
        -:  816:**          PipeId
        -:  817:**
        -:  818:** Output Arguments:
        -:  819:**          None
        -:  820:**
        -:  821:** Return Values:
        -:  822:**          Status
        -:  823:**
        -:  824:******************************************************************************/
        -:  825:int32 CFE_SB_UnsubscribeLocal(CFE_SB_MsgId_t MsgId, CFE_SB_PipeId_t PipeId)
        1:  826:{
        1:  827:    uint32  CallerId = 0xFFFFFFFF;
        1:  828:    int32   Status = 0;
        -:  829:
        -:  830:    /* get the callers Application Id */
        1:  831:    CFE_ES_GetAppID(&CallerId);
        -:  832:
        1:  833:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_LOCAL,CallerId);
        -:  834:
        1:  835:    return Status;
        -:  836:
        -:  837:}/* end CFE_SB_UnsubscribeLocal */
        -:  838:
        -:  839:
        -:  840:/******************************************************************************
        -:  841:** Name:    CFE_SB_UnsubscribeAppId
        -:  842:**
        -:  843:** Purpose: CFE Internal API intented to be called by CFE_ES when an applications
        -:  844:**          SB resources need to be freed. The regular unsibscribe api won't work
        -:  845:**          because it does a check to ensure the caller is the owner of the pipe.
        -:  846:**
        -:  847:** Date Written:
        -:  848:**          03/15/2007
        -:  849:**
        -:  850:** Input Arguments:
        -:  851:**          MsgId
        -:  852:**          PipeId
        -:  853:**          AppId
        -:  854:**
        -:  855:** Output Arguments:
        -:  856:**          None
        -:  857:**
        -:  858:** Return Values:
        -:  859:**          Status
        -:  860:**
        -:  861:******************************************************************************/
        -:  862:int32 CFE_SB_UnsubscribeWithAppId(CFE_SB_MsgId_t MsgId,
        -:  863:                              CFE_SB_PipeId_t PipeId,
        -:  864:                              uint32 AppId)
      414:  865:{
      414:  866:    int32   Status = 0;
        -:  867:
      414:  868:    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, (uint8)CFE_SB_LOCAL, AppId);
        -:  869:
      414:  870:    return Status;
        -:  871:
        -:  872:}/* end CFE_SB_UnsubscribeWithAppId */
        -:  873:
        -:  874:
        -:  875:/******************************************************************************
        -:  876:** Name:    CFE_SB_UnsubscribeFull
        -:  877:**
        -:  878:** Purpose: CFE Internal API used to unsubscribe to a message.
        -:  879:**
        -:  880:** Assumptions, External Events, and Notes:
        -:  881:**
        -:  882:**
        -:  883:** Notes:This function cannot be called directly,it would not be semaphore protected.
        -:  884:**       Also,if more than one subscription is found, this function will remove all
        -:  885:**       entries that match.
        -:  886:**
        -:  887:** Date Written:
        -:  888:**          04/25/2005
        -:  889:**
        -:  890:** Input Arguments:
        -:  891:**          MsgId
        -:  892:**          PipeId
        -:  893:**          Scope
        -:  894:**          AppId
        -:  895:**
        -:  896:** Output Arguments:
        -:  897:**          None
        -:  898:**
        -:  899:** Return Values:
        -:  900:**          Status
        -:  901:**
        -:  902:******************************************************************************/
        -:  903:int32 CFE_SB_UnsubscribeFull(CFE_SB_MsgId_t MsgId,CFE_SB_PipeId_t PipeId,
        -:  904:                             uint8 Scope,uint32 AppId)
      430:  905:{
        -:  906:    uint16  Idx;
        -:  907:    uint32  PipeIdx;
      430:  908:    uint32  TskId = 0;
      430:  909:    uint32  MatchFound = FALSE;
        -:  910:    int32   Stat;
      430:  911:    CFE_SB_DestinationD_t   *DestPtr = NULL;
        -:  912:    char    FullName[(OS_MAX_API_NAME * 2)];
        -:  913:
        -:  914:
        -:  915:    /* take semaphore to prevent a task switch during this call */
      430:  916:    CFE_SB_LockSharedData(__func__,__LINE__);
        -:  917:
        -:  918:    /* get task id for events */
      430:  919:    TskId = OS_TaskGetId();
        -:  920:
        -:  921:    /* check that the pipe has been created */
      430:  922:    PipeIdx = CFE_SB_GetPipeIdx(PipeId);
      430:  923:    if(PipeIdx==CFE_SB_INVALID_PIPE){
        1:  924:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  925:      CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_INV_PIPE_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  926:            "Unsubscribe Err:Invalid Pipe Id Msg=0x%x,Pipe=%d,app=%s",
        -:  927:            (unsigned int)MsgId,(int)PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1:  928:      return CFE_SB_BAD_ARGUMENT;
        -:  929:    }/* end if */
        -:  930:
        -:  931:    /* if given 'AppId' is not the owner of the pipe, send error event and return */
      429:  932:    if(CFE_SB.PipeTbl[PipeIdx].AppId != AppId){
        1:  933:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1:  934:      CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  935:            "Unsubscribe Err:Caller(%s) is not the owner of pipe %d,Msg=0x%x",
        -:  936:            CFE_SB_GetAppTskName(TskId,FullName),(int)PipeId,MsgId);
        1:  937:      return CFE_SB_BAD_ARGUMENT;
        -:  938:    }/* end if */
        -:  939:
        -:  940:    /* check input parameters */
      428:  941:    if((CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS)||
        -:  942:       (CFE_SB_ValidatePipeId(PipeId) != CFE_SUCCESS)||
        -:  943:       (Scope > 1))
        -:  944:    {
        3:  945:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        3:  946:        CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_ARG_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -:  947:            "UnSubscribe Err:Bad Arg,MsgId 0x%x,PipeId %d,app %s,scope %d",
        -:  948:            (unsigned int)MsgId,(int)PipeId,CFE_SB_GetAppTskName(TskId,FullName),Scope);
        3:  949:        return CFE_SB_BAD_ARGUMENT;
        -:  950:    }/* end if */
        -:  951:
        -:  952:    /* get index into routing table */
      425:  953:    Idx = CFE_SB_GetRoutingTblIdx(MsgId);
        -:  954:
        -:  955:    /* if there are no subscriptions for this message id... */
      425:  956:    if(Idx == CFE_SB_AVAILABLE){
        2:  957:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2:  958:        CFE_EVS_SendEventWithAppID(CFE_SB_UNSUB_NO_SUBS_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -:  959:            "Unsubscribe Err:No subs for Msg 0x%x on %s,app %s",
        -:  960:            (unsigned int)MsgId,CFE_SB_GetPipeName(PipeId),CFE_SB_GetAppTskName(TskId,FullName));
        2:  961:        return CFE_SUCCESS;
        -:  962:    }/* end if */
        -:  963:
        -:  964:    /* At this point, there must be at least one destination. */
        -:  965:    /* So the value of 'ListHeadPtr' will not be NULL by design */
        -:  966:
        -:  967:    /* search the list for a matching pipe id */
      423:  968:    DestPtr = CFE_SB.RoutingTbl[Idx].ListHeadPtr;
        -:  969:
        -:  970:    do{
        -:  971:
      559:  972:        if(DestPtr->PipeId == PipeId){
        -:  973:            /* match found, remove node from list */
      422:  974:            CFE_SB_RemoveDest(Idx,DestPtr);
        -:  975:
        -:  976:            /* return node to memory pool */
      422:  977:            CFE_SB_PutDestinationBlk(DestPtr);
        -:  978:
      422:  979:            CFE_SB.RoutingTbl[Idx].Destinations--;
      422:  980:            CFE_SB.StatTlmMsg.Payload.SubscriptionsInUse--;
        -:  981:
      422:  982:            MatchFound = TRUE;
        -:  983:
        -:  984:        }/* end if */
        -:  985:
      559:  986:        DestPtr = DestPtr->Next;
        -:  987:
      559:  988:    }while((MatchFound == FALSE)&&(DestPtr != NULL));
        -:  989:
        -:  990:    /* if 'Destinations' was decremented to zero above... */
      423:  991:    if(CFE_SB.RoutingTbl[Idx].Destinations==0){
      393:  992:        CFE_SB.StatTlmMsg.Payload.MsgIdsInUse--;
      393:  993:        CFE_SB.RoutingTbl[Idx].MsgId = CFE_SB_INVALID_MSG_ID;
      393:  994:        CFE_SB_SetRoutingTblIdx(MsgId,CFE_SB_AVAILABLE);
        -:  995:
        -:  996:        /* Send unsubscribe report only if there are zero requests for this pkt */
      393:  997:        if((CFE_SB.SubscriptionReporting == CFE_SB_ENABLE)&&
        -:  998:          (Scope == CFE_SB_GLOBAL))
        -:  999:        {
        2: 1000:          CFE_SB.SubRprtMsg.Payload.MsgId = MsgId;
        2: 1001:          CFE_SB.SubRprtMsg.Payload.Pipe = PipeId;
        2: 1002:          CFE_SB.SubRprtMsg.Payload.Qos.Priority = 0;
        2: 1003:          CFE_SB.SubRprtMsg.Payload.Qos.Reliability = 0;
        2: 1004:          CFE_SB.SubRprtMsg.Payload.SubType = CFE_SB_UNSUBSCRIPTION;
        2: 1005:          CFE_SB_UnlockSharedData(__func__,__LINE__);
        2: 1006:          Stat = CFE_SB_SendMsg((CFE_SB_Msg_t *)&CFE_SB.SubRprtMsg);
        2: 1007:          CFE_EVS_SendEventWithAppID(CFE_SB_UNSUBSCRIPTION_RPT_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -: 1008:            "Sending Unsubscription Report Msg=0x%x,Pipe=%d,Stat=0x%x",
        -: 1009:            (unsigned int)MsgId,(int)PipeId,(unsigned int)Stat);
        2: 1010:          CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1011:        }/* end if */
        -: 1012:
        -: 1013:    }/* end if */
        -: 1014:
      423: 1015:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1016:
      423: 1017:    CFE_EVS_SendEventWithAppID(CFE_SB_SUBSCRIPTION_REMOVED_EID,CFE_EVS_DEBUG,CFE_SB.AppId,
        -: 1018:            "Subscription Removed:Msg 0x%x on pipe %d,app %s",
        -: 1019:            MsgId,PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        -: 1020:
      423: 1021:    return CFE_SUCCESS;
        -: 1022:
        -: 1023:}/* end CFE_SB_UnsubscribeFull */
        -: 1024:
        -: 1025:
        -: 1026:
        -: 1027:/******************************************************************************
        -: 1028:** Name:    CFE_SB_SendMsg
        -: 1029:**
        -: 1030:** Purpose: API used to send a message on the software bus.
        -: 1031:**
        -: 1032:** Assumptions, External Events, and Notes:
        -: 1033:**
        -: 1034:**          Note: This function increments and tracks the source sequence
        -: 1035:**                counter for all telemetry messages.
        -: 1036:**
        -: 1037:** Date Written:
        -: 1038:**          04/25/2005
        -: 1039:**
        -: 1040:** Input Arguments:
        -: 1041:**          MsgPtr
        -: 1042:**
        -: 1043:** Output Arguments:
        -: 1044:**          None
        -: 1045:**
        -: 1046:** Return Values:
        -: 1047:**          Status
        -: 1048:**
        -: 1049:******************************************************************************/
        -: 1050:int32  CFE_SB_SendMsg(CFE_SB_Msg_t    *MsgPtr)
       38: 1051:{
       38: 1052:    int32   Status = 0;
        -: 1053:
       38: 1054:    Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_INCREMENT_TLM,CFE_SB_SEND_ONECOPY);
        -: 1055:
       38: 1056:    return Status;
        -: 1057:
        -: 1058:}/* end CFE_SB_SendMsg */
        -: 1059:
        -: 1060:
        -: 1061:
        -: 1062:/******************************************************************************
        -: 1063:** Name:    CFE_SB_PassMsg
        -: 1064:**
        -: 1065:** Purpose: API used to send a message on the software bus.
        -: 1066:**
        -: 1067:** Assumptions, External Events, and Notes:
        -: 1068:**
        -: 1069:**          Note: This function does NOT increment and track the source
        -: 1070:**                sequence counter for telemetry messages.
        -: 1071:**
        -: 1072:** Date Written:
        -: 1073:**          04/25/2005
        -: 1074:**
        -: 1075:** Input Arguments:
        -: 1076:**          MsgPtr
        -: 1077:**
        -: 1078:** Output Arguments:
        -: 1079:**          None
        -: 1080:**
        -: 1081:** Return Values:
        -: 1082:**          Status
        -: 1083:**
        -: 1084:******************************************************************************/
        -: 1085:int32  CFE_SB_PassMsg(CFE_SB_Msg_t    *MsgPtr)
        1: 1086:{
        1: 1087:    int32   Status = 0;
        -: 1088:
        1: 1089:    Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_DO_NOT_INCREMENT,CFE_SB_SEND_ONECOPY);
        -: 1090:
        1: 1091:    return Status;
        -: 1092:
        -: 1093:}/* end CFE_SB_PassMsg */
        -: 1094:
        -: 1095:
        -: 1096:
        -: 1097:/******************************************************************************
        -: 1098:** Name:    CFE_SB_SendMsgFull
        -: 1099:**
        -: 1100:** Purpose: API used to send a message on the software bus.
        -: 1101:**
        -: 1102:** Assumptions, External Events, and Notes:
        -: 1103:**
        -: 1104:**          Note: This function increments and tracks the source sequence
        -: 1105:**                counter for all telemetry messages.
        -: 1106:**
        -: 1107:** Date Written:
        -: 1108:**          04/25/2005
        -: 1109:**
        -: 1110:** Input Arguments:
        -: 1111:**          MsgPtr
        -: 1112:**          TlmCntIncrements
        -: 1113:**          CopyMode
        -: 1114:**
        -: 1115:** Output Arguments:
        -: 1116:**          None
        -: 1117:**
        -: 1118:** Return Values:
        -: 1119:**          Status
        -: 1120:**
        -: 1121:******************************************************************************/
        -: 1122:int32  CFE_SB_SendMsgFull(CFE_SB_Msg_t    *MsgPtr,
        -: 1123:                          uint32           TlmCntIncrements,
        -: 1124:                          uint32           CopyMode)
       45: 1125:{
        -: 1126:    CFE_SB_MsgId_t          MsgId;
        -: 1127:    int32                   Status;
       45: 1128:    CFE_SB_DestinationD_t   *DestPtr = NULL;
        -: 1129:    CFE_SB_PipeD_t          *PipeDscPtr;
        -: 1130:    CFE_SB_RouteEntry_t     *RtgTblPtr;
        -: 1131:    CFE_SB_BufferD_t        *BufDscPtr;
        -: 1132:    uint16                  TotalMsgSize;
        -: 1133:    uint16                  RtgTblIdx;
       45: 1134:    uint32                  TskId = 0;
        -: 1135:    uint16                  i;
        -: 1136:    char                    FullName[(OS_MAX_API_NAME * 2)];
        -: 1137:    CFE_SB_EventBuf_t       SBSndErr;
        -: 1138:
       45: 1139:    SBSndErr.EvtsToSnd = 0;
        -: 1140:
        -: 1141:    /* get task id for events and Sender Info*/
       45: 1142:    TskId = OS_TaskGetId();
        -: 1143:
        -: 1144:    /* check input parameter */
       45: 1145:    if(MsgPtr == NULL){
        1: 1146:        CFE_SB_LockSharedData(__func__,__LINE__);
        1: 1147:        CFE_SB.HKTlmMsg.Payload.MsgSendErrCnt++;
        1: 1148:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1149:        CFE_EVS_SendEventWithAppID(CFE_SB_SEND_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1150:            "Send Err:Bad input argument,Arg 0x%lx,App %s",
        -: 1151:            (unsigned long)MsgPtr,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1152:        return CFE_SB_BAD_ARGUMENT;
        -: 1153:    }/* end if */
        -: 1154:
       44: 1155:    MsgId = CFE_SB_GetMsgId(MsgPtr);
        -: 1156:
        -: 1157:    /* validate the msgid in the message */
       44: 1158:    if(CFE_SB_ValidateMsgId(MsgId) != CFE_SUCCESS){
        2: 1159:        CFE_SB_LockSharedData(__func__,__LINE__);
        2: 1160:        CFE_SB.HKTlmMsg.Payload.MsgSendErrCnt++;
        2: 1161:        if (CopyMode == CFE_SB_SEND_ZEROCOPY)
        -: 1162:        {
        1: 1163:            BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
        1: 1164:            CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1165:        }
        2: 1166:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2: 1167:        CFE_EVS_SendEventWithAppID(CFE_SB_SEND_INV_MSGID_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1168:            "Send Err:Invalid MsgId(0x%x)in msg,App %s",
        -: 1169:            MsgId,CFE_SB_GetAppTskName(TskId,FullName));
        2: 1170:        return CFE_SB_BAD_ARGUMENT;
        -: 1171:    }/* end if */
        -: 1172:
       42: 1173:    TotalMsgSize = CFE_SB_GetTotalMsgLength(MsgPtr);
        -: 1174:
        -: 1175:    /* Verify the size of the pkt is < or = the mission defined max */
       42: 1176:    if(TotalMsgSize > CFE_SB_MAX_SB_MSG_SIZE){
        2: 1177:        CFE_SB_LockSharedData(__func__,__LINE__);
        2: 1178:        CFE_SB.HKTlmMsg.Payload.MsgSendErrCnt++;
        2: 1179:        if (CopyMode == CFE_SB_SEND_ZEROCOPY)
        -: 1180:        {
        1: 1181:            BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
        1: 1182:            CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1183:        }
        2: 1184:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2: 1185:        CFE_EVS_SendEventWithAppID(CFE_SB_MSG_TOO_BIG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1186:            "Send Err:Msg Too Big MsgId=0x%x,app=%s,size=%d,MaxSz=%d",
        -: 1187:            MsgId,CFE_SB_GetAppTskName(TskId,FullName),TotalMsgSize,CFE_SB_MAX_SB_MSG_SIZE);
        2: 1188:        return CFE_SB_MSG_TOO_BIG;
        -: 1189:    }/* end if */
        -: 1190:
        -: 1191:    /* take semaphore to prevent a task switch during this call */
       40: 1192:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1193:
       40: 1194:    RtgTblIdx = CFE_SB_GetRoutingTblIdx(MsgId);
        -: 1195:
        -: 1196:    /* if there have been no subscriptions for this pkt, */
        -: 1197:    /* increment the dropped pkt cnt, send event and return success */
       40: 1198:    if(RtgTblIdx == CFE_SB_AVAILABLE){
        -: 1199:
       16: 1200:        CFE_SB.HKTlmMsg.Payload.NoSubscribersCnt++;
        -: 1201:
       16: 1202:        if (CopyMode == CFE_SB_SEND_ZEROCOPY){
        1: 1203:            BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
        1: 1204:            CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1205:        }
        -: 1206:
       16: 1207:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1208:
        -: 1209:        /* Determine if event can be sent without causing recursive event problem */
       16: 1210:        if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_SEND_NO_SUBS_EID_BIT) == CFE_SB_GRANTED){
        -: 1211:
       15: 1212:           CFE_EVS_SendEventWithAppID(CFE_SB_SEND_NO_SUBS_EID,CFE_EVS_INFORMATION,CFE_SB.AppId,
        -: 1213:              "No subscribers for MsgId 0x%x,sender %s",
        -: 1214:              MsgId,CFE_SB_GetAppTskName(TskId,FullName));
        -: 1215:
        -: 1216:           /* clear the bit so the task may send this event again */
       15: 1217:           CFE_SB_FinishSendEvent(TskId,CFE_SB_SEND_NO_SUBS_EID_BIT);
        -: 1218:        }/* end if */
        -: 1219:
       16: 1220:        return CFE_SUCCESS;
        -: 1221:    }/* end if */
        -: 1222:
        -: 1223:    /* Allocate a new buffer. */
       24: 1224:    if (CopyMode == CFE_SB_SEND_ZEROCOPY){
        3: 1225:        BufDscPtr = CFE_SB_GetBufferFromCaller(MsgId, MsgPtr);
        -: 1226:    }
        -: 1227:    else{
       21: 1228:        BufDscPtr = CFE_SB_GetBufferFromPool(MsgId, TotalMsgSize);
        -: 1229:    }
       24: 1230:    if (BufDscPtr == NULL){
        2: 1231:        CFE_SB.HKTlmMsg.Payload.MsgSendErrCnt++;
        2: 1232:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1233:
        -: 1234:        /* Determine if event can be sent without causing recursive event problem */
        2: 1235:        if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_GET_BUF_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1236:
        1: 1237:            CFE_EVS_SendEventWithAppID(CFE_SB_GET_BUF_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1238:              "Send Err:Request for Buffer Failed. MsgId 0x%x,app %s,size %d",
        -: 1239:              MsgId,CFE_SB_GetAppTskName(TskId,FullName),TotalMsgSize);
        -: 1240:
        -: 1241:            /* clear the bit so the task may send this event again */
        1: 1242:            CFE_SB_FinishSendEvent(TskId,CFE_SB_GET_BUF_ERR_EID_BIT);
        -: 1243:        }/* end if */
        -: 1244:
        2: 1245:        return CFE_SB_BUF_ALOC_ERR;
        -: 1246:    }/* end if */
        -: 1247:
        -: 1248:    /* Copy the packet into the SB memory space */
       22: 1249:    if (CopyMode != CFE_SB_SEND_ZEROCOPY){
        -: 1250:        /* Copy the packet into the SB memory space */
       19: 1251:        CFE_PSP_MemCpy( BufDscPtr->Buffer, MsgPtr, (uint16)TotalMsgSize );
        -: 1252:    }
        -: 1253:
        -: 1254:    /* For Tlm packets, increment the seq count if requested */
       22: 1255:    if((CFE_SB_GetPktType(MsgId)==CFE_SB_TLM) &&
        -: 1256:       (TlmCntIncrements==CFE_SB_INCREMENT_TLM)){
       18: 1257:        CFE_SB.RoutingTbl[RtgTblIdx].SeqCnt++;
       18: 1258:        CFE_SB_SetMsgSeqCnt((CFE_SB_Msg_t *)BufDscPtr->Buffer,
        -: 1259:                              CFE_SB.RoutingTbl[RtgTblIdx].SeqCnt);
        -: 1260:    }/* end if */
        -: 1261:
        -: 1262:    /* store the sender information */
       22: 1263:    if(CFE_SB.SenderReporting != 0)
        -: 1264:    {
       21: 1265:       BufDscPtr->Sender.ProcessorId = CFE_PSP_GetProcessorId();
       21: 1266:       strncpy(&BufDscPtr->Sender.AppName[0],CFE_SB_GetAppTskName(TskId,FullName),OS_MAX_API_NAME);
        -: 1267:    }
        -: 1268:
       22: 1269:    RtgTblPtr = &CFE_SB.RoutingTbl[RtgTblIdx];
        -: 1270:
        -: 1271:    /* At this point there must be at least one destination for pkt */
        -: 1272:
       22: 1273:    DestPtr = RtgTblPtr -> ListHeadPtr;
        -: 1274:
        -: 1275:    /* Send the packet to all destinations  */
       44: 1276:    for (i=0; i < RtgTblPtr -> Destinations; i++) {
        -: 1277:
        -: 1278:        /* The DestPtr should never be NULL in this loop, this is just extra
        -: 1279:           protection in case of the unforseen */
       22: 1280:        if(DestPtr == NULL){
    #####: 1281:          break;
        -: 1282:        }
        -: 1283:
       22: 1284:        if (DestPtr->Active != CFE_SB_INACTIVE)    /* destination is active */
        -: 1285:        {
        -: 1286:
       21: 1287:        PipeDscPtr = &CFE_SB.PipeTbl[DestPtr->PipeId];
        -: 1288:
        -: 1289:        /* if Msg limit exceeded, log event, increment counter */
        -: 1290:        /* and go to next destination */
       21: 1291:        if(DestPtr->BuffCount >= DestPtr->MsgId2PipeLim){
        -: 1292:
        2: 1293:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].PipeId  = DestPtr->PipeId;
        2: 1294:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].EventId = CFE_SB_MSGID_LIM_ERR_EID;
        2: 1295:            SBSndErr.EvtsToSnd++;
        2: 1296:            CFE_SB.HKTlmMsg.Payload.MsgLimErrCnt++;
        2: 1297:            PipeDscPtr->SendErrors++;
        -: 1298:
        -: 1299:            }else{
        -: 1300:        /*
        -: 1301:        ** Write the buffer descriptor to the queue of the pipe.  If the write
        -: 1302:        ** failed, log info and increment the pipe's error counter.
        -: 1303:        */
       19: 1304:                Status = OS_QueuePut(PipeDscPtr->SysQueueId,(void *)&BufDscPtr,
        -: 1305:                                     sizeof(CFE_SB_BufferD_t *),0);
        -: 1306:
       19: 1307:        if (Status == OS_SUCCESS) {
       15: 1308:            BufDscPtr->UseCount++;    /* used for releasing buffer  */
       15: 1309:            DestPtr->BuffCount++; /* used for checking MsgId2PipeLimit */
       15: 1310:            DestPtr->DestCnt++;   /* used for statistics */
       15: 1311:            if (DestPtr->PipeId < CFE_SB_TLM_PIPEDEPTHSTATS_SIZE)
        -: 1312:            {
        -: 1313:                CFE_SB_PipeDepthStats_t *StatObj =
       15: 1314:                        &CFE_SB.StatTlmMsg.Payload.PipeDepthStats[DestPtr->PipeId];
       15: 1315:                StatObj->InUse++;
       15: 1316:                if(StatObj->InUse > StatObj->PeakInUse){
       13: 1317:                    StatObj->PeakInUse = StatObj->InUse;
        -: 1318:            }/* end if */
        -: 1319:            }
        -: 1320:
        4: 1321:        }else if(Status == OS_QUEUE_FULL) {
        -: 1322:
        2: 1323:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].PipeId  = DestPtr->PipeId;
        2: 1324:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].EventId = CFE_SB_Q_FULL_ERR_EID;
        2: 1325:            SBSndErr.EvtsToSnd++;
        2: 1326:            CFE_SB.HKTlmMsg.Payload.PipeOverflowErrCnt++;
        2: 1327:            PipeDscPtr->SendErrors++;
        -: 1328:
        -: 1329:
        -: 1330:        }else{ /* Unexpected error while writing to queue. */
        -: 1331:
        2: 1332:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].PipeId  = DestPtr->PipeId;
        2: 1333:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].EventId = CFE_SB_Q_WR_ERR_EID;
        2: 1334:            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd].ErrStat = Status;
        2: 1335:            SBSndErr.EvtsToSnd++;
        2: 1336:            CFE_SB.HKTlmMsg.Payload.InternalErrCnt++;
        2: 1337:            PipeDscPtr->SendErrors++;
        -: 1338:
        -: 1339:                }/*end if */
        -: 1340:            }/*end if */
        -: 1341:        }/*end if */
        -: 1342:
       22: 1343:        DestPtr = DestPtr -> Next;
        -: 1344:
        -: 1345:    } /* end loop over destinations */
        -: 1346:
        -: 1347:    /*
        -: 1348:    ** Decrement the buffer UseCount and free buffer if cnt=0. This decrement is done
        -: 1349:    ** because the use cnt is initialized to 1 in CFE_SB_GetBufferFromPool.
        -: 1350:    ** Initializing the count to 1 (as opposed to zero) and decrementing it here are
        -: 1351:    ** done to ensure the buffer gets released when there are destinations that have
        -: 1352:    ** been disabled via ground command.
        -: 1353:    */
       22: 1354:    CFE_SB_DecrBufUseCnt(BufDscPtr);
        -: 1355:
        -: 1356:    /* release the semaphore */
       22: 1357:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1358:
        -: 1359:
        -: 1360:    /* send an event for each pipe write error that may have occurred */
       28: 1361:    for(i=0;i < SBSndErr.EvtsToSnd; i++)
        -: 1362:    {
        6: 1363:        if(SBSndErr.EvtBuf[i].EventId == CFE_SB_MSGID_LIM_ERR_EID)
        -: 1364:        {
        -: 1365:            /* Determine if event can be sent without causing recursive event problem */
        2: 1366:            if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_MSGID_LIM_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1367:
        1: 1368:              CFE_ES_PerfLogEntry(CFE_SB_MSG_LIM_PERF_ID);
        1: 1369:              CFE_ES_PerfLogExit(CFE_SB_MSG_LIM_PERF_ID);
        -: 1370:
        1: 1371:              CFE_EVS_SendEventWithAppID(CFE_SB_MSGID_LIM_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1372:                "Msg Limit Err,MsgId 0x%x,pipe %s,sender %s",
        -: 1373:                (unsigned int)RtgTblPtr->MsgId,
        -: 1374:                CFE_SB_GetPipeName(SBSndErr.EvtBuf[i].PipeId),
        -: 1375:                CFE_SB_GetAppTskName(TskId,FullName));
        -: 1376:
        -: 1377:              /* clear the bit so the task may send this event again */
        1: 1378:              CFE_SB_FinishSendEvent(TskId,CFE_SB_MSGID_LIM_ERR_EID_BIT);
        -: 1379:            }/* end if */
        -: 1380:
        4: 1381:        }else if(SBSndErr.EvtBuf[i].EventId == CFE_SB_Q_FULL_ERR_EID){
        -: 1382:
        -: 1383:            /* Determine if event can be sent without causing recursive event problem */
        2: 1384:            if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_Q_FULL_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1385:
        1: 1386:              CFE_ES_PerfLogEntry(CFE_SB_PIPE_OFLOW_PERF_ID);
        1: 1387:              CFE_ES_PerfLogExit(CFE_SB_PIPE_OFLOW_PERF_ID);
        -: 1388:
        1: 1389:              CFE_EVS_SendEventWithAppID(CFE_SB_Q_FULL_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1390:                  "Pipe Overflow,MsgId 0x%x,pipe %s,sender %s",
        -: 1391:                  (unsigned int)RtgTblPtr->MsgId,
        -: 1392:                  CFE_SB_GetPipeName(SBSndErr.EvtBuf[i].PipeId),
        -: 1393:                  CFE_SB_GetAppTskName(TskId,FullName));
        -: 1394:
        -: 1395:               /* clear the bit so the task may send this event again */
        1: 1396:              CFE_SB_FinishSendEvent(TskId,CFE_SB_Q_FULL_ERR_EID_BIT);
        -: 1397:            }/* end if */
        -: 1398:
        -: 1399:        }else{
        -: 1400:
        -: 1401:            /* Determine if event can be sent without causing recursive event problem */
        2: 1402:            if(CFE_SB_RequestToSendEvent(TskId,CFE_SB_Q_WR_ERR_EID_BIT) == CFE_SB_GRANTED){
        -: 1403:
        1: 1404:              CFE_EVS_SendEventWithAppID(CFE_SB_Q_WR_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1405:                "Pipe Write Err,MsgId 0x%x,pipe %s,sender %s,stat 0x%x",
        -: 1406:                (unsigned int)RtgTblPtr->MsgId,
        -: 1407:                CFE_SB_GetPipeName(SBSndErr.EvtBuf[i].PipeId),
        -: 1408:                CFE_SB_GetAppTskName(TskId,FullName),
        -: 1409:                (unsigned int)SBSndErr.EvtBuf[i].ErrStat);
        -: 1410:
        -: 1411:               /* clear the bit so the task may send this event again */
        1: 1412:              CFE_SB_FinishSendEvent(TskId,CFE_SB_Q_WR_ERR_EID_BIT);
        -: 1413:            }/* end if */
        -: 1414:
        -: 1415:        }/* end if */
        -: 1416:    }
        -: 1417:
        -: 1418:
       22: 1419:    return CFE_SUCCESS;
        -: 1420:
        -: 1421:}/* end CFE_SB_SendMsgFull */
        -: 1422:
        -: 1423:
        -: 1424:
        -: 1425:/******************************************************************************
        -: 1426:** Name:    CFE_SB_RcvMsg
        -: 1427:**
        -: 1428:** Purpose: API used to receive a message from the software bus.
        -: 1429:**
        -: 1430:** Assumptions, External Events, and Notes:
        -: 1431:**          Notes:
        -: 1432:**
        -: 1433:**
        -: 1434:** Date Written:
        -: 1435:**          04/25/2005
        -: 1436:**
        -: 1437:** Input Arguments:
        -: 1438:**          PipeId
        -: 1439:**          BufPtr
        -: 1440:**          timeOut - CFE_SB_PEND, CFE_SB_POLL or millisecond timeout
        -: 1441:**
        -: 1442:** Output Arguments:
        -: 1443:**          None
        -: 1444:**
        -: 1445:** Return Values:
        -: 1446:**          Status
        -: 1447:**
        -: 1448:******************************************************************************/
        -: 1449:int32  CFE_SB_RcvMsg(CFE_SB_MsgPtr_t    *BufPtr,
        -: 1450:                     CFE_SB_PipeId_t    PipeId,
        -: 1451:                     int32              TimeOut)
      199: 1452:{
        -: 1453:    int32                  Status;
        -: 1454:    CFE_SB_BufferD_t       *Message;
        -: 1455:    CFE_SB_PipeD_t         *PipeDscPtr;
      199: 1456:    CFE_SB_DestinationD_t  *DestPtr = NULL;
      199: 1457:    uint32                 TskId = 0;
        -: 1458:    char                   FullName[(OS_MAX_API_NAME * 2)];
        -: 1459:
        -: 1460:    /* get task id for events */
      199: 1461:    TskId = OS_TaskGetId();
        -: 1462:
        -: 1463:    /* Check input parameters */
      199: 1464:    if((BufPtr == NULL)||(TimeOut < (-1))){
        2: 1465:        CFE_SB_LockSharedData(__func__,__LINE__);
        2: 1466:        CFE_SB.HKTlmMsg.Payload.MsgReceiveErrCnt++;
        2: 1467:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2: 1468:        CFE_EVS_SendEventWithAppID(CFE_SB_RCV_BAD_ARG_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1469:            "Rcv Err:Bad Input Arg:BufPtr 0x%lx,pipe %d,t/o %d,app %s",
        -: 1470:            (unsigned long)BufPtr,(int)PipeId,(int)TimeOut,CFE_SB_GetAppTskName(TskId,FullName));
        2: 1471:        return CFE_SB_BAD_ARGUMENT;
        -: 1472:    }/* end if */
        -: 1473:
      197: 1474:    PipeDscPtr = CFE_SB_GetPipePtr(PipeId);
        -: 1475:    /* If the pipe does not exist or PipeId is out of range... */
      197: 1476:    if (PipeDscPtr == NULL) {
        1: 1477:        CFE_SB_LockSharedData(__func__,__LINE__);
        1: 1478:        CFE_SB.HKTlmMsg.Payload.MsgReceiveErrCnt++;
        1: 1479:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1480:        CFE_EVS_SendEventWithAppID(CFE_SB_BAD_PIPEID_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1481:            "Rcv Err:PipeId %d does not exist,app %s",
        -: 1482:            (int)PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1483:        return CFE_SB_BAD_ARGUMENT;
        -: 1484:    }/* end if */
        -: 1485:
        -: 1486:    /*
        -: 1487:    ** Save off any currently in use buffer to free later; this allows
        -: 1488:    ** one fewer shared data locks
        -: 1489:    */
        -: 1490:
      196: 1491:    PipeDscPtr->ToTrashBuff = PipeDscPtr->CurrentBuff;
      196: 1492:    PipeDscPtr->CurrentBuff = NULL;
        -: 1493:
        -: 1494:    /*
        -: 1495:    ** Read a new buffer from the queue of the pipe, using the
        -: 1496:    ** specified timeout option.  If a buffer was obtained, return the
        -: 1497:    ** packet to the task according to mode.  Otherwise, return a status
        -: 1498:    ** code indicating that no buffer was read.
        -: 1499:    */
      196: 1500:    Status = CFE_SB_ReadQueue(PipeDscPtr, TskId, TimeOut, &Message);
        -: 1501:
        -: 1502:    /* take semaphore again to protect the remaining code in this call */
      196: 1503:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1504:
        -: 1505:    /* free any pending trash buffer */
      196: 1506:    if (PipeDscPtr->ToTrashBuff != NULL) {
        -: 1507:
        -: 1508:        /* Decrement the Buffer Use Count and Free buffer if cnt=0) */
       14: 1509:        CFE_SB_DecrBufUseCnt(PipeDscPtr->ToTrashBuff);
        -: 1510:
       14: 1511:        PipeDscPtr->ToTrashBuff = NULL;
        -: 1512:
        -: 1513:    }/* end if */
        -: 1514:
      196: 1515:    if (Status == CFE_SUCCESS) {
        -: 1516:
        -: 1517:        /*
        -: 1518:        ** Load the pipe tables 'CurrentBuff' with the buffer descriptor
        -: 1519:        ** ptr corresponding to the message just read. This is done so that
        -: 1520:        ** the buffer can be released on the next RcvMsg call for this pipe.
        -: 1521:        */
       15: 1522:        PipeDscPtr->CurrentBuff = Message;
        -: 1523:
        -: 1524:        /* Set the Receivers pointer to the address of the actual message */
       15: 1525:        *BufPtr = (CFE_SB_MsgPtr_t) Message->Buffer;
        -: 1526:
        -: 1527:        /* get pointer to destination to be used in decrementing msg limit cnt*/
       15: 1528:        DestPtr = CFE_SB_GetDestPtr(PipeDscPtr->CurrentBuff->MsgId, PipeDscPtr->PipeId);
        -: 1529:
        -: 1530:        /*
        -: 1531:        ** DestPtr would be NULL if the msg is unsubscribed to while it is on
        -: 1532:        ** the pipe. The BuffCount may be zero if the msg is unsubscribed to and
        -: 1533:        ** then resubscribed to while it is on the pipe. Both of these cases are
        -: 1534:        ** considered nominal and are handled by the code below.
        -: 1535:        */
       15: 1536:        if(DestPtr != NULL){
        -: 1537:
        7: 1538:            if (DestPtr->BuffCount > 0){
        6: 1539:                DestPtr->BuffCount--;
        -: 1540:            }
        -: 1541:
        -: 1542:        }/* end if DestPtr != NULL */
        -: 1543:
       15: 1544:        if (PipeDscPtr->PipeId < CFE_SB_TLM_PIPEDEPTHSTATS_SIZE)
        -: 1545:        {
       15: 1546:        CFE_SB.StatTlmMsg.Payload.PipeDepthStats[PipeDscPtr->PipeId].InUse--;
        -: 1547:        }
        -: 1548:
        -: 1549:    }else{
        -: 1550:
        -: 1551:        /* Set the users pointer to NULL indicating the CFE_SB_ReadQueue failed */
      181: 1552:        *BufPtr = NULL;
        -: 1553:
        -: 1554:    }/* end if */
        -: 1555:
        -: 1556:    /* release the semaphore */
      196: 1557:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1558:
        -: 1559:    /*
        -: 1560:    ** If status is not CFE_SUCCESS, then no packet was received.  If this was
        -: 1561:    ** caused by an unexpected error, then CFE_SB_ReadQueue() will report the
        -: 1562:    ** error.
        -: 1563:    */
      196: 1564:    return Status;
        -: 1565:
        -: 1566:}/* end CFE_SB_RcvMsg */
        -: 1567:
        -: 1568:
        -: 1569:/******************************************************************************
        -: 1570:** Name:    CFE_SB_GetLastSenderId
        -: 1571:**
        -: 1572:** Purpose: API used for receiving sender Information of the last message received on
        -: 1573:**          the given pipe.
        -: 1574:**
        -: 1575:** Assumptions, External Events, and Notes:
        -: 1576:**          None
        -: 1577:**
        -: 1578:** Date Written:
        -: 1579:**          06/13/2007
        -: 1580:**
        -: 1581:** Input Arguments:
        -: 1582:**          Ptr -     caller declares a ptr of type CFE_SB_SenderId_t then gives the
        -: 1583:**                    address of that pointer.
        -: 1584:**          PipeId -  the Pipe Id that the message was received on.
        -: 1585:**
        -: 1586:** Output Arguments:
        -: 1587:**          None
        -: 1588:**
        -: 1589:** Return Values:
        -: 1590:**          Status
        -: 1591:**
        -: 1592:******************************************************************************/
        -: 1593:uint32  CFE_SB_GetLastSenderId(CFE_SB_SenderId_t **Ptr,CFE_SB_PipeId_t  PipeId)
        4: 1594:{
        -: 1595:
        -: 1596:    CFE_SB_BufferD_t *Ptr2BufDescriptor;
        4: 1597:    uint32            TskId = 0;
        4: 1598:    uint32            AppId = 0xFFFFFFFF;
        -: 1599:    char              FullName[(OS_MAX_API_NAME * 2)];
        -: 1600:
        4: 1601:    TskId = OS_TaskGetId();
        -: 1602:
        -: 1603:    /* validate ptr  - note: must validate ptr before pipe id validation  */
        -: 1604:    /* because an invalid pipe id sets the callers pointer to NULL */
        4: 1605:    if(Ptr == NULL){
        1: 1606:      CFE_EVS_SendEventWithAppID(CFE_SB_LSTSNDER_ERR1_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1607:          "SB GetLastSender Err:Rcvd Null Ptr,Pipe=%d,App=%s",
        -: 1608:          PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1609:      return CFE_SB_BAD_ARGUMENT;
        -: 1610:    }/* end if */
        -: 1611:
        -: 1612:    /* validate pipe id */
        3: 1613:    if(CFE_SB_ValidatePipeId(PipeId)!=CFE_SUCCESS){
        1: 1614:      *Ptr = NULL;
        1: 1615:      CFE_EVS_SendEventWithAppID(CFE_SB_LSTSNDER_ERR2_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1616:          "SB GetLastSender Err:Rcvd Invalid Pipe=%d,App=%s",
        -: 1617:          (int)PipeId,CFE_SB_GetAppTskName(TskId,FullName));
        1: 1618:      return CFE_SB_BAD_ARGUMENT;
        -: 1619:    }/* end if */
        -: 1620:
        2: 1621:    CFE_ES_GetAppID(&AppId);
        -: 1622:
        2: 1623:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1624:
        -: 1625:    /* verify requestor is owner of pipe */
        2: 1626:    if(CFE_SB.PipeTbl[PipeId].AppId != AppId){
        1: 1627:      *Ptr = NULL;
        1: 1628:      CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1629:      CFE_EVS_SendEventWithAppID(CFE_SB_GLS_INV_CALLER_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 1630:          "SB GetLastSender Err:Caller(%s) is not the owner of pipe %d",
        -: 1631:          CFE_SB_GetAppTskName(TskId,FullName),(int)PipeId);
        1: 1632:      return CFE_SB_BAD_ARGUMENT;
        -: 1633:    }/* end if */
        -: 1634:
        -: 1635:    /* Get ptr to buffer descriptor for the last msg received on the given pipe */
        1: 1636:    Ptr2BufDescriptor = CFE_SB.PipeTbl[PipeId].CurrentBuff;
        -: 1637:
        -: 1638:    /* Set the receivers pointer to the adr of 'Sender' struct in buf descriptor */
        1: 1639:    *Ptr = (CFE_SB_SenderId_t *) &Ptr2BufDescriptor -> Sender;
        -: 1640:
        1: 1641:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1642:
        1: 1643:    return CFE_SUCCESS;
        -: 1644:
        -: 1645:}/* end CFE_SB_GetLastSenderId */
        -: 1646:
        -: 1647:
        -: 1648:/******************************************************************************
        -: 1649:** Name:    CFE_SB_ZeroCopyGetPtr
        -: 1650:**
        -: 1651:** Purpose: API used for for getting a pointer to a buffer (for zero copy mode
        -: 1652:**          only)
        -: 1653:**
        -: 1654:** Assumptions, External Events, and Notes:
        -: 1655:**          None
        -: 1656:**
        -: 1657:** Date Written:
        -: 1658:**          04/25/2005
        -: 1659:**
        -: 1660:** Input Arguments:
        -: 1661:**          MsgSize
        -: 1662:**
        -: 1663:** Output Arguments:
        -: 1664:**          BufferHandle
        -: 1665:**
        -: 1666:** Return Values:
        -: 1667:**          Pointer to an empty buffer in SB Memory space, or NULL if the buffer
        -: 1668:**          could not be allocated.
        -: 1669:**
        -: 1670:******************************************************************************/
        -: 1671:
        -: 1672:CFE_SB_Msg_t  *CFE_SB_ZeroCopyGetPtr(uint16 MsgSize,
        -: 1673:                                     CFE_SB_ZeroCopyHandle_t *BufferHandle)
       14: 1674:{
        -: 1675:   int32                stat1;
       14: 1676:   uint32               AppId = 0xFFFFFFFF;
       14: 1677:   uint8               *address = NULL;
       14: 1678:   CFE_SB_ZeroCopyD_t  *zcd = NULL;
       14: 1679:   CFE_SB_BufferD_t    *bd = NULL;
        -: 1680:
       14: 1681:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1682:
        -: 1683:    /* Allocate a new zero copy descriptor from the SB memory pool.*/
       14: 1684:    stat1 = CFE_ES_GetPoolBuf((uint32 **)&zcd, CFE_SB.Mem.PoolHdl,  sizeof(CFE_SB_ZeroCopyD_t));
       14: 1685:    if(stat1 < 0){
        1: 1686:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        1: 1687:        return NULL;
        -: 1688:    }
        -: 1689:
        -: 1690:    /* Add the size of a zero copy descriptor to the memory-in-use ctr and */
        -: 1691:    /* adjust the high water mark if needed */
       13: 1692:    CFE_SB.StatTlmMsg.Payload.MemInUse+=stat1;
       13: 1693:    if(CFE_SB.StatTlmMsg.Payload.MemInUse > CFE_SB.StatTlmMsg.Payload.PeakMemInUse){
       12: 1694:       CFE_SB.StatTlmMsg.Payload.PeakMemInUse = CFE_SB.StatTlmMsg.Payload.MemInUse;
        -: 1695:    }/* end if */
        -: 1696:
        -: 1697:    /* Allocate a new buffer (from the SB memory pool) to hold the message  */
       13: 1698:    stat1 = CFE_ES_GetPoolBuf((uint32 **)&bd, CFE_SB.Mem.PoolHdl, MsgSize + sizeof(CFE_SB_BufferD_t));
       13: 1699:    if((stat1 < 0)||(bd==NULL)){
        -: 1700:        /*deallocate the first buffer if the second buffer creation fails*/
        2: 1701:        stat1 = CFE_ES_PutPoolBuf(CFE_SB.Mem.PoolHdl, (uint32 *)zcd);
        2: 1702:        if(stat1 > 0){
        1: 1703:            CFE_SB.StatTlmMsg.Payload.MemInUse-=stat1;
        -: 1704:        }
        2: 1705:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        2: 1706:        return NULL;
        -: 1707:    }
        -: 1708:
        -: 1709:    /* Increment the number of buffers in use by one even though two buffers */
        -: 1710:    /* were allocated. SBBuffersInUse increments on a per-message basis */
       11: 1711:    CFE_SB.StatTlmMsg.Payload.SBBuffersInUse++;
       11: 1712:    if(CFE_SB.StatTlmMsg.Payload.SBBuffersInUse > CFE_SB.StatTlmMsg.Payload.PeakSBBuffersInUse){
       10: 1713:        CFE_SB.StatTlmMsg.Payload.PeakSBBuffersInUse = CFE_SB.StatTlmMsg.Payload.SBBuffersInUse;
        -: 1714:    }/* end if */
        -: 1715:
        -: 1716:    /* Add the size of the actual buffer to the memory-in-use ctr and */
        -: 1717:    /* adjust the high water mark if needed */
       11: 1718:    CFE_SB.StatTlmMsg.Payload.MemInUse+=stat1;
       11: 1719:    if(CFE_SB.StatTlmMsg.Payload.MemInUse > CFE_SB.StatTlmMsg.Payload.PeakMemInUse){
       10: 1720:       CFE_SB.StatTlmMsg.Payload.PeakMemInUse = CFE_SB.StatTlmMsg.Payload.MemInUse;
        -: 1721:    }/* end if */
        -: 1722:
        -: 1723:    /* first set ptr to actual msg buffer the same as ptr to descriptor */
       11: 1724:    address = (uint8 *)bd;
        -: 1725:
        -: 1726:    /* increment actual msg buffer ptr beyond the descriptor */
       11: 1727:    address += sizeof(CFE_SB_BufferD_t);
        -: 1728:
        -: 1729:    /* Initialize the zero copy descriptor structure. */
       11: 1730:    zcd->Size      = MsgSize;
       11: 1731:    zcd->Buffer    = (void *)address;
       11: 1732:    zcd->Next      = NULL;
        -: 1733:
        -: 1734:    /* Add this Zero Copy Descriptor to the end of the chain */
       11: 1735:    if(CFE_SB.ZeroCopyTail != NULL){
        3: 1736:        ((CFE_SB_ZeroCopyD_t *) CFE_SB.ZeroCopyTail)->Next = (void *)zcd;
        -: 1737:    }
       11: 1738:    zcd->Prev = CFE_SB.ZeroCopyTail;
       11: 1739:    CFE_SB.ZeroCopyTail = (void *)zcd;
        -: 1740:
       11: 1741:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1742:
        -: 1743:    /* get callers AppId */
       11: 1744:    CFE_ES_GetAppID(&AppId);
       11: 1745:    zcd->AppID     = AppId;
        -: 1746:
       11: 1747:    (*BufferHandle) = (CFE_SB_ZeroCopyHandle_t) zcd;
        -: 1748:
        -: 1749:    /* Initialize the buffer descriptor structure. */
       11: 1750:    bd->UseCount  = 1;
       11: 1751:    bd->Size      = MsgSize;
       11: 1752:    bd->Buffer    = (void *)address;
        -: 1753:
       11: 1754:    return (CFE_SB_Msg_t *)address;
        -: 1755:
        -: 1756:}/* CFE_SB_ZeroCopyGetPtr */
        -: 1757:
        -: 1758:
        -: 1759:/******************************************************************************
        -: 1760:** Name:    CFE_SB_ZeroCopyReleasePtr
        -: 1761:**
        -: 1762:** Purpose: API used for releasing a pointer to a buffer (for zero copy mode
        -: 1763:**          only) This function is typically not needed for zero copy transfers.
        -: 1764:**          This function is needed only when a ptr is received via
        -: 1765:**          CFE_SB_ZeroCopyGetPtr, but never used in a send.
        -: 1766:**
        -: 1767:** Assumptions, External Events, and Notes:
        -: 1768:**          None
        -: 1769:**
        -: 1770:** Date Written:
        -: 1771:**          04/25/2005
        -: 1772:**
        -: 1773:** Input Arguments:
        -: 1774:**          Ptr2Release
        -: 1775:**          BufferHandle
        -: 1776:**
        -: 1777:** Output Arguments:
        -: 1778:**          None
        -: 1779:**
        -: 1780:** Return Values:
        -: 1781:**          Status
        -: 1782:**
        -: 1783:******************************************************************************/
        -: 1784:int32 CFE_SB_ZeroCopyReleasePtr(CFE_SB_Msg_t  *Ptr2Release,
        -: 1785:                                CFE_SB_ZeroCopyHandle_t BufferHandle)
       10: 1786:{
        -: 1787:    int32    Status;
        -: 1788:    int32    Stat2;
        -: 1789:
       10: 1790:    Status = CFE_SB_ZeroCopyReleaseDesc(Ptr2Release, BufferHandle);
        -: 1791:
       10: 1792:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1793:
       10: 1794:    if(Status == CFE_SUCCESS){
        -: 1795:        /* give the buffer back to the buffer pool */
        7: 1796:        Stat2 = CFE_ES_PutPoolBuf(CFE_SB.Mem.PoolHdl,
        -: 1797:                                  (uint32 *) (((uint8 *)Ptr2Release) - sizeof(CFE_SB_BufferD_t)));
        7: 1798:        if(Stat2 > 0){
        -: 1799:             /* Substract the size of the actual buffer from the Memory in use ctr */
        6: 1800:            CFE_SB.StatTlmMsg.Payload.MemInUse-=Stat2;
        6: 1801:            CFE_SB.StatTlmMsg.Payload.SBBuffersInUse--;
        -: 1802:        }/* end if */
        -: 1803:    }
        -: 1804:
       10: 1805:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1806:
       10: 1807:    return Status;
        -: 1808:
        -: 1809:}/* end CFE_SB_ZeroCopyReleasePtr */
        -: 1810:
        -: 1811:
        -: 1812:/******************************************************************************
        -: 1813:** Name:    CFE_SB_ZeroCopyReleaseDesc
        -: 1814:**
        -: 1815:** Purpose: API used for releasing a zero copy descriptor (for zero copy mode
        -: 1816:**          only).
        -: 1817:**
        -: 1818:** Assumptions, External Events, and Notes:
        -: 1819:**          None
        -: 1820:**
        -: 1821:** Date Written:
        -: 1822:**          04/25/2005
        -: 1823:**
        -: 1824:** Input Arguments:
        -: 1825:**          Ptr2Release
        -: 1826:**          BufferHandle
        -: 1827:**
        -: 1828:** Output Arguments:
        -: 1829:**          None
        -: 1830:**
        -: 1831:** Return Values:
        -: 1832:**          Status
        -: 1833:**
        -: 1834:******************************************************************************/
        -: 1835:int32 CFE_SB_ZeroCopyReleaseDesc(CFE_SB_Msg_t  *Ptr2Release,
        -: 1836:                                 CFE_SB_ZeroCopyHandle_t  BufferHandle)
       14: 1837:{
        -: 1838:    int32    Stat;
       14: 1839:    CFE_SB_ZeroCopyD_t *zcd = (CFE_SB_ZeroCopyD_t *) BufferHandle;
        -: 1840:
       14: 1841:    CFE_SB_LockSharedData(__func__,__LINE__);
        -: 1842:
       14: 1843:    Stat = CFE_ES_GetPoolBufInfo(CFE_SB.Mem.PoolHdl, (uint32 *)zcd);
        -: 1844:
       14: 1845:    if((Ptr2Release == NULL) || (Stat < 0) || (zcd->Buffer != (void *)Ptr2Release)){
        5: 1846:        CFE_SB_UnlockSharedData(__func__,__LINE__);
        5: 1847:        return CFE_SB_BUFFER_INVALID;
        -: 1848:    }
        -: 1849:
        -: 1850:    /* delink the descriptor */
        9: 1851:    if(zcd->Prev != NULL){
        5: 1852:        ((CFE_SB_ZeroCopyD_t *) (zcd->Prev))->Next = zcd->Next;
        -: 1853:    }
        9: 1854:    if(zcd->Next != NULL){
        3: 1855:        ((CFE_SB_ZeroCopyD_t *) (zcd->Next))->Prev = zcd->Prev;
        -: 1856:    }
        9: 1857:    if(CFE_SB.ZeroCopyTail == (void *)zcd){
        6: 1858:        CFE_SB.ZeroCopyTail = zcd->Prev;
        -: 1859:    }
        -: 1860:
        -: 1861:    /* give the descriptor back to the buffer pool */
        9: 1862:    Stat = CFE_ES_PutPoolBuf(CFE_SB.Mem.PoolHdl, (uint32 *)zcd);
        9: 1863:    if(Stat > 0){
        -: 1864:        /* Substract the size of the actual buffer from the Memory in use ctr */
        8: 1865:        CFE_SB.StatTlmMsg.Payload.MemInUse-=Stat;
        -: 1866:    }/* end if */
        -: 1867:
        9: 1868:    CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 1869:
        9: 1870:    return CFE_SUCCESS;
        -: 1871:
        -: 1872:}/* end CFE_SB_ZeroCopyReleaseDesc */
        -: 1873:
        -: 1874:
        -: 1875:/******************************************************************************
        -: 1876:** Name:    CFE_SB_ZeroCopySend
        -: 1877:**
        -: 1878:** Purpose: API for sending messages in zero copy mode (with telemetry source
        -: 1879:**          sequence count incrementing)
        -: 1880:**
        -: 1881:** Assumptions, External Events, and Notes:
        -: 1882:**          None
        -: 1883:**
        -: 1884:** Date Written:
        -: 1885:**          04/25/2005
        -: 1886:**
        -: 1887:** Input Arguments:
        -: 1888:**          MsgPtr - Pointer to message to be sent
        -: 1889:**          BufferHandle - Handle supplied by the get pointer call
        -: 1890:**
        -: 1891:** Output Arguments:
        -: 1892:**          None
        -: 1893:**
        -: 1894:** Return Values:
        -: 1895:**          Status
        -: 1896:**
        -: 1897:******************************************************************************/
        -: 1898:int32 CFE_SB_ZeroCopySend(CFE_SB_Msg_t   *MsgPtr,
        -: 1899:                          CFE_SB_ZeroCopyHandle_t BufferHandle)
        2: 1900:{
        2: 1901:    int32   Status = 0;
        -: 1902:
        2: 1903:    Status = CFE_SB_ZeroCopyReleaseDesc(MsgPtr, BufferHandle);
        -: 1904:
        2: 1905:    if(Status == CFE_SUCCESS){
        1: 1906:        Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_INCREMENT_TLM,CFE_SB_SEND_ZEROCOPY);
        -: 1907:    }
        -: 1908:
        2: 1909:    return Status;
        -: 1910:
        -: 1911:}/* end CFE_SB_ZeroCopySend */
        -: 1912:
        -: 1913:
        -: 1914:/******************************************************************************
        -: 1915:** Name:    CFE_SB_ZeroCopyPass
        -: 1916:**
        -: 1917:** Purpose: API for sending messages in zero copy mode (telemetry source
        -: 1918:**          sequence count is preserved)
        -: 1919:**
        -: 1920:** Assumptions, External Events, and Notes:
        -: 1921:**          None
        -: 1922:**
        -: 1923:** Date Written:
        -: 1924:**          04/25/2005
        -: 1925:**
        -: 1926:** Input Arguments:
        -: 1927:**          MsgPtr - Pointer to message to be sent
        -: 1928:**          BufferHandle - Handle supplied by the get pointer call
        -: 1929:**
        -: 1930:** Output Arguments:
        -: 1931:**          None
        -: 1932:**
        -: 1933:** Return Values:
        -: 1934:**          Status
        -: 1935:**
        -: 1936:******************************************************************************/
        -: 1937:int32 CFE_SB_ZeroCopyPass(CFE_SB_Msg_t   *MsgPtr,
        -: 1938:                          CFE_SB_ZeroCopyHandle_t BufferHandle)
        2: 1939:{
        2: 1940:    int32   Status = 0;
        -: 1941:
        2: 1942:    Status = CFE_SB_ZeroCopyReleaseDesc(MsgPtr, BufferHandle);
        -: 1943:
        2: 1944:    if(Status == CFE_SUCCESS){
        1: 1945:        Status = CFE_SB_SendMsgFull(MsgPtr,CFE_SB_DO_NOT_INCREMENT,CFE_SB_SEND_ZEROCOPY);
        -: 1946:    }
        -: 1947:
        2: 1948:    return Status;
        -: 1949:
        -: 1950:}/* end CFE_SB_ZeroCopyPass */
        -: 1951:
        -: 1952:
        -: 1953:/******************************************************************************
        -: 1954:**  Function:  CFE_SB_ReadQueue()
        -: 1955:**
        -: 1956:**  Purpose:
        -: 1957:**    Read an SB message from the system queue.  The message is represented
        -: 1958:**    by a pointer to the buffer descriptor of the message.  Several options
        -: 1959:**    are available for the timeout, as described below.
        -: 1960:**
        -: 1961:**  Arguments:
        -: 1962:**    PipeDscPtr: Pointer to pipe descriptor.
        -: 1963:**    AppId     : Application ID of the receiving task (used for error messages).
        -: 1964:**    Time_Out  : Timeout option; one of the following:
        -: 1965:**                  CFE_SB_PEND_FOREVER  = wait forever until a packet arrives
        -: 1966:**                  CFE_SB_POLL = check the pipe for packets but don't wait
        -: 1967:**                  value in milliseconds = wait up to a specified time
        -: 1968:**    Message   : Pointer to a variable that will receive the buffer
        -: 1969:**                descriptor of the message.
        -: 1970:**
        -: 1971:**  Return:
        -: 1972:**    CFE_SB status code indicating the result of the operation:
        -: 1973:**      CFE_SUCCESS         = message was successfully read
        -: 1974:**      CFE_SB_NO_MESSAGE   = no message is present (for CFE_SB_POLL option)
        -: 1975:**      CFE_SB_TIME_OUT     = timeout expired (for timeout option)
        -: 1976:**      CFE_SB_PIPE_RD_ERR  = an unexpected queue read error occurred
        -: 1977:*/
        -: 1978:
        -: 1979:int32  CFE_SB_ReadQueue (CFE_SB_PipeD_t         *PipeDscPtr,
        -: 1980:                         uint32                 TskId,
        -: 1981:                         CFE_SB_TimeOut_t       Time_Out,
        -: 1982:                         CFE_SB_BufferD_t       **Message)
      196: 1983:{
        -: 1984:    int32              Status,TimeOut;
        -: 1985:    uint32             Nbytes;
        -: 1986:    char               FullName[(OS_MAX_API_NAME * 2)];
        -: 1987:
        -: 1988:    /* translate the given Time_Out value */
      196: 1989:    switch(Time_Out){
        -: 1990:
        -: 1991:      case CFE_SB_PEND_FOREVER:
        9: 1992:          TimeOut = OS_PEND;
        9: 1993:          break;
        -: 1994:
        -: 1995:      case CFE_SB_POLL:
      186: 1996:          TimeOut = OS_CHECK;
      186: 1997:          break;
        -: 1998:
        -: 1999:      default:
        1: 2000:          TimeOut = Time_Out;
        -: 2001:          break;
        -: 2002:
        -: 2003:    }/* end switch */
        -: 2004:
        -: 2005:    /* Read the buffer descriptor address from the queue.  */
      196: 2006:    Status = OS_QueueGet(PipeDscPtr->SysQueueId,
        -: 2007:                        (void *)Message,
        -: 2008:                        sizeof(CFE_SB_BufferD_t *),
        -: 2009:                        &Nbytes,
        -: 2010:                        TimeOut);
        -: 2011:
        -: 2012:    /* translate the return value */
      196: 2013:    switch(Status){
        -: 2014:
        -: 2015:      case OS_SUCCESS:
       15: 2016:          Status = CFE_SUCCESS;
       15: 2017:          break;
        -: 2018:
        -: 2019:      case OS_QUEUE_EMPTY:
      178: 2020:          Status = CFE_SB_NO_MESSAGE;
      178: 2021:          break;
        -: 2022:
        -: 2023:      case OS_QUEUE_TIMEOUT:
        1: 2024:          Status = CFE_SB_TIME_OUT;
        1: 2025:          break;
        -: 2026:
        -: 2027:      default:
        2: 2028:          CFE_SB_LockSharedData(__func__,__LINE__);
        2: 2029:          CFE_SB.HKTlmMsg.Payload.InternalErrCnt++;
        2: 2030:          CFE_SB_UnlockSharedData(__func__,__LINE__);
        -: 2031:          /* Unexpected error while reading the queue. */
        2: 2032:          CFE_EVS_SendEventWithAppID(CFE_SB_Q_RD_ERR_EID,CFE_EVS_ERROR,CFE_SB.AppId,
        -: 2033:              "Pipe Read Err,pipe %s,app %s,stat 0x%x",
        -: 2034:              CFE_SB_GetPipeName(PipeDscPtr->PipeId),CFE_SB_GetAppTskName(TskId,FullName),(unsigned int)Status);
        -: 2035:
        2: 2036:          Status = CFE_SB_PIPE_RD_ERR;
        -: 2037:          break;
        -: 2038:
        -: 2039:    }/* end switch */
        -: 2040:
      196: 2041:    return (Status);
        -: 2042:}/* end CFE_SB_ReadQueue */
        -: 2043:
        -: 2044:/*****************************************************************************/
        -: 2045:
