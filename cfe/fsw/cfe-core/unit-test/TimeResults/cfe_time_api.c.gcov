        -:    0:Source:/mnt/hgfs/Proj/CFS/Builds/Trunk/Mission/cfe/fsw/cfe-core/src/time/cfe_time_api.c
        -:    0:Graph:cfe_time_api.gcno
        -:    0:Data:cfe_time_api.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:** $Id: cfe_time_api.c.gcov 1.2 2008/08/06 22:43:51EDT dkobe Exp  $
        -:    3:**
        -:    4:**
        -:    5:**      Copyright © 2004-2006, United States government as represented by the 
        -:    6:**      administrator of the National Aeronautics Space Administration.  
        -:    7:**      All rights reserved. This software(cFE) was created at NASA’s Goddard 
        -:    8:**      Space Flight Center pursuant to government contracts.
        -:    9:**
        -:   10:**      This software may be used only pursuant to a United States government 
        -:   11:**      sponsored project and the United States government may not be charged
        -:   12:**      for use thereof. 
        -:   13:**
        -:   14:**
        -:   15:** Purpose:  cFE Time Services (TIME) library API source file
        -:   16:**
        -:   17:** Author:   S.Walling/Microtel
        -:   18:**
        -:   19:** Notes:    Partially derived from SDO source code
        -:   20:**
        -:   21:** $Log: cfe_time_api.c.gcov  $
        -:   21:** Revision 1.2 2008/08/06 22:43:51EDT dkobe 
        -:   21:** Updated Unit Tests for CFE_TIME_RegisterSynchCallback, CFE_TIME_UnregisterSynchCallback and CFE_TIME_CleanUpApp
        -:   22:** Revision 1.1 2008/04/17 08:05:38EDT ruperera 
        -:   23:** Initial revision
        -:   24:** Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/src/time/project.pj
        -:   25:** Revision 1.9 2007/03/07 10:54:24EST njyanchik 
        -:   26:** I added a IsToneGood bit to the information that CFE_TIME_GetClockInfo function returns. The decison on a 'good' tone is made in the 1Hz ISR. If the tone is about
        -:   27:** 1 second after the previous one, it is still considered good, otherwise, the tone is not good.
        -:   28:** Revision 1.8 2007/03/07 10:43:47EST njyanchik 
        -:   29:** I made a new API called CFE_TIME_GetClockInfo that is functionally equivilant to CFE_TIME_GetStateFlags. The reason I made a new function is because this function
        -:   30:** will get changed in a future DCR (3191).
        -:   31:** Revision 1.7 2006/07/28 10:17:12EDT njyanchik 
        -:   32:** Fix of LDRA errors
        -:   33:** Revision 1.6 2006/06/08 14:15:50EDT njyanchik 
        -:   34:** I added the appropriate legal headers to all of the time files
        -:   35:** Revision 1.5 2006/05/18 13:34:22EDT njyanchik 
        -:   36:** The conversions between microsecs and sub secs left 999999 us as 0xFFFFE000 subseconds,
        -:   37:** when 0xFFFFF000 is expected, causing the additions in the frequency to be off. Tthis change
        -:   38:** adds an extra factor that bumps the output so that 999999 meets 0xFFFFF000.
        -:   39:** Revision 1.4 2006/05/04 09:29:02EDT njyanchik 
        -:   40:** Added MET to default spacecraft time conversion
        -:   41:** API is CFE_TIME_SysTime_t CFE_TIME_MET2SCTime (CFE_TIME_SysTime_t METTime)
        -:   42:** Revision 1.3 2006/01/27 07:51:19EST njyanchik 
        -:   43:** modified CFE_TIME_Sub2MicroSecs to stop drift. If the Subseconds % 0x4000000 != 0 then we
        -:   44:**  will need to add 1 to the result. This will prevent the drift. Also, added in a check that prevents
        -:   45:** the number of microseconds from ever getting to 1000000.
        -:   46:** Revision 1.2 2005/07/21 15:28:30EDT lswalling 
        -:   47:** Add Time print API function
        -:   48:** Revision 1.1 2005/06/09 10:57:56EDT rperera 
        -:   49:** Initial revision
        -:   50:** Member added to project d:/mksdata/MKS-CFE-REPOSITORY/cfe-core/time/project.pj
        -:   51:*/
        -:   52:
        -:   53:
        -:   54:/*
        -:   55:** Required header files...
        -:   56:*/
        -:   57:#include "cfe_time_utils.h"
        -:   58:extern CFE_TIME_TaskData_t CFE_TIME_TaskData;
        -:   59:
        -:   60:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   61:/*                                                                         */
        -:   62:/* CFE_TIME_GetTime() -- get time in default format (TAI vs UTC)           */
        -:   63:/*                                                                         */
        -:   64:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   65:
        -:   66:CFE_TIME_SysTime_t   CFE_TIME_GetTime(void)
        1:   67:{
        -:   68:    CFE_TIME_SysTime_t CurrentTime;
        -:   69:
        -:   70:#ifdef CFE_TIME_CFG_DEFAULT_TAI
        -:   71:
        1:   72:    CurrentTime = CFE_TIME_GetTAI();
        -:   73:
        -:   74:#else
        -:   75:
        -:   76:    CurrentTime = CFE_TIME_GetUTC();
        -:   77:
        -:   78:#endif
        -:   79:
        1:   80:    return(CurrentTime);
        -:   81:
        -:   82:} /* End of CFE_TIME_GetTime() */
        -:   83:
        -:   84:
        -:   85:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   86:/*                                                                         */
        -:   87:/* CFE_TIME_GetTAI() -- get time in TAI format (TAI vs UTC)                */
        -:   88:/*                                                                         */
        -:   89:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   90:
        -:   91:CFE_TIME_SysTime_t   CFE_TIME_GetTAI(void)
        2:   92:{
        -:   93:    CFE_TIME_Reference_t Reference;
        -:   94:    CFE_TIME_SysTime_t tai;
        -:   95:
        -:   96:    /* Zero out the Reference variable because we pass it into
        -:   97:     * a function before using it
        -:   98:     * */
        2:   99:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  100:    
        -:  101:    /*
        -:  102:    ** Get reference time values (local time, time at tone, etc.)...
        -:  103:    */
        2:  104:    CFE_TIME_GetReference(&Reference);
        -:  105:
        -:  106:    /*
        -:  107:    ** Calculate current TAI...
        -:  108:    */
        2:  109:    tai = CFE_TIME_CalculateTAI(&Reference);
        -:  110:
        2:  111:    return(tai);
        -:  112:
        -:  113:} /* End of CFE_TIME_GetTAI() */
        -:  114:
        -:  115:
        -:  116:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  117:/*                                                                         */
        -:  118:/* CFE_TIME_GetUTC() -- get time in UTC format (TAI vs UTC)                */
        -:  119:/*                                                                         */
        -:  120:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  121:
        -:  122:CFE_TIME_SysTime_t   CFE_TIME_GetUTC(void)
        1:  123:{
        -:  124:    CFE_TIME_Reference_t Reference;
        -:  125:    CFE_TIME_SysTime_t utc;
        -:  126:
        -:  127:    /* Zero out the Reference variable because we pass it into
        -:  128:     * a function before using it
        -:  129:     * */
        1:  130:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  131:    /*
        -:  132:    ** Get reference time values (local time, time at tone, etc.)...
        -:  133:    */
        1:  134:    CFE_TIME_GetReference(&Reference);
        -:  135:
        -:  136:    /*
        -:  137:    ** Calculate current UTC...
        -:  138:    */
        1:  139:    utc = CFE_TIME_CalculateUTC(&Reference);
        -:  140:
        1:  141:    return(utc);
        -:  142:
        -:  143:} /* End of CFE_TIME_GetUTC() */
        -:  144:
        -:  145:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  146:/*                                                                         */
        -:  147:/* CFE_TIME_METtoSCTime() -- convert MET Time to default spacecraft time   */
        -:  148:/*                                                                         */
        -:  149:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  150:
        -:  151:CFE_TIME_SysTime_t CFE_TIME_MET2SCTime (CFE_TIME_SysTime_t METTime)
        1:  152:{
        -:  153:
        -:  154:    CFE_TIME_SysTime_t STCF;
        -:  155:    CFE_TIME_SysTime_t TIATime;
        -:  156:    CFE_TIME_SysTime_t UTCTime;
        -:  157:    CFE_TIME_SysTime_t ReturnTime;
        -:  158:    CFE_TIME_SysTime_t LeapSecsAsSysTime;
        -:  159:    int16              LeapSeconds;
        -:  160:    
        1:  161:    STCF = CFE_TIME_GetSTCF();
        -:  162:
        -:  163:    /* TIA = MET + STCF */
        1:  164:    TIATime = CFE_TIME_Add(METTime, STCF);
        -:  165:
        1:  166:    LeapSeconds = CFE_TIME_GetLeapSeconds();
        -:  167:
        -:  168:    /* Put leap seconds in correct format */
        1:  169:    LeapSecsAsSysTime.Seconds       = LeapSeconds;
        1:  170:    LeapSecsAsSysTime.Subseconds    = 0;
        -:  171:    
        -:  172:    /* UTC Time = TIA Time - Leap Seconds */
        1:  173:    UTCTime = CFE_TIME_Subtract(TIATime, LeapSecsAsSysTime);
        -:  174:
        -:  175:
        -:  176:#ifdef CFE_TIME_CFG_DEFAULT_TAI
        -:  177:
        1:  178:    ReturnTime = TIATime;
        -:  179:
        -:  180:#else
        -:  181:    ReturnTime = UTCTime;
        -:  182:
        -:  183:#endif
        -:  184:
        1:  185:    return (ReturnTime);
        -:  186:}/* end CFE_TIME_MET2SCTime() */
        -:  187:
        -:  188:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  189:/*                                                                         */
        -:  190:/* CFE_TIME_GetClockState() -- get time data (status)                      */
        -:  191:/*                                                                         */
        -:  192:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  193:
        -:  194:CFE_TIME_ClockState_t   CFE_TIME_GetClockState(void)
        1:  195:{
        -:  196:    CFE_TIME_Reference_t Reference;
        -:  197:    CFE_TIME_ClockState_t state;
        -:  198:    
        -:  199:    /* Zero out the Reference variable because we pass it into
        -:  200:     * a function before using it
        -:  201:     * */
        1:  202:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  203:    /*
        -:  204:    ** Get reference time values (local time, time at tone, etc.)...
        -:  205:    */
        1:  206:    CFE_TIME_GetReference(&Reference);
        -:  207:
        -:  208:    /*
        -:  209:    ** Determine the current clock state...
        -:  210:    */
        1:  211:    state = (CFE_TIME_ClockState_t) CFE_TIME_CalculateState(&Reference);
        -:  212:
        1:  213:    return(state);
        -:  214:
        -:  215:} /* End of CFE_TIME_GetClockState() */
        -:  216:
        -:  217:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  218:/*                                                                 */
        -:  219:/* CFE_TIME_GetClockInfo() -- Convert state data to flag values    */
        -:  220:/*                                                                 */
        -:  221:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  222:
        -:  223:uint16 CFE_TIME_GetClockInfo(void)
        1:  224:{
        1:  225:    uint16 StateFlags = 0;
        -:  226:
        -:  227:    /*
        -:  228:    ** Spacecraft time has been set...
        -:  229:    */
        1:  230:    if (CFE_TIME_TaskData.ClockSetState == CFE_TIME_WAS_SET)
        -:  231:    {
        1:  232:        StateFlags |= CFE_TIME_FLAG_CLKSET;
        -:  233:    }
        -:  234:    /*
        -:  235:    ** This instance of Time Service is in FLYWHEEL mode...
        -:  236:    */
        1:  237:    if (CFE_TIME_TaskData.ClockFlyState == CFE_TIME_IS_FLY)
        -:  238:    {
        1:  239:        StateFlags |= CFE_TIME_FLAG_FLYING;
        -:  240:    }
        -:  241:    /*
        -:  242:    ** Clock source set to "internal"...
        -:  243:    */
        1:  244:    if (CFE_TIME_TaskData.ClockSource == CFE_TIME_USE_INTERN)
        -:  245:    {
        1:  246:        StateFlags |= CFE_TIME_FLAG_SRCINT;
        -:  247:    }
        -:  248:    /*
        -:  249:    ** Clock signal set to "primary"...
        -:  250:    */
        1:  251:    if (CFE_TIME_TaskData.ClockSignal == CFE_TIME_TONE_PRI)
        -:  252:    {
        1:  253:        StateFlags |= CFE_TIME_FLAG_SIGPRI;
        -:  254:    }
        -:  255:    /*
        -:  256:    ** Time Server is in FLYWHEEL mode...
        -:  257:    */
        1:  258:    if (CFE_TIME_TaskData.ServerFlyState == CFE_TIME_IS_FLY)
        -:  259:    {
        1:  260:        StateFlags |= CFE_TIME_FLAG_SRVFLY;
        -:  261:    }
        -:  262:    /*
        -:  263:    ** This instance of Time Services commanded into FLYWHEEL...
        -:  264:    */
        1:  265:    if (CFE_TIME_TaskData.Forced2Fly)
        -:  266:    {
        1:  267:        StateFlags |= CFE_TIME_FLAG_CMDFLY;
        -:  268:    }
        -:  269:    /*
        -:  270:    ** One time STCF adjustment direction...
        -:  271:    */
        1:  272:    if (CFE_TIME_TaskData.OneTimeDirection == CFE_TIME_ADD_ADJUST)
        -:  273:    {
        1:  274:        StateFlags |= CFE_TIME_FLAG_ADDADJ;
        -:  275:    }
        -:  276:    /*
        -:  277:    ** 1 Hz STCF adjustment direction...
        -:  278:    */
        1:  279:    if (CFE_TIME_TaskData.OneHzDirection == CFE_TIME_ADD_ADJUST)
        -:  280:    {
        1:  281:        StateFlags |= CFE_TIME_FLAG_ADD1HZ;
        -:  282:    }
        -:  283:    /*
        -:  284:    ** Time Client Latency adjustment direction...
        -:  285:    */
        1:  286:    if (CFE_TIME_TaskData.DelayDirection == CFE_TIME_ADD_ADJUST)
        -:  287:    {
        1:  288:        StateFlags |= CFE_TIME_FLAG_ADDTCL;
        -:  289:    }
        -:  290:    /*
        -:  291:    ** This instance of Time Service is a "server"...
        -:  292:    */
        -:  293:    #ifdef CFE_TIME_CFG_SERVER
        1:  294:    StateFlags |= CFE_TIME_FLAG_SERVER;
        -:  295:    #endif
        -:  296:
        -:  297:    /* 
        -:  298:    ** The tone is good 
        -:  299:    */
        1:  300:    if (CFE_TIME_TaskData.IsToneGood == TRUE)
        -:  301:    {
        1:  302:        StateFlags |= CFE_TIME_FLAG_GDTONE;
        -:  303:    }   
        -:  304:
        1:  305:    return(StateFlags);
        -:  306:
        -:  307:} /* End of CFE_TIME_GetClockInfo() */
        -:  308:
        -:  309:
        -:  310:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  311:/*                                                                         */
        -:  312:/* CFE_TIME_GetLeapSeconds() -- get time data (leap seconds)               */
        -:  313:/*                                                                         */
        -:  314:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  315:
        -:  316:int16   CFE_TIME_GetLeapSeconds(void)
        2:  317:{
        -:  318:    CFE_TIME_Reference_t Reference;
        -:  319:
        -:  320:    /* Zero out the Reference variable because we pass it into
        -:  321:     * a function before using it
        -:  322:     * */
        2:  323:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  324:
        -:  325:    /*
        -:  326:    ** Get reference time values (local time, time at tone, etc.)...
        -:  327:    */
        2:  328:    CFE_TIME_GetReference(&Reference);
        -:  329:
        2:  330:    return(Reference.AtToneLeaps);
        -:  331:
        -:  332:} /* End of CFE_TIME_GetLeapSeconds() */
        -:  333:
        -:  334:
        -:  335:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  336:/*                                                                         */
        -:  337:/* CFE_TIME_GetSTCF() -- get time data (Spacecraft Time Correlation Factor)*/
        -:  338:/*                                                                         */
        -:  339:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  340:
        -:  341:CFE_TIME_SysTime_t   CFE_TIME_GetSTCF(void)
        2:  342:{
        -:  343:    CFE_TIME_Reference_t Reference;
        -:  344:    
        -:  345:    /* Zero out the Reference variable because we pass it into
        -:  346:     * a function before using it
        -:  347:     * */
        2:  348:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  349:    
        -:  350:    /*
        -:  351:    ** Get reference time values (local time, time at tone, etc.)...
        -:  352:    */
        2:  353:    CFE_TIME_GetReference(&Reference);
        -:  354:
        2:  355:    return(Reference.AtToneSTCF);
        -:  356:
        -:  357:} /* End of CFE_TIME_GetSTCF() */
        -:  358:
        -:  359:
        -:  360:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  361:/*                                                                         */
        -:  362:/* CFE_TIME_GetMET() -- get time data (Mission Elapsed Timer)              */
        -:  363:/*                                                                         */
        -:  364:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  365:
        -:  366:CFE_TIME_SysTime_t   CFE_TIME_GetMET(void)
        1:  367:{
        -:  368:    CFE_TIME_Reference_t Reference;
        -:  369:    
        -:  370:     /* Zero out the Reference variable because we pass it into
        -:  371:     * a function before using it
        -:  372:     */
        1:  373:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  374:
        -:  375:
        -:  376:    /*
        -:  377:    ** Get reference time values (local time, time at tone, etc.)...
        -:  378:    */
        1:  379:    CFE_TIME_GetReference(&Reference);
        -:  380:
        1:  381:    return(Reference.CurrentMET);
        -:  382:
        -:  383:} /* End of CFE_TIME_GetMET() */
        -:  384:
        -:  385:
        -:  386:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  387:/*                                                                         */
        -:  388:/* CFE_TIME_GetMETseconds() -- get time data (seconds portion of MET)      */
        -:  389:/*                                                                         */
        -:  390:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  391:
        -:  392:uint32   CFE_TIME_GetMETseconds(void)
        1:  393:{
        -:  394:    CFE_TIME_Reference_t Reference;
        -:  395:
        -:  396:    /* Zero out the Reference variable because we pass it into
        -:  397:     * a function before using it
        -:  398:     * */
        1:  399:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  400:
        -:  401:    
        -:  402:    /*
        -:  403:    ** Get reference time values (local time, time at tone, etc.)...
        -:  404:    */
        1:  405:    CFE_TIME_GetReference(&Reference);
        -:  406:
        1:  407:    return(Reference.CurrentMET.Seconds);
        -:  408:
        -:  409:} /* End of CFE_TIME_GetMETseconds() */
        -:  410:
        -:  411:
        -:  412:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  413:/*                                                                         */
        -:  414:/* CFE_TIME_GetMETsubsecs() -- get time data (sub-seconds portion of MET)  */
        -:  415:/*                                                                         */
        -:  416:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  417:
        -:  418:uint32   CFE_TIME_GetMETsubsecs(void)
        1:  419:{
        -:  420:    CFE_TIME_Reference_t Reference;
        -:  421:
        -:  422:    /* Zero out the Reference variable because we pass it into
        -:  423:     * a function before using it
        -:  424:     * */
        1:  425:    OS_MemSet(&Reference, 0 , sizeof(CFE_TIME_Reference_t));
        -:  426:    
        -:  427:    /*
        -:  428:    ** Get reference time values (local time, time at tone, etc.)...
        -:  429:    */
        1:  430:    CFE_TIME_GetReference(&Reference);
        -:  431:
        1:  432:    return(Reference.CurrentMET.Subseconds);
        -:  433:
        -:  434:} /* End of CFE_TIME_GetMETsubsecs() */
        -:  435:
        -:  436:
        -:  437:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  438:/*                                                                         */
        -:  439:/* CFE_TIME_Add() -- add two CFE_TIME_SysTime_t values                     */
        -:  440:/*                                                                         */
        -:  441:/*   result = time1 + time2                                                */
        -:  442:/*                                                                         */
        -:  443:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  444:
        -:  445:CFE_TIME_SysTime_t  CFE_TIME_Add(CFE_TIME_SysTime_t Time1, CFE_TIME_SysTime_t Time2)
       42:  446:{
        -:  447:    CFE_TIME_SysTime_t Result;
        -:  448:
       42:  449:    Result.Subseconds = Time1.Subseconds + Time2.Subseconds;
        -:  450:
        -:  451:    /*
        -:  452:    ** Check for sub-seconds roll-over
        -:  453:    */
       42:  454:    if (Result.Subseconds < Time1.Subseconds)
        -:  455:    {
        2:  456:        Result.Seconds = (Time1.Seconds + Time2.Seconds) + 1;
        -:  457:    }
        -:  458:    else
        -:  459:    {
       40:  460:        Result.Seconds = Time1.Seconds + Time2.Seconds;
        -:  461:    }
        -:  462:
       42:  463:    return(Result);
        -:  464:
        -:  465:} /* End of CFE_TIME_Add() */
        -:  466:
        -:  467:
        -:  468:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  469:/*                                                                         */
        -:  470:/* CFE_TIME_Subtract() -- subtract a CFE_TIME_SysTime_t value from another */
        -:  471:/*                                                                         */
        -:  472:/*   result = time1 - time2                                                */
        -:  473:/*                                                                         */
        -:  474:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  475:
        -:  476:CFE_TIME_SysTime_t  CFE_TIME_Subtract(CFE_TIME_SysTime_t Time1, CFE_TIME_SysTime_t Time2)
       56:  477:{
        -:  478:    CFE_TIME_SysTime_t Result;
        -:  479:
       56:  480:    Result.Subseconds = Time1.Subseconds - Time2.Subseconds;
        -:  481:
       56:  482:    if (Result.Subseconds > Time1.Subseconds)
        -:  483:    {
        3:  484:        Result.Seconds = (Time1.Seconds - Time2.Seconds) - 1;
        -:  485:    }
        -:  486:    else
        -:  487:    {
       53:  488:        Result.Seconds = Time1.Seconds - Time2.Seconds;
        -:  489:    }
        -:  490:
       56:  491:    return(Result);
        -:  492:
        -:  493:} /* End of CFE_TIME_Subtract() */
        -:  494:
        -:  495:
        -:  496:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  497:/*                                                                         */
        -:  498:/* CFE_TIME_Compare() -- compare two CFE_TIME_SysTime_t values             */
        -:  499:/*                                                                         */
        -:  500:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  501:
        -:  502:CFE_TIME_Compare_t  CFE_TIME_Compare(CFE_TIME_SysTime_t TimeA, CFE_TIME_SysTime_t TimeB)
       50:  503:{
        -:  504:    CFE_TIME_Compare_t Result;
        -:  505:
       50:  506:    if (TimeA.Seconds > TimeB.Seconds)
        -:  507:    {
        -:  508:        /*
        -:  509:        ** Assume rollover if difference is too large...
        -:  510:        */
        6:  511:        if ((TimeA.Seconds - TimeB.Seconds) > CFE_TIME_NEGATIVE)
        -:  512:        {
        1:  513:            Result = CFE_TIME_A_LT_B;
        -:  514:        }
        -:  515:        else
        -:  516:        {
        5:  517:            Result = CFE_TIME_A_GT_B;
        -:  518:        }
        -:  519:    }
       44:  520:    else if (TimeA.Seconds < TimeB.Seconds)
        -:  521:    {
        -:  522:        /*
        -:  523:        ** Assume rollover if difference is too large...
        -:  524:        */
        6:  525:        if ((TimeB.Seconds - TimeA.Seconds) > CFE_TIME_NEGATIVE)
        -:  526:        {
        1:  527:            Result = CFE_TIME_A_GT_B;
        -:  528:        }
        -:  529:        else
        -:  530:        {
        5:  531:            Result = CFE_TIME_A_LT_B;
        -:  532:        }
        -:  533:    }
        -:  534:    else
        -:  535:    {
        -:  536:        /*
        -:  537:        ** Seconds are equal, check sub-seconds
        -:  538:        */
       38:  539:        if (TimeA.Subseconds > TimeB.Subseconds)
        -:  540:        {
        1:  541:            Result = CFE_TIME_A_GT_B;
        -:  542:        }
       37:  543:        else if (TimeA.Subseconds < TimeB.Subseconds)
        -:  544:        {
        1:  545:            Result = CFE_TIME_A_LT_B;
        -:  546:        }
        -:  547:        else
        -:  548:        {
       36:  549:            Result = CFE_TIME_EQUAL;
        -:  550:        }
        -:  551:    }
        -:  552:
       50:  553:    return(Result);
        -:  554:
        -:  555:} /* End of CFE_TIME_Compare() */
        -:  556:
        -:  557:
        -:  558:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  559:/*                                                                         */
        -:  560:/* CFE_TIME_Sub2MicroSecs() -- convert sub-seconds to micro-seconds        */
        -:  561:/*                                                                         */
        -:  562:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  563:
        -:  564:uint32  CFE_TIME_Sub2MicroSecs(uint32 SubSeconds)
       15:  565:{
        -:  566:    uint32 MicroSeconds;
        -:  567:	
        -:  568:    /* 0xffffdf00 subseconds = 999999 microseconds, so anything greater 
        -:  569:     * than that we set to 999999 microseconds, so it doesn't get to
        -:  570:     * a million microseconds */
        -:  571:    
       15:  572:	if (SubSeconds > 0xffffdf00)
        -:  573:	{
        2:  574:			MicroSeconds = 999999;
        -:  575:	}
        -:  576:    else
        -:  577:    {
        -:  578:        /*
        -:  579:        **  Convert a 1/2^32 clock tick count to a microseconds count
        -:  580:        **
        -:  581:        **  Conversion factor is  ( ( 2 ** -32 ) / ( 10 ** -6 ) ).
        -:  582:        **
        -:  583:        **  Logic is as follows:
        -:  584:        **    x * ( ( 2 ** -32 ) / ( 10 ** -6 ) )
        -:  585:        **  = x * ( ( 10 ** 6  ) / (  2 ** 32 ) )
        -:  586:        **  = x * ( ( 5 ** 6 ) ( 2 ** 6 ) / ( 2 ** 26 ) ( 2 ** 6) )
        -:  587:        **  = x * ( ( 5 ** 6 ) / ( 2 ** 26 ) )
        -:  588:        **  = x * ( ( 5 ** 3 ) ( 5 ** 3 ) / ( 2 ** 7 ) ( 2 ** 7 ) (2 ** 12) )
        -:  589:        **
        -:  590:        **  C code equivalent:
        -:  591:        **  = ( ( ( ( ( x >> 7) * 125) >> 7) * 125) >> 12 )
        -:  592:        */   
        -:  593:
       13:  594:    	MicroSeconds = (((((SubSeconds >> 7) * 125) >> 7) * 125) >> 12);
        -:  595:    
        -:  596:
        -:  597:        /* if the Subseconds % 0x4000000 != 0 then we will need to
        -:  598:         * add 1 to the result. the & is a faster way of doing the % */  
       13:  599:	    if ((SubSeconds & 0x3ffffff) != 0)
        -:  600:    	{
        3:  601:	    	MicroSeconds++;
        -:  602:    	}
        -:  603:    
        -:  604:        /* In the Micro2SubSecs conversion, we added an extra anomaly
        -:  605:         * to get the subseconds to bump up against the end point,
        -:  606:         * 0xFFFFF000. This must be accounted for here. Since we bumped
        -:  607:         * at the half way mark, we must "unbump" at the same mark 
        -:  608:         */
       13:  609:        if (MicroSeconds > 500000)
        -:  610:        {
        1:  611:            MicroSeconds --;
        -:  612:        }
        -:  613:        
        -:  614:    } /* end else */
        -:  615:    
       15:  616:    return(MicroSeconds);
        -:  617:
        -:  618:} /* End of CFE_TIME_Sub2MicroSecs() */
        -:  619:
        -:  620:
        -:  621:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  622:/*                                                                         */
        -:  623:/* CFE_TIME_Micro2SubSecs() -- convert micro-seconds to sub-seconds        */
        -:  624:/*                                                                         */
        -:  625:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  626:
        -:  627:uint32  CFE_TIME_Micro2SubSecs(uint32 MicroSeconds)
       69:  628:{
        -:  629:    uint32 SubSeconds;
        -:  630:
        -:  631:    /*
        -:  632:    ** Conversion amount must be less than one second
        -:  633:    */
       69:  634:    if (MicroSeconds > 999999)
        -:  635:    {
        1:  636:        SubSeconds = 0xFFFFFFFF;
        -:  637:    }
        -:  638:    else
        -:  639:    {
        -:  640:    /*
        -:  641:    **  Convert micro-seconds count to sub-seconds (1/2^32) count
        -:  642:    **
        -:  643:    **  Conversion factor is  ( ( 10 ** -6 ) / ( 2 ** -20 ).
        -:  644:    **
        -:  645:    **  Logic is as follows:
        -:  646:    **    x * ( ( 10 ** -6 ) / ( 2 ** -32 ) )
        -:  647:    **  = x * ( ( 2 ** 32 ) / ( 10 ** 6 ) )
        -:  648:    **  = x * ( ( ( 2 ** 26 ) ( 2 ** 6) ) / ( ( 5 ** 6 ) ( 2 ** 6 ) ) )
        -:  649:    **  = x * ( ( 2 ** 26 ) / ( 5 ** 6 ) )
        -:  650:    **  = x * ( ( ( 2 ** 11) ( 2 ** 3) (2 ** 12) ) / ( 5( 5 ** 5 ) ) )
        -:  651:    **  = x * ( ( ( ( ( 2 ** 11 ) / 5 ) * ( 2 ** 3 ) ) / ( 5 ** 5 ) ) * (2 ** 12) )
        -:  652:    **
        -:  653:    **  C code equivalent:
        -:  654:    **  = ( ( ( ( ( x << 11 ) / 5 ) << 3 ) / 3125 ) << 12 )
        -:  655:    **
        -:  656:    **  Conversion factor was reduced and factored accordingly
        -:  657:    **  to minimize precision loss and register overflow.
        -:  658:    */
       68:  659:        SubSeconds = ( ( ( ( MicroSeconds << 11 ) / 5 ) << 3 ) / 3125 ) << 12;
        -:  660:
        -:  661:        /* To get the SubSeconds to "bump up" against 0xFFFFF000 when 
        -:  662:         * MicroSeconds = 9999999, we add in another anomaly to the 
        -:  663:         * conversion at the half-way point  (500000 us). This will bump
        -:  664:         * all of the subseconds up by 0x1000, so 999999 us == 0xFFFFF00,
        -:  665:         * 999998 == 0xFFFFE000, etc. This extra anomaly is accounted for
        -:  666:         * in the Sub2MicroSecs conversion as well.
        -:  667:         */
        -:  668:        
       68:  669:        if (SubSeconds > 0x80001000)
        -:  670:        {
        3:  671:           SubSeconds += 0x1000;
        -:  672:        }
        -:  673:
        -:  674:    }
        -:  675:
       69:  676:    return(SubSeconds);
        -:  677:
        -:  678:} /* End of CFE_TIME_Micro2SubSecs() */
        -:  679:
        -:  680:
        -:  681:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  682:/*                                                                         */
        -:  683:/* CFE_TIME_CFE2FSSeconds() --  convert cFE seconds to file system seconds */
        -:  684:/*                                                                         */
        -:  685:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  686:
        -:  687:uint32 CFE_TIME_CFE2FSSeconds(uint32 SecondsCFE)
        3:  688:{
        -:  689:    /*
        -:  690:    ** Using a signed integer allows the factor to be negative...
        -:  691:    */
        3:  692:    int32 ConvertFactor = CFE_TIME_FS_FACTOR;
        -:  693:
        -:  694:    /*
        -:  695:    ** File system time = cFE time + conversion factor...
        -:  696:    */
        3:  697:    uint32 SecondsFS = SecondsCFE + (uint32) ConvertFactor;
        -:  698:
        -:  699:    /*
        -:  700:    ** Prevent file system time from going below zero...
        -:  701:    */
        3:  702:    if (ConvertFactor < 0)
        -:  703:    {
    #####:  704:        if (-ConvertFactor > SecondsCFE)
        -:  705:        {
    #####:  706:            SecondsFS = 0;
        -:  707:        }
        -:  708:    }
        -:  709:
        3:  710:    return(SecondsFS);
        -:  711:
        -:  712:} /* End of CFE_TIME_CFE2FSSeconds() */
        -:  713:
        -:  714:
        -:  715:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  716:/*                                                                         */
        -:  717:/* CFE_TIME_FS2CFESeconds() --  convert file system seconds to cFE seconds */
        -:  718:/*                                                                         */
        -:  719:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  720:
        -:  721:uint32 CFE_TIME_FS2CFESeconds(uint32 SecondsFS)
        4:  722:{
        -:  723:    /*
        -:  724:    ** Using a signed integer allows the factor to be negative...
        -:  725:    */
        4:  726:    int32 ConvertFactor = CFE_TIME_FS_FACTOR;
        -:  727:
        -:  728:    /*
        -:  729:    ** cFE time = file system time - conversion factor...
        -:  730:    */
        4:  731:    uint32 SecondsCFE = SecondsFS - (uint32) ConvertFactor;
        -:  732:
        -:  733:    /*
        -:  734:    ** Prevent cFE time from going below zero...
        -:  735:    */
        4:  736:    if (ConvertFactor > SecondsFS)
        -:  737:    {
        2:  738:        SecondsCFE = 0;
        -:  739:    }
        -:  740:
        4:  741:    return(SecondsCFE);
        -:  742:
        -:  743:} /* End of CFE_TIME_FS2CFESeconds() */
        -:  744:
        -:  745:
        -:  746:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  747:/*                                                                         */
        -:  748:/* CFE_TIME_Print() --  create text string representing date and time      */
        -:  749:/*                                                                         */
        -:  750:/* Notes:                                                                  */
        -:  751:/*                                                                         */
        -:  752:/*  1) The value of the time argument is simply added to the configuration */
        -:  753:/*     definitions for the ground epoch and converted into a fixed length  */
        -:  754:/*     string in the buffer provided by the caller.                        */
        -:  755:/*                                                                         */
        -:  756:/*  2) A loss of data during the string conversion will occur if the       */
        -:  757:/*     computed year exceeds 9999.  However, a year that large would       */
        -:  758:/*     require an unrealistic definition for the ground epoch since        */
        -:  759:/*     the maximum amount of time represented by a CFE_TIME_SysTime        */
        -:  760:/*     structure is approximately 136 years.                               */
        -:  761:/*                                                                         */
        -:  762:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  763:
        -:  764:void CFE_TIME_Print(char *PrintBuffer, CFE_TIME_SysTime_t TimeToPrint)
       10:  765:{
        -:  766:    uint32 NumberOfYears;
        -:  767:    uint32 NumberOfDays;
        -:  768:    uint32 NumberOfHours;
        -:  769:    uint32 NumberOfMinutes;
        -:  770:    uint32 NumberOfSeconds;
        -:  771:    uint32 NumberOfMicros;
        -:  772:    uint32 DaysInThisYear;
        -:  773:
       10:  774:    boolean StillCountingYears = TRUE;
        -:  775:
        -:  776:    /*
        -:  777:    ** Convert the cFE time (offset from epoch) into calendar time...
        -:  778:    */
       10:  779:    NumberOfMinutes = (TimeToPrint.Seconds / 60) + CFE_TIME_EPOCH_MINUTE;
       10:  780:    NumberOfSeconds = (TimeToPrint.Seconds % 60) + CFE_TIME_EPOCH_SECOND;
        -:  781:
        -:  782:    /*
        -:  783:    ** Adding the epoch "seconds" after computing the minutes avoids
        -:  784:    **    overflow problems when the input time value (seconds) is
        -:  785:    **    at, or near, 0xFFFFFFFF...
        -:  786:    */
       20:  787:    while (NumberOfSeconds >= 60)
        -:  788:    {
    #####:  789:        NumberOfMinutes++;
    #####:  790:        NumberOfSeconds -= 60;
        -:  791:    }
        -:  792:
        -:  793:    /*
        -:  794:    ** Compute the years/days/hours/minutes...
        -:  795:    */
       10:  796:    NumberOfHours   = (NumberOfMinutes / 60) + CFE_TIME_EPOCH_HOUR;
       10:  797:    NumberOfMinutes = (NumberOfMinutes % 60);
        -:  798:
        -:  799:    /*
        -:  800:    ** Unlike hours and minutes, epoch days are counted as Jan 1 = day 1...
        -:  801:    */
       10:  802:    NumberOfDays  = (NumberOfHours / 24) + (CFE_TIME_EPOCH_DAY - 1);
       10:  803:    NumberOfHours = (NumberOfHours % 24);
        -:  804:
       10:  805:    NumberOfYears = CFE_TIME_EPOCH_YEAR;
        -:  806:
        -:  807:    /*
        -:  808:    ** Convert total number of days into years and remainder days...
        -:  809:    */
      194:  810:    while (StillCountingYears)
        -:  811:    {
        -:  812:        /*
        -:  813:        ** Set number of days in this year (leap year?)...
        -:  814:        */
      174:  815:        DaysInThisYear = 365;
        -:  816:
      174:  817:        if ((NumberOfYears % 4) == 0)
        -:  818:        {
       51:  819:            if ((NumberOfYears % 100) != 0)
        -:  820:            {
       48:  821:                DaysInThisYear = 366;
        -:  822:            }
        3:  823:            else if ((NumberOfYears % 400) == 0)
        -:  824:            {
        2:  825:                DaysInThisYear = 366;
        -:  826:            }
        -:  827:        }
        -:  828:
        -:  829:        /*
        -:  830:        ** When we have less than a years worth of days, we're done...
        -:  831:        */
      174:  832:        if (NumberOfDays < DaysInThisYear)
        -:  833:        {
       10:  834:            StillCountingYears = FALSE;
        -:  835:        }
        -:  836:        else
        -:  837:        {
        -:  838:            /*
        -:  839:            ** Add a year and remove the number of days in that year...
        -:  840:            */
      164:  841:            NumberOfYears++;
      164:  842:            NumberOfDays -= DaysInThisYear;
        -:  843:        }
        -:  844:    }
        -:  845:
        -:  846:    /*
        -:  847:    ** Unlike hours and minutes, days are displayed as Jan 1 = day 1...
        -:  848:    */
       10:  849:    NumberOfDays++;
        -:  850:
        -:  851:    /*
        -:  852:    ** After computing microseconds, convert to 5 digits from 6 digits...
        -:  853:    */
       10:  854:    NumberOfMicros = CFE_TIME_Sub2MicroSecs(TimeToPrint.Subseconds) / 10;
        -:  855:
        -:  856:    /*
        -:  857:    ** Build formatted output string (yyyy-ddd-hh:mm:ss.xxxxx)...
        -:  858:    */
       10:  859:    *PrintBuffer++ = '0' + (char) (NumberOfYears / 1000); NumberOfYears = NumberOfYears % 1000;
       10:  860:    *PrintBuffer++ = '0' + (char) (NumberOfYears / 100);  NumberOfYears = NumberOfYears % 100;
       10:  861:    *PrintBuffer++ = '0' + (char) (NumberOfYears / 10);
       10:  862:    *PrintBuffer++ = '0' + (char) (NumberOfYears % 10);
       10:  863:    *PrintBuffer++ = '-';
        -:  864:
       10:  865:    *PrintBuffer++ = '0' + (char) (NumberOfDays / 100); NumberOfDays = NumberOfDays % 100;
       10:  866:    *PrintBuffer++ = '0' + (char) (NumberOfDays / 10);
       10:  867:    *PrintBuffer++ = '0' + (char) (NumberOfDays % 10);
       10:  868:    *PrintBuffer++ = '-';
        -:  869:
       10:  870:    *PrintBuffer++ = '0' + (char) (NumberOfHours / 10);
       10:  871:    *PrintBuffer++ = '0' + (char) (NumberOfHours % 10);
       10:  872:    *PrintBuffer++ = ':';
        -:  873:
       10:  874:    *PrintBuffer++ = '0' + (char) (NumberOfMinutes / 10);
       10:  875:    *PrintBuffer++ = '0' + (char) (NumberOfMinutes % 10);
       10:  876:    *PrintBuffer++ = ':';
        -:  877:
       10:  878:    *PrintBuffer++ = '0' + (char) (NumberOfSeconds / 10);
       10:  879:    *PrintBuffer++ = '0' + (char) (NumberOfSeconds % 10);
       10:  880:    *PrintBuffer++ = '.';
        -:  881:
       10:  882:    *PrintBuffer++ = '0' + (char) (NumberOfMicros / 10000); NumberOfMicros = NumberOfMicros % 10000;
       10:  883:    *PrintBuffer++ = '0' + (char) (NumberOfMicros / 1000);  NumberOfMicros = NumberOfMicros % 1000;
       10:  884:    *PrintBuffer++ = '0' + (char) (NumberOfMicros / 100);   NumberOfMicros = NumberOfMicros % 100;
       10:  885:    *PrintBuffer++ = '0' + (char) (NumberOfMicros / 10);
       10:  886:    *PrintBuffer++ = '0' + (char) (NumberOfMicros % 10);
       10:  887:    *PrintBuffer++ = '\0';
        -:  888:
        -:  889:    return;
        -:  890:
        -:  891:} /* End of CFE_TIME_Print() */
        -:  892:
        -:  893:
        -:  894:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  895:/*                                                                         */
        -:  896:/* CFE_TIME_ExternalTone() --  external tone signal was detected           */
        -:  897:/*                                                                         */
        -:  898:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  899:
        -:  900:void CFE_TIME_ExternalTone(void)
        1:  901:{
        -:  902:    /*
        -:  903:    ** Call tone signal ISR (OK if called from non-ISR context)...
        -:  904:    */
        1:  905:    CFE_TIME_Tone1HzISR();
        -:  906:
        -:  907:    return;
        -:  908:
        -:  909:} /* End of CFE_TIME_ExternalTone() */
        -:  910:
        -:  911:
        -:  912:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  913:/*                                                                         */
        -:  914:/* CFE_TIME_RegisterSynchCallback() --  register synch callback func       */
        -:  915:/*                                                                         */
        -:  916:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  917:
        -:  918:int32  CFE_TIME_RegisterSynchCallback(CFE_TIME_SynchCallbackPtr_t CallbackFuncPtr)   
       10:  919:{
       10:  920:    int32  Status = CFE_SUCCESS;
       10:  921:    uint32 i = 0;
        -:  922:
       40:  923:    while ((i<CFE_TIME_MAX_NUM_SYNCH_FUNCS) && (CFE_TIME_TaskData.SynchCallback[i].Ptr != NULL))
        -:  924:    {
       20:  925:        i++;
        -:  926:    }
        -:  927:    
       10:  928:    if (i<CFE_TIME_MAX_NUM_SYNCH_FUNCS)
        -:  929:    {
        8:  930:        Status = CFE_ES_GetAppID(&CFE_TIME_TaskData.SynchCallback[i].App);
        8:  931:        if (Status == CFE_SUCCESS)
        -:  932:        {
        8:  933:            CFE_TIME_TaskData.SynchCallback[i].Ptr = CallbackFuncPtr;
        -:  934:        }
        -:  935:    }
        -:  936:    else
        -:  937:    {
        2:  938:        Status = CFE_TIME_TOO_MANY_SYNCH_CALLBACKS;
        -:  939:    }
        -:  940:    
       10:  941:    return Status;
        -:  942:} /* End of CFE_TIME_RegisterSynchCallback() */
        -:  943:
        -:  944:
        -:  945:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  946:/*                                                                         */
        -:  947:/* CFE_TIME_UnregisterSynchCallback() --  unregister synch callback func   */
        -:  948:/*                                                                         */
        -:  949:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  950:
        -:  951:int32  CFE_TIME_UnregisterSynchCallback(CFE_TIME_SynchCallbackPtr_t CallbackFuncPtr)   
        6:  952:{
        6:  953:    int32  Status = CFE_SUCCESS;
        6:  954:    uint32 i = 0;
        -:  955:    uint32 AppId;
        -:  956:    
        6:  957:    Status = CFE_ES_GetAppID(&AppId);
        -:  958:    
        6:  959:    if (Status == CFE_SUCCESS)
        -:  960:    {
       26:  961:        while (i<CFE_TIME_MAX_NUM_SYNCH_FUNCS) 
        -:  962:        {
       18:  963:            if ((CFE_TIME_TaskData.SynchCallback[i].App == AppId) &&
        -:  964:                (CFE_TIME_TaskData.SynchCallback[i].Ptr == CallbackFuncPtr))
        -:  965:            {
        4:  966:                break;
        -:  967:            }
        -:  968:            
       14:  969:            i++;
        -:  970:        }
        -:  971:        
        6:  972:        if (i<CFE_TIME_MAX_NUM_SYNCH_FUNCS)
        -:  973:        {
        4:  974:            CFE_TIME_TaskData.SynchCallback[i].App = 0;
        4:  975:            CFE_TIME_TaskData.SynchCallback[i].Ptr = NULL;
        -:  976:        }
        -:  977:        else
        -:  978:        {
        2:  979:            Status = CFE_TIME_CALLBACK_NOT_REGISTERED;
        -:  980:        }
        -:  981:            
        -:  982:    }
        -:  983:    
        6:  984:    return Status;
        -:  985:} /* End of CFE_TIME_UnregisterSynchCallback() */
        -:  986:
        -:  987:
        -:  988:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  989:/*                                                                         */
        -:  990:/* CFE_TIME_ExternalMET() -- time data from external source (MET)          */
        -:  991:/*                                                                         */
        -:  992:/* Notes: 1) Time Servers use this call as the signal to send the          */
        -:  993:/*           "time at the tone" command packet.                            */
        -:  994:/*                                                                         */
        -:  995:/*        2) This function is only included in the API if the Time         */
        -:  996:/*           Server has been configured to accept time data from an        */
        -:  997:/*           external source (MET).                                        */
        -:  998:/*                                                                         */
        -:  999:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1000:
        -: 1001:#ifdef CFE_TIME_CFG_SRC_MET
        -: 1002:void CFE_TIME_ExternalMET(CFE_TIME_SysTime_t NewMET)
        -: 1003:{
        -: 1004:    /*
        -: 1005:    ** Process external MET data...
        -: 1006:    */
        -: 1007:    CFE_TIME_ToneSendMET(NewMET);
        -: 1008:
        -: 1009:    return;
        -: 1010:
        -: 1011:} /* End of CFE_TIME_ExternalMET() */
        -: 1012:#endif /* CFE_TIME_CFG_SRC_MET  */
        -: 1013:
        -: 1014:
        -: 1015:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1016:/*                                                                         */
        -: 1017:/* CFE_TIME_ExternalGPS() -- time data from external source (GPS)          */
        -: 1018:/*                                                                         */
        -: 1019:/* Notes: 1) Time Servers use this call as the signal to send the          */
        -: 1020:/*           "time at the tone" command packet.                            */
        -: 1021:/*                                                                         */
        -: 1022:/*        2) This function is only included in the API if the Time         */
        -: 1023:/*           Server has been configured to accept time data from an        */
        -: 1024:/*           external source (GPS).                                        */
        -: 1025:/*                                                                         */
        -: 1026:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1027:
        -: 1028:#ifdef CFE_TIME_CFG_SRC_GPS
        -: 1029:void CFE_TIME_ExternalGPS(CFE_TIME_SysTime_t NewTime, int16 NewLeaps)
        -: 1030:{
        -: 1031:    /*
        -: 1032:    ** Process external GPS time data...
        -: 1033:    */
        -: 1034:    CFE_TIME_ToneSendGPS(NewTime, NewLeaps);
        -: 1035:
        -: 1036:    return;
        -: 1037:
        -: 1038:} /* End of CFE_TIME_ExternalGPS() */
        -: 1039:#endif /* CFE_TIME_CFG_SRC_GPS */
        -: 1040:
        -: 1041:
        -: 1042:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1043:/*                                                                         */
        -: 1044:/* CFE_TIME_ExternalTime() -- time data from external source (S/C, etc.)   */
        -: 1045:/*                                                                         */
        -: 1046:/* Notes: 1) Time Servers use this call as the signal to send the          */
        -: 1047:/*           "time at the tone" command packet.                            */
        -: 1048:/*                                                                         */
        -: 1049:/*        2) This function is only included in the API if the Time         */
        -: 1050:/*           Server has been configured to accept time data from an        */
        -: 1051:/*           external source (spacecraft time).                            */
        -: 1052:/*                                                                         */
        -: 1053:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1054:
        -: 1055:#ifdef CFE_TIME_CFG_SRC_TIME
        -: 1056:void CFE_TIME_ExternalTime(CFE_TIME_SysTime_t NewTime)
        -: 1057:{
        -: 1058:    /*
        -: 1059:    ** Process external time data...
        -: 1060:    */
        -: 1061:    CFE_TIME_ToneSendTime(NewTime);
        -: 1062:
        -: 1063:    return;
        -: 1064:
        -: 1065:} /* End of CFE_TIME_ExternalTime() */
        -: 1066:#endif /* CFE_TIME_CFG_SRC_TIME */
        -: 1067:
        -: 1068:
        -: 1069:/************************/
        -: 1070:/*  End of File Comment */
        -: 1071:/************************/
