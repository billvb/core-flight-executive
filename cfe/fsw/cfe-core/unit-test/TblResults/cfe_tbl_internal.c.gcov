        -:    0:Source:/mnt/hgfs/Proj/cFE/Builds/Trunk/fsw/cfe-core/src/tbl/cfe_tbl_internal.c
        -:    0:Graph:cfe_tbl_internal.gcno
        -:    0:Data:cfe_tbl_internal.gcda
        -:    0:Runs:1
        -:    0:Programs:2
        -:    1:/*
        -:    2:** $Id: cfe_tbl_internal.c.gcov 1.8 2009/05/01 16:37:23EDT dkobe Exp  $
        -:    3:**
        -:    4:**      Copyright © 2004-2006, United States government as represented by the 
        -:    5:**      administrator of the National Aeronautics Space Administration.  
        -:    6:**      All rights reserved. This software(cFE) was created at NASA’s Goddard 
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This software may be used only pursuant to a United States government 
        -:   10:**      sponsored project and the United States government may not be charged
        -:   11:**      for use thereof.  
        -:   12:**
        -:   13:** Purpose:  cFE Table Services (TBL) utility function source file
        -:   14:**
        -:   15:** Author:   D. Kobe/the Hammers Company, Inc.
        -:   16:**
        -:   17:** Notes:
        -:   18:**
        -:   19:** $Log: cfe_tbl_internal.c.gcov  $
        -:   19:** Revision 1.8 2009/05/01 16:37:23EDT dkobe 
        -:   19:** Updated for checking for positive return codes from table validation functions
        -:   20:** Revision 1.3 2008/07/29 15:55:15EDT dkobe 
        -:   21:** Moved CFE_TBL_DumpToBuffer from cfe_tbl_internal.c to cfe_tbl_api.c
        -:   22:** Revision 1.2 2008/07/29 14:05:35EDT dkobe 
        -:   23:** Removed redundant FileCreateTimeSecs and FileCreateTimeSubSecs fields
        -:   24:** Revision 1.1 2008/04/17 08:05:34EDT ruperera 
        -:   25:** Initial revision
        -:   26:** Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/src/tbl/project.pj
        -:   27:** Revision 1.51 2007/08/07 12:52:42EDT David Kobe (dlkobe) 
        -:   28:** Modified CFE_ES_GetPoolBuf API's first parameter to be of type uint32**
        -:   29:** Revision 1.50 2007/07/13 11:27:15EDT dlkobe 
        -:   30:** Moved prototype for CFE_TBL_UpdateCriticalTblCDS to cfe_tbl_internal.h
        -:   31:** Revision 1.49 2007/07/03 10:19:17EDT dlkobe 
        -:   32:** Removed unused CFE_TBL_AddAccessLink function
        -:   33:** Revision 1.48 2007/06/07 09:34:52EDT dlkobe 
        -:   34:** Corrected Critical Table CDS Name and CDS Registry Init
        -:   35:** Revision 1.47 2007/04/30 11:01:16EDT rjmcgraw 
        -:   36:** Changed EarlyInit to return error when detected
        -:   37:** Revision 1.46 2007/04/28 16:14:44EDT dlkobe 
        -:   38:** Changed RegisterCDS call to use internal RegisterCDSEx call
        -:   39:**
        -:   40:**
        -:   41:*/
        -:   42:
        -:   43:
        -:   44:/*
        -:   45:** Required header files...
        -:   46:*/
        -:   47:#include "osapi-os-core.h"
        -:   48:#include "cfe_platform_cfg.h"
        -:   49:#include "cfe_msgids.h"
        -:   50:#include "cfe_tbl_internal.h"
        -:   51:#include "cfe_tbl_events.h"
        -:   52:#include "cfe_error.h"
        -:   53:#include "cfe_es.h"
        -:   54:#include "cfe_evs.h"
        -:   55:#include "cfe_fs.h"
        -:   56:#include <stdio.h>
        -:   57:#include <string.h>
        -:   58:
        -:   59:/*
        -:   60:** External Globals
        -:   61:*/
        -:   62:extern CFE_TBL_TaskData_t CFE_TBL_TaskData;
        -:   63:
        -:   64:/*******************************************************************
        -:   65:**
        -:   66:** CFE_ES_RegisterCDSEx
        -:   67:**
        -:   68:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:   69:********************************************************************/
        -:   70:int32 CFE_ES_RegisterCDSEx(CFE_ES_CDSHandle_t *HandlePtr, int32 BlockSize, const char *Name, boolean CriticalTbl);
        -:   71:
        -:   72:/*****************************************************************************/
        -:   73:/**
        -:   74:** \brief Performs a byte swap on a uint32 integer
        -:   75:**
        -:   76:** \par Description
        -:   77:**        Converts a big-endian uint32 integer to a little-endian uint32 integer
        -:   78:**        and vice-versa.
        -:   79:**
        -:   80:** \par Assumptions, External Events, and Notes:
        -:   81:**          None
        -:   82:**
        -:   83:** \param[in]  Uint32ToSwapPtr Pointer to uint32 value to be swapped.
        -:   84:** 
        -:   85:** \param[out] *Uint32ToSwapPtr The swapped uint32 value
        -:   86:**
        -:   87:**                     
        -:   88:******************************************************************************/
        -:   89:void CFE_TBL_ByteSwapUint32(uint32 *Uint32ToSwapPtr);
        -:   90:
        -:   91:/*******************************************************************
        -:   92:**
        -:   93:** CFE_TBL_EarlyInit
        -:   94:**
        -:   95:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:   96:********************************************************************/
        -:   97:/******************************************************************************
        -:   98:**  Function:  CFE_TBL_EarlyInit()
        -:   99:**
        -:  100:**  Purpose:
        -:  101:**    Initialize the Table Services
        -:  102:**
        -:  103:**  Arguments:
        -:  104:**
        -:  105:**  Notes:
        -:  106:**    This function MUST be called before any TBL API's are called.
        -:  107:**
        -:  108:**  Return:
        -:  109:**    none
        -:  110:*/
        -:  111:int32 CFE_TBL_EarlyInit (void)
       13:  112:{
        -:  113:    int16 i;
        -:  114:    int32 j;
        -:  115:    int32 Status;
        -:  116:
        -:  117:
        -:  118:    /* Initialize the Table Registry */
     1677:  119:    for(i=0; i < CFE_TBL_MAX_NUM_TABLES; i++)
        -:  120:    {
     1664:  121:        CFE_TBL_InitRegistryRecord(&CFE_TBL_TaskData.Registry[i]);
        -:  122:    }
        -:  123:
        -:  124:    /* Initialize the Table Access Descriptors */
     3341:  125:    for (i=0; i<CFE_TBL_MAX_NUM_HANDLES; i++)
        -:  126:    {
     3328:  127:        CFE_TBL_TaskData.Handles[i].AppId = CFE_ES_ERR_APPID;
     3328:  128:        CFE_TBL_TaskData.Handles[i].RegIndex = 0;
     3328:  129:        CFE_TBL_TaskData.Handles[i].PrevLink = CFE_TBL_END_OF_LIST;
     3328:  130:        CFE_TBL_TaskData.Handles[i].NextLink = CFE_TBL_END_OF_LIST;
     3328:  131:        CFE_TBL_TaskData.Handles[i].UsedFlag = FALSE;
     3328:  132:        CFE_TBL_TaskData.Handles[i].LockFlag = FALSE;
     3328:  133:        CFE_TBL_TaskData.Handles[i].Updated = FALSE;
     3328:  134:        CFE_TBL_TaskData.Handles[i].BufferIndex = 0;
        -:  135:    }
        -:  136:
        -:  137:    /* Initialize the Table Validation Results Records */
      143:  138:    for (i=0; i<CFE_TBL_MAX_NUM_VALIDATIONS; i++)
        -:  139:    {
      130:  140:        CFE_TBL_TaskData.ValidationResults[i].State = CFE_TBL_VALIDATION_FREE;
      130:  141:        CFE_TBL_TaskData.ValidationResults[i].CrcOfTable = 0;
      130:  142:        CFE_TBL_TaskData.ValidationResults[i].Result = 0;
      130:  143:        CFE_TBL_TaskData.ValidationResults[i].ActiveBuffer = FALSE;
      130:  144:        CFE_TBL_TaskData.ValidationResults[i].TableName[0] = '\0';
        -:  145:    }
        -:  146:
        -:  147:    /* Initialize the Dump-Only Table Dump Control Blocks */
       65:  148:    for (i=0; i<CFE_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -:  149:    {
       52:  150:        CFE_TBL_TaskData.DumpControlBlocks[i].State = CFE_TBL_DUMP_FREE;
       52:  151:        CFE_TBL_TaskData.DumpControlBlocks[i].DumpBufferPtr = NULL;
       52:  152:        CFE_TBL_TaskData.DumpControlBlocks[i].Size = 0;
       52:  153:        CFE_TBL_TaskData.DumpControlBlocks[i].TableName[0] = '\0';
        -:  154:        
        -:  155:        /* Prevent Shared Buffers from being used until successfully allocated */
       52:  156:        CFE_TBL_TaskData.LoadBuffs[i].Taken = TRUE;
        -:  157:    }
        -:  158:
       13:  159:    CFE_TBL_TaskData.ValidationCtr = 0;
        -:  160:
       13:  161:    CFE_TBL_TaskData.HkTlmTblRegIndex = CFE_TBL_NOT_FOUND;
       13:  162:    CFE_TBL_TaskData.LastTblUpdated = CFE_TBL_NOT_FOUND;
        -:  163:    
        -:  164:    /*
        -:  165:    ** Create table registry access mutex
        -:  166:    */
       13:  167:    Status = OS_MutSemCreate(&CFE_TBL_TaskData.RegistryMutex,
        -:  168:                              CFE_TBL_MUT_REG_NAME,
        -:  169:                              CFE_TBL_MUT_REG_VALUE);
       13:  170:    if(Status != OS_SUCCESS)
        -:  171:    {
        1:  172:      CFE_ES_WriteToSysLog("CFE_TBL:Registry mutex creation failed! RC=0x%08x",Status);
        1:  173:      return Status;
        -:  174:    }/* end if */                              
        -:  175:
        -:  176:    /*
        -:  177:    ** Create working buffer access mutex
        -:  178:    */
       12:  179:    Status = OS_MutSemCreate(&CFE_TBL_TaskData.WorkBufMutex,
        -:  180:                              CFE_TBL_MUT_WORK_NAME,
        -:  181:                              CFE_TBL_MUT_WORK_VALUE);
       12:  182:    if(Status != OS_SUCCESS)
        -:  183:    {
        1:  184:      CFE_ES_WriteToSysLog("CFE_TBL:Working buffer mutex creation failed! RC=0x%08x",Status);
        1:  185:      return Status;
        -:  186:    }/* end if */
        -:  187:    
        -:  188:    /*
        -:  189:    ** Initialize housekeeping packet (clear user data area)...
        -:  190:    */
       11:  191:    CFE_SB_InitMsg(&CFE_TBL_TaskData.HkPacket,
        -:  192:                    CFE_TBL_HK_TLM_MID,
        -:  193:                    sizeof(CFE_TBL_HkPacket_t), TRUE);
        -:  194:
        -:  195:    /*
        -:  196:    ** Initialize table registry report packet (clear user data area)...
        -:  197:    */
       11:  198:    CFE_SB_InitMsg(&CFE_TBL_TaskData.TblRegPacket,
        -:  199:                    CFE_TBL_REG_TLM_MID,
        -:  200:                    sizeof(CFE_TBL_TblRegPacket_t), TRUE);
        -:  201:
        -:  202:    /* Initialize memory partition and allocate shared table buffers. */
       11:  203:    Status = CFE_ES_PoolCreate(&CFE_TBL_TaskData.Buf.PoolHdl,
        -:  204:                                CFE_TBL_TaskData.Buf.Partition,                               
        -:  205:                                CFE_TBL_BUF_MEMORY_BYTES);        
        -:  206:
       11:  207:    if(Status < 0)
        -:  208:    {
        1:  209:        CFE_ES_WriteToSysLog("CFE_TBL:InitBuffers PoolCreate fail Status=0x%X\n", Status);
        1:  210:        return Status;
        -:  211:    }
        -:  212:    else
        -:  213:    {
        -:  214:        /* Initialize each of the shared load buffers */
       10:  215:        j=0;
        -:  216:        do
        -:  217:        {
        -:  218:            /* Allocate memory for shared load buffers */
       37:  219:            Status = CFE_ES_GetPoolBuf((uint32 **)&CFE_TBL_TaskData.LoadBuffs[j].BufferPtr,
        -:  220:                                       CFE_TBL_TaskData.Buf.PoolHdl,
        -:  221:                                       CFE_TBL_MAX_SNGL_TABLE_SIZE);
        -:  222:
       37:  223:            if (Status < CFE_TBL_MAX_SNGL_TABLE_SIZE)
        -:  224:            {
        1:  225:                CFE_ES_WriteToSysLog("CFE_TBL:InitBuffers GetPoolBuf Fail Index=%d, Status=0x%X\n", j, Status);
        1:  226:                return Status;
        -:  227:            }
        -:  228:            else
        -:  229:            {
        -:  230:                /* The buffer is successfully created, so allow it to be used */
       36:  231:                CFE_TBL_TaskData.LoadBuffs[j].Taken = FALSE;
        -:  232:                
       36:  233:                OS_MemSet(CFE_TBL_TaskData.LoadBuffs[j].DataSource, 0, OS_MAX_PATH_LEN);
       36:  234:                CFE_TBL_TaskData.LoadBuffs[j].FileCreateTimeSecs = 0;
       36:  235:                CFE_TBL_TaskData.LoadBuffs[j].FileCreateTimeSubSecs = 0;
        -:  236:            }
        -:  237:
       36:  238:            j++;
        -:  239:        } while ((j < CFE_TBL_MAX_SIMULTANEOUS_LOADS) && 
       36:  240:                 (Status >= CFE_TBL_MAX_SNGL_TABLE_SIZE));
        -:  241:    }
        -:  242:    
        -:  243:    /* Try to obtain a previous image of the Critical Table Registry from the Critical Data Store */
        9:  244:    Status = CFE_ES_RegisterCDSEx(&CFE_TBL_TaskData.CritRegHandle, 
        -:  245:                                  (sizeof(CFE_TBL_CritRegRec_t)*CFE_TBL_MAX_CRITICAL_TABLES),
        -:  246:                                  "CFE_TBL.CritReg", TRUE);
        -:  247:                                
        -:  248:    /* Assume for the moment that nothing is already in the CDS and zero out the Critical Table Registry */
      297:  249:    for (i=0; i<CFE_TBL_MAX_CRITICAL_TABLES; i++)
        -:  250:    {
      288:  251:        CFE_TBL_TaskData.CritReg[i].CDSHandle = CFE_ES_CDS_BAD_HANDLE;
      288:  252:        CFE_TBL_TaskData.CritReg[i].FileCreateTimeSecs = 0;
      288:  253:        CFE_TBL_TaskData.CritReg[i].FileCreateTimeSubSecs = 0;
      288:  254:        CFE_TBL_TaskData.CritReg[i].LastFileLoaded[0] = '\0';
      288:  255:        CFE_TBL_TaskData.CritReg[i].TimeOfLastUpdate.Seconds = 0;
      288:  256:        CFE_TBL_TaskData.CritReg[i].TimeOfLastUpdate.Subseconds = 0;
        -:  257:    }
        -:  258:    
        9:  259:    if (Status == CFE_ES_CDS_ALREADY_EXISTS)
        -:  260:    {
        -:  261:        /* Try to recover the Critical Table Registry from the CDS */
        1:  262:        Status = CFE_ES_RestoreFromCDS(CFE_TBL_TaskData.CritReg, CFE_TBL_TaskData.CritRegHandle);
        -:  263:        
        1:  264:        if (Status != CFE_SUCCESS)
        -:  265:        {
        -:  266:            /* Note if we were unable to recover error free Critical Table Registry from the CDS */
        1:  267:            CFE_ES_WriteToSysLog("CFE_TBL:EarlyInit-Failed to recover Critical Table Registry (Err=0x%08X)\n", Status); 
        -:  268:        }
        -:  269:        
        -:  270:        /* Whether we recovered the Critical Table Registry or not, we are successful with initialization */
        1:  271:        Status = CFE_SUCCESS;
        -:  272:    }
        8:  273:    else if (Status != CFE_SUCCESS)
        -:  274:    {
        -:  275:        /* Not being able to support Critical Tables is not the end of the world */
        -:  276:        /* Note the problem and move on */
        1:  277:        CFE_ES_WriteToSysLog("CFE_TBL:EarlyInit-Failed to create Critical Table Registry (Err=0x%08X)\n", Status);
        -:  278:        
        -:  279:        /* Failure to support critical tables is not a good enough reason to exit the cFE on start up */
        1:  280:        Status = CFE_SUCCESS;
        -:  281:    }
        -:  282:    else
        -:  283:    {
        -:  284:        /* Save the initial version of the Critical Table Registry in the CDS */
        7:  285:        Status = CFE_ES_CopyToCDS(CFE_TBL_TaskData.CritRegHandle, CFE_TBL_TaskData.CritReg);
        -:  286:        
        7:  287:        if (Status != CFE_SUCCESS)
        -:  288:        {
        -:  289:            /* Not being able to support Critical Tables is not the end of the world */
        -:  290:            /* Note the problem and move on */
        1:  291:            CFE_ES_WriteToSysLog("CFE_TBL:EarlyInit-Failed to save Critical Table Registry (Err=0x%08X)\n", Status);
        -:  292:        
        -:  293:            /* Failure to support critical tables is not a good enough reason to exit the cFE on start up */
        1:  294:            Status = CFE_SUCCESS;
        -:  295:        }
        -:  296:    }
        -:  297:    
        9:  298:    return Status;
        -:  299:            
        -:  300:}/* end CFE_TBL_EarlyInit */
        -:  301:
        -:  302:
        -:  303:/*******************************************************************
        -:  304:**
        -:  305:** CFE_TBL_InitRegistryRecord
        -:  306:**
        -:  307:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  308:********************************************************************/
        -:  309:
        -:  310:
        -:  311:void CFE_TBL_InitRegistryRecord (CFE_TBL_RegistryRec_t *RegRecPtr)
     2202:  312:{
     2202:  313:    RegRecPtr->OwnerAppId = CFE_TBL_NOT_OWNED;
     2202:  314:    RegRecPtr->Size = 0;
     2202:  315:    RegRecPtr->Buffers[0].BufferPtr = NULL;
     2202:  316:    RegRecPtr->Buffers[0].FileCreateTimeSecs = 0;
     2202:  317:    RegRecPtr->Buffers[0].FileCreateTimeSubSecs = 0;
     2202:  318:    RegRecPtr->Buffers[0].Taken = FALSE;
     2202:  319:    RegRecPtr->Buffers[0].DataSource[0] = '\0';
     2202:  320:    RegRecPtr->Buffers[1].BufferPtr = NULL;
     2202:  321:    RegRecPtr->Buffers[1].FileCreateTimeSecs = 0;
     2202:  322:    RegRecPtr->Buffers[1].FileCreateTimeSubSecs = 0;
     2202:  323:    RegRecPtr->Buffers[1].Taken = FALSE;
     2202:  324:    RegRecPtr->Buffers[1].DataSource[0] = '\0';
     2202:  325:    RegRecPtr->ValidationFuncPtr = NULL;
     2202:  326:    RegRecPtr->TimeOfLastUpdate.Seconds = 0;
     2202:  327:    RegRecPtr->TimeOfLastUpdate.Subseconds = 0;
     2202:  328:    RegRecPtr->HeadOfAccessList = CFE_TBL_END_OF_LIST;
     2202:  329:    RegRecPtr->LoadInProgress =  CFE_TBL_NO_LOAD_IN_PROGRESS;
     2202:  330:    RegRecPtr->ValidateActiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
     2202:  331:    RegRecPtr->ValidateInactiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
     2202:  332:    RegRecPtr->CDSHandle = CFE_ES_CDS_BAD_HANDLE;
     2202:  333:    RegRecPtr->CriticalTable = FALSE;
     2202:  334:    RegRecPtr->TableLoadedOnce = FALSE;
     2202:  335:    RegRecPtr->LoadPending = FALSE;
     2202:  336:    RegRecPtr->DumpOnly = FALSE;
     2202:  337:    RegRecPtr->DumpControlIndex = CFE_TBL_NO_DUMP_PENDING;
     2202:  338:    RegRecPtr->UserDefAddr = FALSE;
     2202:  339:    RegRecPtr->DblBuffered = FALSE;
     2202:  340:    RegRecPtr->ActiveBufferIndex = 0;
     2202:  341:    RegRecPtr->Name[0] = '\0';
     2202:  342:    RegRecPtr->LastFileLoaded[0] = '\0';
     2202:  343:}
        -:  344:
        -:  345:
        -:  346:/*******************************************************************
        -:  347:**
        -:  348:** CFE_TBL_ValidateHandle
        -:  349:**
        -:  350:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  351:********************************************************************/
        -:  352:
        -:  353:
        -:  354:int32 CFE_TBL_ValidateHandle(CFE_TBL_Handle_t TblHandle)
      105:  355:{
      105:  356:    int32 Status = CFE_SUCCESS;
        -:  357:
        -:  358:    /* Is the handle out of range? */
      105:  359:    if (TblHandle >= CFE_TBL_MAX_NUM_HANDLES)
        -:  360:    {
        3:  361:        Status = CFE_TBL_ERR_INVALID_HANDLE;
        -:  362:
        3:  363:        CFE_ES_WriteToSysLog("CFE_TBL:ValidateHandle-Table Handle=%d is > %d\n", TblHandle, CFE_TBL_MAX_NUM_HANDLES);
        -:  364:    }
        -:  365:    else
        -:  366:    {
        -:  367:        /* Check to see if the Handle is no longer valid for this Table */
      102:  368:        if (CFE_TBL_TaskData.Handles[TblHandle].UsedFlag == FALSE)
        -:  369:        {
        2:  370:            Status = CFE_TBL_ERR_INVALID_HANDLE;
        -:  371:
        2:  372:            CFE_ES_WriteToSysLog("CFE_TBL:ValidateHandle-Table Handle=%d is for unused Table Handle\n", TblHandle);
        -:  373:        }
        -:  374:    }
      105:  375:    return Status;
        -:  376:}   /* End of CFE_TBL_ValidateHandle() */
        -:  377:
        -:  378:/*******************************************************************
        -:  379:**
        -:  380:** CFE_TBL_ValidateAppID
        -:  381:**
        -:  382:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  383:********************************************************************/
        -:  384:
        -:  385:int32 CFE_TBL_ValidateAppID(uint32 *AppIdPtr)
      418:  386:{
      418:  387:    int32 Status = CFE_ES_GetAppID(AppIdPtr);
        -:  388:
      418:  389:    if (Status == CFE_SUCCESS)
        -:  390:    {
      414:  391:        if (*AppIdPtr >= CFE_ES_MAX_APPLICATIONS)
        -:  392:        {
        5:  393:            Status = CFE_TBL_ERR_BAD_APP_ID;
        -:  394:
        5:  395:            CFE_ES_WriteToSysLog("CFE_TBL:ValidateAppID-AppId=%d > Max Apps (%d)\n",
        -:  396:                                 *AppIdPtr, CFE_ES_MAX_APPLICATIONS);
        -:  397:        }
        -:  398:    }
        -:  399:    else
        -:  400:    {
        4:  401:        CFE_ES_WriteToSysLog("CFE_TBL:ValidateAppID-GetAppID failed (Stat=0x%08X)\n", Status);
        -:  402:    }
        -:  403:
      418:  404:    return Status;
        -:  405:}   /* End of CFE_TBL_ValidateAppID() */
        -:  406:
        -:  407:/*******************************************************************
        -:  408:**
        -:  409:** CFE_TBL_ValidateAccess
        -:  410:**
        -:  411:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  412:********************************************************************/
        -:  413:
        -:  414:int32 CFE_TBL_ValidateAccess(CFE_TBL_Handle_t TblHandle, uint32 *AppIdPtr)
       97:  415:{
       97:  416:    int32 Status = CFE_SUCCESS;
        -:  417:
        -:  418:    /* Check to make sure App ID is legit */
       97:  419:    Status = CFE_TBL_ValidateAppID(AppIdPtr);
        -:  420:
       97:  421:    if (Status == CFE_SUCCESS)
        -:  422:    {
        -:  423:        /* Check table handle validity */
       94:  424:        Status = CFE_TBL_ValidateHandle(TblHandle);
        -:  425:
       94:  426:        if (Status == CFE_SUCCESS)
        -:  427:        {
       90:  428:            Status = CFE_TBL_CheckAccessRights(TblHandle, *AppIdPtr);
        -:  429:
       90:  430:            if (Status != CFE_SUCCESS)
        -:  431:            {
        1:  432:                CFE_ES_WriteToSysLog("CFE_TBL:ValidateAccess-App(%d) no access to Tbl Handle=%d (Stat=0x%08X)\n",
        -:  433:                                     *AppIdPtr, TblHandle, Status);
        -:  434:            }
        -:  435:        }
        -:  436:        else
        -:  437:        {
        4:  438:            CFE_ES_WriteToSysLog("CFE_TBL:ValidateAccess-Invalid Tbl Handle=%d\n", TblHandle);
        -:  439:        }
        -:  440:    }
        -:  441:    else
        -:  442:    {
        3:  443:        CFE_ES_WriteToSysLog("CFE_TBL:ValidateAccess-Bad AppId=%d\n", *AppIdPtr);
        -:  444:    }
        -:  445:
       97:  446:    return Status;
        -:  447:}   /* End of CFE_TBL_ValidateAccess() */
        -:  448:
        -:  449:
        -:  450:/*******************************************************************
        -:  451:**
        -:  452:** CFE_TBL_CheckAccessRights
        -:  453:**
        -:  454:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  455:********************************************************************/
        -:  456:
        -:  457:int32 CFE_TBL_CheckAccessRights(CFE_TBL_Handle_t TblHandle, uint32 ThisAppId)
      100:  458:{
      100:  459:    int32 Status = CFE_SUCCESS;
        -:  460:
      100:  461:    if (ThisAppId != CFE_TBL_TaskData.Handles[TblHandle].AppId)
        -:  462:    {
        -:  463:        /* The Table Service Task always has access rights so that tables */
        -:  464:        /* can be manipulated via ground command                          */
        2:  465:        if (ThisAppId != CFE_TBL_TaskData.TableTaskAppId)
        -:  466:        {
        2:  467:            Status = CFE_TBL_ERR_NO_ACCESS;
        -:  468:        }
        -:  469:    }
        -:  470:
      100:  471:    return Status;
        -:  472:}
        -:  473:
        -:  474:/*******************************************************************
        -:  475:**
        -:  476:** CFE_TBL_RemoveAccessLink
        -:  477:**
        -:  478:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  479:********************************************************************/
        -:  480:
        -:  481:int32 CFE_TBL_RemoveAccessLink(CFE_TBL_Handle_t TblHandle)
       20:  482:{
       20:  483:    int32 Status = CFE_SUCCESS;
       20:  484:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       20:  485:    CFE_TBL_RegistryRec_t      *RegRecPtr     = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  486:
        -:  487:    /* Lock Access to the table while we modify the linked list */
       20:  488:    CFE_TBL_LockRegistry();
        -:  489:
        -:  490:    /* If we are removing the head of the linked list, then point */
        -:  491:    /* the head pointer to the link after this one                */
       20:  492:    if (AccessDescPtr->PrevLink == CFE_TBL_END_OF_LIST)
        -:  493:    {
       15:  494:        RegRecPtr->HeadOfAccessList = AccessDescPtr->NextLink;
        -:  495:
        -:  496:        /* Update the next link, if there is one, to be the new head of the list */
       15:  497:        if (AccessDescPtr->NextLink != CFE_TBL_END_OF_LIST)
        -:  498:        {
        1:  499:            CFE_TBL_TaskData.Handles[AccessDescPtr->NextLink].PrevLink = CFE_TBL_END_OF_LIST;
        -:  500:        }
        -:  501:    }
        -:  502:    else /* Access Descriptor is not the head of the list */
        -:  503:    {
        -:  504:        /* Set the next link on the previous link to the next link of the link being removed */
        5:  505:        CFE_TBL_TaskData.Handles[AccessDescPtr->PrevLink].NextLink = AccessDescPtr->NextLink;
        -:  506:
        -:  507:        /* If this link is not the end of the list, then complete two way linkage */
        -:  508:        /* by setting the next link's previous link to the previous link of the link being removed */
        5:  509:        if (AccessDescPtr->NextLink != CFE_TBL_END_OF_LIST)
        -:  510:        {
        2:  511:            CFE_TBL_TaskData.Handles[AccessDescPtr->NextLink].PrevLink = AccessDescPtr->PrevLink;
        -:  512:        }
        -:  513:    }
        -:  514:
        -:  515:    /* Return the Access Descriptor to the pool */
       20:  516:    AccessDescPtr->UsedFlag = FALSE;
        -:  517:
        -:  518:    /* If this was the last Access Descriptor for this table, we can free the memory buffers as well */
       20:  519:    if (RegRecPtr->HeadOfAccessList == CFE_TBL_END_OF_LIST)
        -:  520:    {
        -:  521:        /* Only free memory that we have allocated.  If the image is User Defined, then don't bother */
       14:  522:        if (RegRecPtr->UserDefAddr == FALSE)
        -:  523:        {
        -:  524:            /* Free memory allocated to buffers */
       13:  525:            Status = CFE_ES_PutPoolBuf(CFE_TBL_TaskData.Buf.PoolHdl, (uint32 *)RegRecPtr->Buffers[0].BufferPtr);
       13:  526:            RegRecPtr->Buffers[0].BufferPtr = NULL;
        -:  527:
       13:  528:            if (Status < 0)
        -:  529:            {
        1:  530:                CFE_ES_WriteToSysLog("CFE_TBL:RemoveAccessLink-PutPoolBuf[0] Fail Stat=0x%08X, Hndl=0x%08X, Buf=0x%08X\n",
        -:  531:                                     Status, CFE_TBL_TaskData.Buf.PoolHdl, RegRecPtr->Buffers[0].BufferPtr);
        -:  532:            }
        -:  533:
        -:  534:            /* If a double buffered table, then free the second buffer as well */
       13:  535:            if (RegRecPtr->DblBuffered)
        -:  536:            {
        3:  537:                Status = CFE_ES_PutPoolBuf(CFE_TBL_TaskData.Buf.PoolHdl, (uint32 *)RegRecPtr->Buffers[1].BufferPtr);
        3:  538:                RegRecPtr->Buffers[1].BufferPtr = NULL;
        -:  539:
        3:  540:                if (Status < 0)
        -:  541:                {
        1:  542:                    CFE_ES_WriteToSysLog("CFE_TBL:RemoveAccessLink-PutPoolBuf[1] Fail Stat=0x%08X, Hndl=0x%08X, Buf=0x%08X\n",
        -:  543:                                         Status, CFE_TBL_TaskData.Buf.PoolHdl, RegRecPtr->Buffers[1].BufferPtr);
        -:  544:                }
        -:  545:            }
        -:  546:            else
        -:  547:            {
        -:  548:                /* If a shared buffer has been allocated to the table, then release it as well */
       10:  549:                if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  550:                {
        -:  551:                    /* Free the working buffer */
        1:  552:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        1:  553:                    RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -:  554:                }
        -:  555:            }
        -:  556:        }
        -:  557:    }
        -:  558:
        -:  559:    /* Unlock the registry to allow others to modify it */
       20:  560:    CFE_TBL_UnlockRegistry();
        -:  561:
       20:  562:    return Status;
        -:  563:}   /* End of CFE_TBL_RemoveAccessLink() */
        -:  564:
        -:  565:
        -:  566:/*******************************************************************
        -:  567:**
        -:  568:** CFE_TBL_GetAddressInternal
        -:  569:**
        -:  570:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  571:********************************************************************/
        -:  572:
        -:  573:
        -:  574:int32 CFE_TBL_GetAddressInternal(void **TblPtr, CFE_TBL_Handle_t TblHandle, uint32 ThisAppId)
       11:  575:{
       11:  576:    int32   Status = CFE_SUCCESS;
        -:  577:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
        -:  578:    CFE_TBL_RegistryRec_t *RegRecPtr;
        -:  579:
        -:  580:    /* Check table handle validity */
       11:  581:    Status = CFE_TBL_ValidateHandle(TblHandle);
        -:  582:
       11:  583:    if (Status == CFE_SUCCESS)
        -:  584:    {
        -:  585:        /* Get a pointer to the Access Descriptor */
       10:  586:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        -:  587:
        -:  588:        /* Verify that we are allowed access to the table */
       10:  589:        Status = CFE_TBL_CheckAccessRights(TblHandle, ThisAppId);
        -:  590:
       10:  591:        if (Status == CFE_SUCCESS)
        -:  592:        {
        -:  593:            /* Get a pointer to the Table Registry entry */
        9:  594:            RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  595:
        -:  596:            /* If table is unowned, then owner must have unregistered it when we weren't looking */
        9:  597:            if (RegRecPtr->OwnerAppId == CFE_TBL_NOT_OWNED)
        -:  598:            {
        1:  599:                Status = CFE_TBL_ERR_UNREGISTERED;
        -:  600:
        1:  601:                CFE_ES_WriteToSysLog("CFE_TBL:GetAddressInternal-App(%d) attempt to access unowned Tbl Handle=%d\n",
        -:  602:                                     ThisAppId, TblHandle);
        -:  603:            }
        -:  604:            else /* Table Registry Entry is valid */
        -:  605:            {
        -:  606:                /* Lock the table and return the current pointer */
        8:  607:                AccessDescPtr->LockFlag = TRUE;
        -:  608:
        -:  609:                /* Save the buffer we are using in the access descriptor */
        -:  610:                /* This is used to ensure that if the buffer becomes inactive while */
        -:  611:                /* we are using it, no one will modify it until we are done */
        8:  612:                AccessDescPtr->BufferIndex = RegRecPtr->ActiveBufferIndex;
        -:  613:
        8:  614:                *TblPtr = RegRecPtr->Buffers[AccessDescPtr->BufferIndex].BufferPtr;
        -:  615:
        -:  616:                /* Return any pending warning or info status indicators */
        8:  617:                Status = CFE_TBL_GetNextNotification(TblHandle);
        -:  618:
        -:  619:                /* Clear Table Updated Notify Bit so that caller only gets it once */
        8:  620:                AccessDescPtr->Updated = FALSE;
        -:  621:            }
        -:  622:        }
        -:  623:        else
        -:  624:        {
        1:  625:            CFE_ES_WriteToSysLog("CFE_TBL:GetAddressInternal-App(%d) does not have access to Tbl Handle=%d\n",
        -:  626:                                 ThisAppId, TblHandle);
        -:  627:        }
        -:  628:    }
        -:  629:    else
        -:  630:    {
        1:  631:        CFE_ES_WriteToSysLog("CFE_TBL:GetAddressInternal-App(%d) using invalid Tbl Handle=%d\n",
        -:  632:                             ThisAppId, TblHandle);
        -:  633:    }
        -:  634:
       11:  635:    return Status;
        -:  636:}   /* End of CFE_TBL_GetAddressInternal() */
        -:  637:
        -:  638:
        -:  639:/*******************************************************************
        -:  640:**
        -:  641:** CFE_TBL_GetNextNotification
        -:  642:**
        -:  643:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  644:********************************************************************/
        -:  645:
        -:  646:int32 CFE_TBL_GetNextNotification(CFE_TBL_Handle_t TblHandle)
       15:  647:{
       15:  648:    int32 Status = CFE_SUCCESS;
       15:  649:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       15:  650:    CFE_TBL_RegistryRec_t *RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  651:
       15:  652:    if (!RegRecPtr->TableLoadedOnce)
        -:  653:    {
        -:  654:        /* If the table has never been loaded, return an error code for the address */
        6:  655:        Status = CFE_TBL_ERR_NEVER_LOADED;
        -:  656:    }
        9:  657:    else if (AccessDescPtr->Updated)
        -:  658:    {
        -:  659:        /* If the table has been updated recently, return the update status */
        5:  660:        Status = CFE_TBL_INFO_UPDATED;
        -:  661:    }
        -:  662:
       15:  663:    return Status;
        -:  664:}   /* End of CFE_TBL_GetNextNotification() */
        -:  665:
        -:  666:
        -:  667:/*******************************************************************
        -:  668:**
        -:  669:** CFE_TBL_FindTableInRegistry
        -:  670:**
        -:  671:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  672:********************************************************************/
        -:  673:
        -:  674:int16 CFE_TBL_FindTableInRegistry(const char *TblName)
      350:  675:{
      350:  676:    int16 RegIndx = CFE_TBL_NOT_FOUND;
      350:  677:    int16 i = -1;
        -:  678:
        -:  679:    do
        -:  680:    {
        -:  681:        /* Point to next record in the Table Registry */
    22093:  682:        i++;
        -:  683:
        -:  684:        /* Check to see if the record is currently being used */
    22093:  685:        if (CFE_TBL_TaskData.Registry[i].OwnerAppId != CFE_TBL_NOT_OWNED)
        -:  686:        {
        -:  687:            /* Perform a case sensitive name comparison */
    10242:  688:            if (strcmp(TblName, CFE_TBL_TaskData.Registry[i].Name) == 0)
        -:  689:            {
        -:  690:                /* If the names match, then return the index */
      180:  691:                RegIndx = i;
        -:  692:            }
        -:  693:        }
    22093:  694:    } while ( (RegIndx == CFE_TBL_NOT_FOUND) && (i < (CFE_TBL_MAX_NUM_TABLES-1)) );
        -:  695:
      350:  696:    return RegIndx;
        -:  697:}   /* End of CFE_TBL_FindTableInRegistry() */
        -:  698:
        -:  699:
        -:  700:/*******************************************************************
        -:  701:**
        -:  702:** CFE_TBL_FindFreeRegistryEntry
        -:  703:**
        -:  704:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  705:********************************************************************/
        -:  706:
        -:  707:int16 CFE_TBL_FindFreeRegistryEntry(void)
      156:  708:{
      156:  709:    int16 RegIndx = CFE_TBL_NOT_FOUND;
      156:  710:    int16 i = 0;
        -:  711:
     8857:  712:    while ( (RegIndx == CFE_TBL_NOT_FOUND) && (i < CFE_TBL_MAX_NUM_TABLES) )
        -:  713:    {
        -:  714:        /* A Table Registry is only "Free" when there isn't an owner AND */
        -:  715:        /* all other applications are not sharing or locking the table   */
     8700:  716:        if ((CFE_TBL_TaskData.Registry[i].OwnerAppId == CFE_TBL_NOT_OWNED) &&
        -:  717:            (CFE_TBL_TaskData.Registry[i].HeadOfAccessList == CFE_TBL_END_OF_LIST))
        -:  718:        {
      155:  719:            RegIndx = i;
        -:  720:        }
        -:  721:        else
        -:  722:        {
     8390:  723:            i++;
        -:  724:        }
        -:  725:    }
        -:  726:
      156:  727:    return RegIndx;
        -:  728:}   /* End of CFE_TBL_FindFreeRegistryEntry() */
        -:  729:
        -:  730:
        -:  731:/*******************************************************************
        -:  732:**
        -:  733:** CFE_TBL_FindFreeHandle
        -:  734:**
        -:  735:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  736:********************************************************************/
        -:  737:
        -:  738:CFE_TBL_Handle_t CFE_TBL_FindFreeHandle(void)
      294:  739:{
      294:  740:    CFE_TBL_Handle_t HandleIndx = CFE_TBL_END_OF_LIST;
      294:  741:    int16 i = 0;
        -:  742:
    34561:  743:    while ((HandleIndx == CFE_TBL_END_OF_LIST) && (i < CFE_TBL_MAX_NUM_HANDLES))
        -:  744:    {
    33973:  745:        if (CFE_TBL_TaskData.Handles[i].UsedFlag == FALSE)
        -:  746:        {
      292:  747:            HandleIndx = i;
        -:  748:        }
        -:  749:        else
        -:  750:        {
    33681:  751:            i++;
        -:  752:        }
        -:  753:    }
        -:  754:
      294:  755:    return HandleIndx;
        -:  756:}   /* End of CFE_TBL_FindFreeHandle() */
        -:  757:
        -:  758:
        -:  759:/*******************************************************************
        -:  760:**
        -:  761:** CFE_TBL_FormTableName
        -:  762:**
        -:  763:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  764:********************************************************************/
        -:  765:
        -:  766:void CFE_TBL_FormTableName(char *FullTblName, const char *TblName, uint32 ThisAppId)
      166:  767:{
        -:  768:    char AppName[OS_MAX_API_NAME];
        -:  769:
      166:  770:    CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  771:
        -:  772:    /* Ensure that AppName is null terminated */
      166:  773:    AppName[OS_MAX_API_NAME-1] = '\0';
        -:  774:
        -:  775:    /* Complete formation of processor specific table name */
      166:  776:    sprintf(FullTblName, "%s.%s", AppName, TblName);
        -:  777:
        -:  778:    return;
        -:  779:}   /* End of CFE_TBL_FormTableName() */
        -:  780:
        -:  781:
        -:  782:/*******************************************************************
        -:  783:**
        -:  784:** CFE_TBL_LockRegistry
        -:  785:**
        -:  786:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  787:********************************************************************/
        -:  788:
        -:  789:int32 CFE_TBL_LockRegistry(void)
      316:  790:{
        -:  791:    int32   Status;
        -:  792:
      316:  793:    Status = OS_MutSemTake(CFE_TBL_TaskData.RegistryMutex);
        -:  794:
        -:  795:    if (Status == OS_SUCCESS)
        -:  796:    {
        -:  797:        Status = CFE_SUCCESS;
        -:  798:
        -:  799:    }
        -:  800:
      316:  801:    return Status;
        -:  802:
        -:  803:}   /* End of CFE_TBL_LockRegistry() */
        -:  804:
        -:  805:
        -:  806:/*******************************************************************
        -:  807:**
        -:  808:** CFE_TBL_UnlockRegistry
        -:  809:**
        -:  810:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  811:********************************************************************/
        -:  812:
        -:  813:int32 CFE_TBL_UnlockRegistry(void)
      316:  814:{
        -:  815:    int32   Status;
        -:  816:
      316:  817:    Status = OS_MutSemGive(CFE_TBL_TaskData.RegistryMutex);
        -:  818:
        -:  819:    if (Status == OS_SUCCESS)
        -:  820:    {
        -:  821:        Status = CFE_SUCCESS;
        -:  822:
        -:  823:    }
        -:  824:
      316:  825:    return Status;
        -:  826:
        -:  827:}   /* End of CFE_TBL_UnlockRegistry() */
        -:  828:
        -:  829:
        -:  830:/*******************************************************************
        -:  831:**
        -:  832:** CFE_TBL_GetWorkingBuffer
        -:  833:**
        -:  834:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  835:********************************************************************/
        -:  836:
        -:  837:int32 CFE_TBL_GetWorkingBuffer(CFE_TBL_LoadBuff_t **WorkingBufferPtr,
        -:  838:                               CFE_TBL_RegistryRec_t *RegRecPtr,
        -:  839:                               boolean CalledByApp)
       34:  840:{
       34:  841:    int32   Status = CFE_SUCCESS;
        -:  842:    int32   i;
        -:  843:    int32   InactiveBufferIndex;
        -:  844:    CFE_TBL_Handle_t AccessIterator;
        -:  845:
        -:  846:    /* Initialize return pointer to NULL */
       34:  847:    *WorkingBufferPtr = NULL;
        -:  848:
        -:  849:    /* If a load is already in progress, return the previously allocated working buffer */
       34:  850:    if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  851:    {
        5:  852:        if (RegRecPtr->DblBuffered)
        -:  853:        {
        1:  854:            *WorkingBufferPtr = &RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)];
        -:  855:        }
        -:  856:        else
        -:  857:        {
        4:  858:            *WorkingBufferPtr = &CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress];
        -:  859:        }
        -:  860:    }
        -:  861:    else
        -:  862:    {
        -:  863:        /* If the table is uninitialized and the function is called by an application (rather than       */
        -:  864:        /* by the Table Services application), then use the current active buffer as the working buffer. */
        -:  865:        /* This allows many tasks with many tables to perform the initialization without conflict        */
        -:  866:        /* over the accessibility of the shared working buffers.                                         */
       43:  867:        if ((RegRecPtr->TableLoadedOnce == FALSE) && (CalledByApp == TRUE))
        -:  868:        {
       14:  869:            if (RegRecPtr->DblBuffered)
        -:  870:            {
        2:  871:                *WorkingBufferPtr = &RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex];
        -:  872:            }
        -:  873:            else
        -:  874:            {
       12:  875:                *WorkingBufferPtr = &RegRecPtr->Buffers[0];
        -:  876:            }
        -:  877:        }
        -:  878:        else
        -:  879:        {
        -:  880:            /* If the table is a double buffered table, then check to make sure the */
        -:  881:            /* inactive buffer has been freed by any Applications that may have been using it */
       15:  882:            if (RegRecPtr->DblBuffered)
        -:  883:            {
        -:  884:                /* Determine the index of the Inactive Buffer Pointer */
        6:  885:                InactiveBufferIndex = 1 - RegRecPtr->ActiveBufferIndex;
        -:  886:
        -:  887:                /* Scan the access descriptor table to determine if anyone is still using the inactive buffer */
        6:  888:                AccessIterator = RegRecPtr->HeadOfAccessList;
       18:  889:                while ((AccessIterator != CFE_TBL_END_OF_LIST) && (Status == CFE_SUCCESS))
        -:  890:                {
        6:  891:                    if (CFE_TBL_TaskData.Handles[AccessIterator].BufferIndex == InactiveBufferIndex)
        -:  892:                    {
        1:  893:                        Status = CFE_TBL_ERR_NO_BUFFER_AVAIL;
        -:  894:
        1:  895:                        CFE_ES_WriteToSysLog("CFE_TBL:GetWorkingBuffer-Inactive Dbl Buff Locked for '%s' by AppId=%d\n",
        -:  896:                                             RegRecPtr->Name, CFE_TBL_TaskData.Handles[AccessIterator].AppId);
        -:  897:                    }
        -:  898:
        -:  899:                    /* Move to next access descriptor in linked list */
        6:  900:                    AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -:  901:                }
        -:  902:
        -:  903:                /* If buffer is free, then return the pointer to it */
        6:  904:                if (Status == CFE_SUCCESS)
        -:  905:                {
        5:  906:                    *WorkingBufferPtr = &RegRecPtr->Buffers[InactiveBufferIndex];
        5:  907:                    RegRecPtr->LoadInProgress = InactiveBufferIndex;
        -:  908:                }
        -:  909:            }
        -:  910:            else /* Single Buffered Table */
        -:  911:            {
        -:  912:                /* Take Mutex to make sure we are not trying to grab a working buffer that some */
        -:  913:                /* other application is also trying to grab. */
        9:  914:                Status = OS_MutSemTake(CFE_TBL_TaskData.WorkBufMutex);
        -:  915:
        -:  916:                /* Make note of any errors but continue and hope for the best */
        9:  917:                if (Status != OS_SUCCESS)
        -:  918:                {
        1:  919:                    CFE_ES_WriteToSysLog("CFE_TBL:GetWorkBuf-Internal error taking WorkBuf Mutex (Status=0x%08X)\n",
        -:  920:                                         Status);
        -:  921:                }
        -:  922:
        -:  923:                /* Determine if there are any common buffers available */
        9:  924:                i = 0;
       26:  925:                while ((i < CFE_TBL_MAX_SIMULTANEOUS_LOADS) && (CFE_TBL_TaskData.LoadBuffs[i].Taken == TRUE))
        -:  926:                {
        8:  927:                    i++;
        -:  928:                }
        -:  929:
        -:  930:                /* If a free buffer was found, then return the address to the associated shared buffer */
        9:  931:                if (i < CFE_TBL_MAX_SIMULTANEOUS_LOADS)
        -:  932:                {
        7:  933:                    CFE_TBL_TaskData.LoadBuffs[i].Taken = TRUE;
        7:  934:                    *WorkingBufferPtr = &CFE_TBL_TaskData.LoadBuffs[i];
        7:  935:                    RegRecPtr->LoadInProgress = i;
        -:  936:
        -:  937:                    /* Translate OS_SUCCESS into CFE_SUCCESS */
        7:  938:                    Status = CFE_SUCCESS;
        -:  939:                }
        -:  940:                else
        -:  941:                {
        2:  942:                    Status = CFE_TBL_ERR_NO_BUFFER_AVAIL;
        -:  943:
        2:  944:                    CFE_ES_WriteToSysLog("CFE_TBL:GetWorkingBuffer-All shared buffers are locked\n");
        -:  945:                }
        -:  946:
        -:  947:                /* Allow others to obtain a shared working buffer */
        9:  948:                OS_MutSemGive(CFE_TBL_TaskData.WorkBufMutex);
        -:  949:            }
        -:  950:
       15:  951:            if ((*WorkingBufferPtr) != NULL)
        -:  952:            {
        -:  953:                /* In case the file contains a partial table load, get the active buffer contents first */
       12:  954:                OS_MemCpy((*WorkingBufferPtr)->BufferPtr,
        -:  955:                          RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr,
        -:  956:                          RegRecPtr->Size);
        -:  957:            }
        -:  958:        }
        -:  959:    }
        -:  960:
        -:  961:
       34:  962:    return Status;
        -:  963:
        -:  964:}   /* End of CFE_TBL_GetWorkingBuffer() */
        -:  965:
        -:  966:
        -:  967:/*******************************************************************
        -:  968:**
        -:  969:** CFE_TBL_LoadFromFile
        -:  970:**
        -:  971:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -:  972:********************************************************************/
        -:  973:
        -:  974:int32 CFE_TBL_LoadFromFile(CFE_TBL_LoadBuff_t *WorkingBufferPtr,
        -:  975:                           CFE_TBL_RegistryRec_t *RegRecPtr,
        -:  976:                           const char *Filename)
       21:  977:{
       21:  978:    int32                Status = CFE_SUCCESS;
        -:  979:    CFE_FS_Header_t      StdFileHeader;
        -:  980:    CFE_TBL_File_Hdr_t   TblFileHeader;
        -:  981:    int32                FileDescriptor;
       21:  982:    int32                FilenameLen = strlen(Filename);
        -:  983:    uint32               NumBytes;
        -:  984:    uint8                ExtraByte;
        -:  985:
       21:  986:    if (FilenameLen > (OS_MAX_PATH_LEN-1))
        -:  987:    {
        1:  988:        Status = CFE_TBL_ERR_FILENAME_TOO_LONG;
        -:  989:    }
        -:  990:    else
        -:  991:    {
        -:  992:        /* Try to open the specified table file */
        -:  993:        /* TODO: Put in PATH search capability to locate file */
       20:  994:        FileDescriptor = OS_open(Filename, OS_READ_ONLY, 0);
        -:  995:
       20:  996:        if (FileDescriptor >= 0)
        -:  997:        {
       19:  998:            Status = CFE_TBL_ReadHeaders(FileDescriptor, &StdFileHeader, &TblFileHeader, Filename);
        -:  999:
       19: 1000:            if (Status == CFE_SUCCESS)
        -: 1001:            {
        -: 1002:                /* Verify that the specified file has compatible data for specified table */
       19: 1003:                if (strcmp(RegRecPtr->Name, TblFileHeader.TableName) == 0)
        -: 1004:                {
       17: 1005:                    if ((TblFileHeader.Offset + TblFileHeader.NumBytes) > RegRecPtr->Size)
        -: 1006:                    {
        1: 1007:                        Status = CFE_TBL_ERR_FILE_TOO_LARGE;
        -: 1008:                    }
        -: 1009:                    else
        -: 1010:                    {
        -: 1011:                        /* Any Table load that starts beyond the first byte is a "partial load" */
        -: 1012:                        /* But a file that starts with the first byte and ends before filling   */
        -: 1013:                        /* the whole table is just considered "short".                          */
       16: 1014:                        if (TblFileHeader.Offset > 0)
        -: 1015:                        {
        1: 1016:                            Status = CFE_TBL_WARN_PARTIAL_LOAD;
        -: 1017:                        }
       15: 1018:                        else if (TblFileHeader.NumBytes < RegRecPtr->Size)
        -: 1019:                        {
        1: 1020:                            Status = CFE_TBL_WARN_SHORT_FILE;
        -: 1021:                        }
        -: 1022:
       16: 1023:                        NumBytes = OS_read(FileDescriptor,
        -: 1024:                                           &WorkingBufferPtr->BufferPtr[TblFileHeader.Offset],
        -: 1025:                                           TblFileHeader.NumBytes);
        -: 1026:
       16: 1027:                        if (NumBytes != TblFileHeader.NumBytes)
        -: 1028:                        {
        1: 1029:                            Status = CFE_TBL_ERR_LOAD_INCOMPLETE;
        -: 1030:                        }
        -: 1031:                        
        -: 1032:                        /* Check to see if the file is too large (ie - more data than header claims) */
       16: 1033:                        NumBytes = OS_read(FileDescriptor, &ExtraByte, 1);
        -: 1034:                        
        -: 1035:                        /* If successfully read another byte, then file must have too much data */
       16: 1036:                        if (NumBytes == 1)
        -: 1037:                        {
        1: 1038:                            Status = CFE_TBL_ERR_FILE_TOO_LARGE;
        -: 1039:                        }
        -: 1040:
       16: 1041:                        OS_MemSet(WorkingBufferPtr->DataSource, 0, OS_MAX_PATH_LEN);
       16: 1042:                        strncpy(WorkingBufferPtr->DataSource, Filename, OS_MAX_PATH_LEN);
        -: 1043:
        -: 1044:                        /* Save file creation time for later storage into Registry */
       16: 1045:                        WorkingBufferPtr->FileCreateTimeSecs = StdFileHeader.TimeSeconds;
       16: 1046:                        WorkingBufferPtr->FileCreateTimeSubSecs = StdFileHeader.TimeSubSeconds;
        -: 1047:                    }
        -: 1048:                }
        -: 1049:                else
        -: 1050:                {
        2: 1051:                    Status = CFE_TBL_ERR_FILE_FOR_WRONG_TABLE;
        -: 1052:                }
        -: 1053:            }
        -: 1054:
       19: 1055:            OS_close(FileDescriptor);
        -: 1056:        }
        -: 1057:        else
        -: 1058:        {
        -: 1059:            /* Return error code obtained from OS_open */
        1: 1060:            Status = FileDescriptor;
        -: 1061:        }
        -: 1062:    }
        -: 1063:
       21: 1064:    return Status;
        -: 1065:}
        -: 1066:
        -: 1067:
        -: 1068:/*******************************************************************
        -: 1069:**
        -: 1070:** CFE_TBL_UpdateInternal
        -: 1071:**
        -: 1072:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1073:********************************************************************/
        -: 1074:
        -: 1075:int32 CFE_TBL_UpdateInternal( CFE_TBL_Handle_t TblHandle,
        -: 1076:                              CFE_TBL_RegistryRec_t *RegRecPtr,
        -: 1077:                              CFE_TBL_AccessDescriptor_t *AccessDescPtr )
        9: 1078:{
        9: 1079:    int32 Status = CFE_SUCCESS;
        -: 1080:    CFE_TBL_Handle_t AccessIterator;
        9: 1081:    boolean LockStatus = FALSE;
        -: 1082:    
       10: 1083:    if ((!RegRecPtr->LoadPending) || (RegRecPtr->LoadInProgress == CFE_TBL_NO_LOAD_IN_PROGRESS))
        -: 1084:    {
        -: 1085:        /* Question: Should calling CFE_TBL_Update on a table with no load pending */
        -: 1086:        /* be considered an error?  Currently assuming it is not an error.         */
        1: 1087:        Status = CFE_TBL_INFO_NO_UPDATE_PENDING;
        -: 1088:    }
        -: 1089:    else
        -: 1090:    {
        8: 1091:        if (RegRecPtr->DblBuffered)
        -: 1092:        {
        -: 1093:            /* To update a double buffered table only requires a pointer swap */
        4: 1094:            RegRecPtr->ActiveBufferIndex = (uint8)RegRecPtr->LoadInProgress;
        -: 1095:
        -: 1096:            /* Source description in buffer should already have been updated by either */
        -: 1097:            /* the LoadFromFile function or the Load function (when a memory load).    */
        -: 1098:            /* However, we need to copy it into active registry area */
        4: 1099:            strncpy(RegRecPtr->LastFileLoaded,
        -: 1100:                    RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].DataSource,
        -: 1101:                    OS_MAX_PATH_LEN);
        -: 1102:
        4: 1103:            CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        -: 1104:            
        -: 1105:            /* If the table is a critical table, update the appropriate CDS with the new data */
        4: 1106:            if (RegRecPtr->CriticalTable == TRUE)
        -: 1107:            {
        4: 1108:                CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -: 1109:            }
        -: 1110:        }
        -: 1111:        else
        -: 1112:        {
        -: 1113:            /* Check to see if the Table is locked by anyone */
        4: 1114:            AccessIterator = RegRecPtr->HeadOfAccessList;
       15: 1115:            while (AccessIterator != CFE_TBL_END_OF_LIST)
        -: 1116:            {
        7: 1117:                LockStatus = (LockStatus || CFE_TBL_TaskData.Handles[AccessIterator].LockFlag);
        -: 1118:
        7: 1119:                AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -: 1120:            }
        -: 1121:
        4: 1122:            if (LockStatus)
        -: 1123:            {
        2: 1124:                Status = CFE_TBL_INFO_TABLE_LOCKED;
        -: 1125:
        2: 1126:                CFE_ES_WriteToSysLog("CFE_TBL:UpdateInternal-Unable to update locked table Handle=%d\n", TblHandle);
        -: 1127:            }
        -: 1128:            else
        -: 1129:            {
        -: 1130:                /* To update a single buffered table requires a memcpy from working buffer */
        2: 1131:                OS_MemCpy(RegRecPtr->Buffers[0].BufferPtr,
        -: 1132:                          CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr,
        -: 1133:                          RegRecPtr->Size);
        -: 1134:
        -: 1135:                /* Save source description with active buffer */
        2: 1136:                strncpy(RegRecPtr->Buffers[0].DataSource,
        -: 1137:                        CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].DataSource,
        -: 1138:                        OS_MAX_PATH_LEN);
        2: 1139:                strncpy(RegRecPtr->LastFileLoaded,
        -: 1140:                        CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].DataSource,
        -: 1141:                        OS_MAX_PATH_LEN);
        -: 1142:                
        -: 1143:                /* Save the file creation time from the loaded file into the Table Registry */
        2: 1144:                RegRecPtr->Buffers[0].FileCreateTimeSecs = 
        -: 1145:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].FileCreateTimeSecs;
        2: 1146:                RegRecPtr->Buffers[0].FileCreateTimeSubSecs = 
        -: 1147:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].FileCreateTimeSubSecs;
        -: 1148:
        -: 1149:                /* Free the working buffer */
        2: 1150:                CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        -: 1151:
        2: 1152:                CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        -: 1153:            
        -: 1154:                /* If the table is a critical table, update the appropriate CDS with the new data */
        2: 1155:                if (RegRecPtr->CriticalTable == TRUE)
        -: 1156:                {
        1: 1157:                    CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -: 1158:                }
        -: 1159:            }
        -: 1160:        }
        -: 1161:    }
        -: 1162:
        9: 1163:    return Status;
        -: 1164:}   /* End of CFE_TBL_UpdateInternal() */
        -: 1165:
        -: 1166:
        -: 1167:/*******************************************************************
        -: 1168:**
        -: 1169:** CFE_TBL_NotifyTblUsersOfUpdate
        -: 1170:**
        -: 1171:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1172:********************************************************************/
        -: 1173:
        -: 1174:void CFE_TBL_NotifyTblUsersOfUpdate(CFE_TBL_RegistryRec_t *RegRecPtr)
       16: 1175:{
        -: 1176:    CFE_TBL_Handle_t AccessIterator;
        -: 1177:    
        -: 1178:    /* Reset Load in Progress Values */
       16: 1179:    RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
       16: 1180:    RegRecPtr->TimeOfLastUpdate = CFE_TIME_GetTime();
        -: 1181:
        -: 1182:    /* Clear notification of pending load (as well as NO LOAD) and notify everyone of update */
       16: 1183:    RegRecPtr->LoadPending = FALSE;
       16: 1184:    RegRecPtr->TableLoadedOnce = TRUE;
       16: 1185:    AccessIterator = RegRecPtr->HeadOfAccessList;
       49: 1186:    while (AccessIterator != CFE_TBL_END_OF_LIST)
        -: 1187:    {
       17: 1188:        CFE_TBL_TaskData.Handles[AccessIterator].Updated = TRUE;
        -: 1189:
       17: 1190:        AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -: 1191:    }
       16: 1192:}
        -: 1193:
        -: 1194:/*******************************************************************
        -: 1195:**
        -: 1196:** CFE_TBL_ReadHeaders
        -: 1197:**
        -: 1198:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1199:********************************************************************/
        -: 1200:
        -: 1201:int32 CFE_TBL_ReadHeaders( int32 FileDescriptor,
        -: 1202:                           CFE_FS_Header_t *StdFileHeaderPtr,
        -: 1203:                           CFE_TBL_File_Hdr_t *TblFileHeaderPtr,
        -: 1204:                           const char *LoadFilename )
       34: 1205:{
        -: 1206:    int32 Status;
       34: 1207:    int32 EndianCheck = 0x01020304;
        -: 1208:    
        -: 1209:    /* Once the file is open, read the headers to determine the target Table */
       34: 1210:    Status = CFE_FS_ReadHeader(StdFileHeaderPtr, FileDescriptor);
        -: 1211:
       34: 1212:    if (Status != sizeof(CFE_FS_Header_t))
        -: 1213:    {
        -: 1214:        /* Error reading the standard cFE File Header */
        1: 1215:        CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_STD_HDR_ERR_EID,
        -: 1216:                                   CFE_EVS_ERROR,
        -: 1217:                                   CFE_TBL_TaskData.TableTaskAppId,
        -: 1218:                                   "Unable to read std header for '%s', Status = 0x%08X",
        -: 1219:                                   LoadFilename, Status);
        -: 1220:
        -: 1221:        /* Make sure the Status is not equal to CFE_SUCCESS */
        1: 1222:        Status = CFE_TBL_ERR_NO_STD_HEADER;
        -: 1223:    }
        -: 1224:    else
        -: 1225:    {
        -: 1226:        /* Verify the file type is a cFE compatible file */
       33: 1227:        if (StdFileHeaderPtr->ContentType != CFE_FS_FILE_CONTENT_ID)
        -: 1228:        {
        1: 1229:            CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_TYPE_ERR_EID,
        -: 1230:                                       CFE_EVS_ERROR,
        -: 1231:                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1232:                                       "File '%s' is not a cFE file type, ContentType = 0x%08X",
        -: 1233:                                       LoadFilename, StdFileHeaderPtr->ContentType);
        -: 1234:
        1: 1235:            Status = CFE_TBL_ERR_BAD_CONTENT_ID;
        -: 1236:        }
        -: 1237:        else
        -: 1238:        {
        -: 1239:            /* Verify the SubType to ensure that it is a Table Image File */
       32: 1240:            if (StdFileHeaderPtr->SubType != CFE_FS_TBL_IMG_SUBTYPE)
        -: 1241:            {
        1: 1242:                CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_SUBTYPE_ERR_EID,
        -: 1243:                                           CFE_EVS_ERROR,
        -: 1244:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1245:                                           "File subtype for '%s' is wrong. Subtype = 0x%08X",
        -: 1246:                                           LoadFilename, StdFileHeaderPtr->SubType);
        -: 1247:
        1: 1248:                Status = CFE_TBL_ERR_BAD_SUBTYPE_ID;
        -: 1249:            }
        -: 1250:            else
        -: 1251:            {
       31: 1252:                Status = OS_read(FileDescriptor, TblFileHeaderPtr, sizeof(CFE_TBL_File_Hdr_t));
        -: 1253:
       31: 1254:                if (Status != sizeof(CFE_TBL_File_Hdr_t))
        -: 1255:                {
        1: 1256:                    CFE_EVS_SendEventWithAppID(CFE_TBL_FILE_TBL_HDR_ERR_EID,
        -: 1257:                                               CFE_EVS_ERROR,
        -: 1258:                                               CFE_TBL_TaskData.TableTaskAppId,
        -: 1259:                                               "Unable to read tbl header for '%s', Status = 0x%08X",
        -: 1260:                                               LoadFilename, Status);
        -: 1261:
        -: 1262:                    /* Make sure the status is not equal to CFE_SUCCESS */
        1: 1263:                    Status = CFE_TBL_ERR_NO_TBL_HEADER;
        -: 1264:                }
        -: 1265:                else
        -: 1266:                {
        -: 1267:                    /* All checks have passed and we are pointing at the data */
       30: 1268:                    Status = CFE_SUCCESS;
        -: 1269:                    
        -: 1270:                    /* Determine whether this processor is a little endian processor */
       30: 1271:                    if ((*(char *)&EndianCheck) == 0x04)
        -: 1272:                    {
        -: 1273:                        /* If this is a little endian processor, then the standard cFE Table Header,   */
        -: 1274:                        /* which is in big endian format, must be swapped so that the data is readable */
       30: 1275:                        CFE_TBL_ByteSwapTblHeader(TblFileHeaderPtr);
        -: 1276:                    }
        -: 1277:                }
        -: 1278:            }
        -: 1279:        }
        -: 1280:    }
        -: 1281:
       34: 1282:    return Status;
        -: 1283:}   /* End of CFE_TBL_ReadHeaders() */
        -: 1284:
        -: 1285:
        -: 1286:/*******************************************************************
        -: 1287:**
        -: 1288:** CFE_TBL_ByteSwapTblHeader
        -: 1289:**
        -: 1290:** NOTE: For complete prolog information, see above
        -: 1291:********************************************************************/
        -: 1292:
        -: 1293:void CFE_TBL_ByteSwapTblHeader(CFE_TBL_File_Hdr_t *HdrPtr)
       37: 1294:{
       37: 1295:    CFE_TBL_ByteSwapUint32(&HdrPtr->Reserved);
       37: 1296:    CFE_TBL_ByteSwapUint32(&HdrPtr->Offset);
       37: 1297:    CFE_TBL_ByteSwapUint32(&HdrPtr->NumBytes);
       37: 1298:} /* End of CFE_TBL_ByteSwapTblHeader() */
        -: 1299:
        -: 1300:
        -: 1301:/*******************************************************************
        -: 1302:**
        -: 1303:** CFE_TBL_ByteSwapUint32
        -: 1304:**
        -: 1305:** NOTE: For complete prolog information, see above
        -: 1306:********************************************************************/
        -: 1307:
        -: 1308:void CFE_TBL_ByteSwapUint32(uint32 *Uint32ToSwapPtr)
      171: 1309:{
      171: 1310:    int32 Temp = *Uint32ToSwapPtr;
      171: 1311:    char *InPtr = (char *)&Temp;
      171: 1312:    char *OutPtr = (char *)Uint32ToSwapPtr;
        -: 1313:    
      171: 1314:    OutPtr[0] = InPtr[3];
      171: 1315:    OutPtr[1] = InPtr[2];
      171: 1316:    OutPtr[2] = InPtr[1];
      171: 1317:    OutPtr[3] = InPtr[0];    
      171: 1318:} /* End of CFE_TBL_ByteSwapUint32() */
        -: 1319:
        -: 1320:/*******************************************************************
        -: 1321:**
        -: 1322:** CFE_TBL_CleanUpApp
        -: 1323:**
        -: 1324:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1325:********************************************************************/
        -: 1326:
        -: 1327:void CFE_TBL_CleanUpApp(uint32 AppId)
        1: 1328:{
        -: 1329:    uint32 i;
        1: 1330:    CFE_TBL_RegistryRec_t *RegRecPtr = NULL;
        1: 1331:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
        -: 1332:
        -: 1333:    /* Scan Dump Requests to determine if any of the tables that */
        -: 1334:    /* were to be dumped will be deleted */
        5: 1335:    for (i=0; i<CFE_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -: 1336:    {
        -: 1337:        /* Check to see if the table to be dumped is owned by the App to be deleted */
        4: 1338:        if ((CFE_TBL_TaskData.DumpControlBlocks[i].State != CFE_TBL_DUMP_FREE) && 
        -: 1339:           (CFE_TBL_TaskData.DumpControlBlocks[i].RegRecPtr->OwnerAppId == AppId))
        -: 1340:        {
        -: 1341:            /* If so, then remove the dump request */
        1: 1342:            CFE_TBL_TaskData.DumpControlBlocks[i].State = CFE_TBL_DUMP_FREE;
        -: 1343:        }
        -: 1344:    }
        -: 1345:    
        -: 1346:    /* Scan Access Descriptors to determine if the Application had access to any tables */
      257: 1347:    for (i=0; i<CFE_TBL_MAX_NUM_HANDLES; i++)
        -: 1348:    {
        -: 1349:        /* Check to see if the Handle belongs to the Application being deleted */
      256: 1350:        if (CFE_TBL_TaskData.Handles[i].AppId == AppId)
        -: 1351:        {
        -: 1352:            /* Delete the handle (and the table, if the App owned it) */
        -: 1353:            /* Get a pointer to the relevant Access Descriptor */
        2: 1354:            AccessDescPtr = &CFE_TBL_TaskData.Handles[i];
        -: 1355:
        -: 1356:            /* Get a pointer to the relevant entry in the registry */
        2: 1357:            RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1358:
        -: 1359:            /* Determine if the Application owned this particular table */
        2: 1360:            if (RegRecPtr->OwnerAppId == AppId)
        -: 1361:            {
        -: 1362:                /* Mark table as free, although, technically, it isn't free until the */
        -: 1363:                /* linked list of Access Descriptors has no links in it.              */
        -: 1364:                /* NOTE: Allocated memory is freed when all Access Links have been    */
        -: 1365:                /*       removed.  This allows Applications to continue to use the    */
        -: 1366:                /*       data until they acknowledge that the table has been removed. */
        2: 1367:                RegRecPtr->OwnerAppId = (uint32)CFE_TBL_NOT_OWNED;
        -: 1368:
        -: 1369:                /* Remove Table Name */
        2: 1370:                RegRecPtr->Name[0] = '\0';
        -: 1371:            }
        -: 1372:            
        -: 1373:            /* Remove the Access Descriptor Link from linked list */
        -: 1374:            /* NOTE: If this removes the last access link, then   */
        -: 1375:            /*       memory buffers are set free as well.         */
        2: 1376:            CFE_TBL_RemoveAccessLink(i);
        -: 1377:        }
        -: 1378:    }
        1: 1379:}
        -: 1380:
        -: 1381:/*******************************************************************
        -: 1382:**
        -: 1383:** CFE_TBL_FindCriticalTblInfo
        -: 1384:**
        -: 1385:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1386:********************************************************************/
        -: 1387:
        -: 1388:void CFE_TBL_FindCriticalTblInfo(CFE_TBL_CritRegRec_t **CritRegRecPtr, CFE_ES_CDSHandle_t CDSHandleToFind)
       18: 1389:{
        -: 1390:    uint32 i;
        -: 1391:    
        -: 1392:    /* Assume the record is never found */
       18: 1393:    *CritRegRecPtr = NULL;
        -: 1394:    
      133: 1395:    for (i=0; i<CFE_TBL_MAX_CRITICAL_TABLES; i++)
        -: 1396:    {
      115: 1397:        if (CFE_TBL_TaskData.CritReg[i].CDSHandle == CDSHandleToFind)
        -: 1398:        {
       15: 1399:            *CritRegRecPtr = &CFE_TBL_TaskData.CritReg[i];
       15: 1400:            i=CFE_TBL_MAX_CRITICAL_TABLES;
        -: 1401:        }
        -: 1402:    }
       18: 1403:}
        -: 1404:
        -: 1405:
        -: 1406:/*******************************************************************
        -: 1407:**
        -: 1408:** CFE_TBL_UpdateCriticalTblCDS
        -: 1409:**
        -: 1410:** NOTE: For complete prolog information, see 'cfe_tbl_internal.h'
        -: 1411:********************************************************************/
        -: 1412:
        -: 1413:void CFE_TBL_UpdateCriticalTblCDS(CFE_TBL_RegistryRec_t *RegRecPtr)
       10: 1414:{
       10: 1415:    CFE_TBL_CritRegRec_t *CritRegRecPtr = NULL;
        -: 1416:    
       10: 1417:    int32 Status = CFE_SUCCESS;
        -: 1418:    
        -: 1419:    /* Copy an image of the updated table to the CDS for safekeeping */
       10: 1420:    Status = CFE_ES_CopyToCDS(RegRecPtr->CDSHandle, RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr);
        -: 1421:    
       10: 1422:    if (Status != CFE_SUCCESS)
        -: 1423:    {
        1: 1424:        CFE_ES_WriteToSysLog("CFE_TBL:UpdateCritTbl-Unable to update Critical Table '%s' in CDS (Err=0x%08X)\n", 
        -: 1425:                             RegRecPtr->Name, Status);
        -: 1426:    }
        -: 1427:    else
        -: 1428:    {
        -: 1429:        /* Locate entry in Critical Table Registry */   
        9: 1430:        CFE_TBL_FindCriticalTblInfo(&CritRegRecPtr, RegRecPtr->CDSHandle);
        9: 1431:        if (CritRegRecPtr != NULL)
        -: 1432:        {
        -: 1433:            /* Save information related to the source of the data stored in the table in Critical Table Registry */
        8: 1434:            CritRegRecPtr->FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
        8: 1435:            CritRegRecPtr->FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
        8: 1436:            strncpy(CritRegRecPtr->LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        8: 1437:            CritRegRecPtr->TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
        -: 1438:            
        -: 1439:            /* Update copy of Critical Table Registry in the CDS */
        8: 1440:            Status = CFE_ES_CopyToCDS(CFE_TBL_TaskData.CritRegHandle, CFE_TBL_TaskData.CritReg);
        -: 1441:            
        8: 1442:            if (Status != CFE_SUCCESS)
        -: 1443:            {
        1: 1444:                CFE_ES_WriteToSysLog("CFE_TBL:UpdateCritTbl-Unable to update Critical Table Registry in CDS (Err=0x%08X)\n",
        -: 1445:                                     Status);
        -: 1446:            }
        -: 1447:        }
        -: 1448:        else
        -: 1449:        {
        1: 1450:            CFE_ES_WriteToSysLog("CFE_TBL:UpdateCritTbl-Error finding '%s' in Critical Table Registry\n", 
        -: 1451:                                 RegRecPtr->Name);
        -: 1452:        }
        -: 1453:    }
        -: 1454:    
        -: 1455:    /* Don't bother notifying the caller of the problem since the active table is still legitimate */
       10: 1456:}
        -: 1457:/************************/
        -: 1458:/*  End of File Comment */
        -: 1459:/************************/
        -: 1460:
