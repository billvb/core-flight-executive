        -:    0:Source:/mnt/hgfs/Projects/Repo_cFE/fsw/cfe-core/src/tbl/cfe_tbl_task_cmds.c
        -:    0:Programs:4
        -:    1:/*
        -:    2:** $Id: cfe_tbl_task_cmds.c.gcov 1.9 2014/09/08 13:14:34GMT-05:00 rmcgraw Exp  $
        -:    3:**
        -:    4:**      Copyright (c) 2004-2012, United States government as represented by the
        -:    5:**      administrator of the National Aeronautics Space Administration.
        -:    6:**      All rights reserved. This software(cFE) was created at NASA's Goddard
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This is governed by the NASA Open Source Agreement and may be used,
        -:   10:**      distributed and modified only pursuant to the terms of that agreement.
        -:   11:**
        -:   12:**
        -:   13:** Subsystem: cFE TBL Task Command Processing Functions
        -:   14:**
        -:   15:** Author: David Kobe (the Hammers Company, Inc.)
        -:   16:**
        -:   17:** Notes:
        -:   18:**
        -:   19:** $Log: cfe_tbl_task_cmds.c.gcov  $
        -:   19:** Revision 1.9 2014/09/08 13:14:34GMT-05:00 rmcgraw 
        -:   19:** DCR22107:25 Baselined TBL unit test for cFE6.4.0
        -:   20:** Revision 1.14 2014/06/09 10:28:32EDT lwalling
        -:   21:** Store name of last table loaded in housekeeping, modify comments when storing last table updated info
        -:   22:** Revision 1.13 2012/02/22 15:13:33EST lwalling
        -:   23:** Remove obsolete TODO comments
        -:   24:** Revision 1.12 2012/01/18 16:32:20EST jmdagost
        -:   25:** Updated no-op event msg to include cFE version numbers.
        -:   26:** Revision 1.11 2012/01/13 12:17:40EST acudmore
        -:   27:** Changed license text to reflect open source
        -:   28:** Revision 1.10 2011/11/14 17:59:52EST lwalling
        -:   29:** Event EID mentioned in previous log entry should have been CFE_TBL_LOAD_EXCEEDS_SIZE_ERR_EID
        -:   30:** Revision 1.9 2011/11/14 17:43:02EST lwalling
        -:   31:** Modified event text and argument list for CFE_TBL_FILE_INCOMPLETE_ERR_EID
        -:   32:** Revision 1.8 2010/10/27 16:36:49EDT dkobe
        -:   33:** Added computation and reporting of Table CRCs to table load and registry reporting commands
        -:   34:** Revision 1.7 2010/10/27 13:57:56EDT dkobe
        -:   35:** Added calls to send notification messages when table commands are processed.
        -:   36:** Revision 1.6 2010/10/25 15:00:30EDT jmdagost
        -:   37:** Corrected bad apostrophe in prologue.
        -:   38:** Revision 1.5 2010/10/04 15:18:54EDT jmdagost
        -:   39:** Cleaned up copyright symbol.
        -:   40:** Revision 1.4 2009/06/10 09:20:11EDT acudmore
        -:   41:** Changed OS_Mem* and OS_BSP* calls to CFE_PSP_* calls
        -:   42:** Revision 1.3 2008/12/08 16:10:56EST dkobe
        -:   43:** Correcting errors generated during detailed design document generation
        -:   44:** Revision 1.2 2008/07/29 14:05:34EDT dkobe
        -:   45:** Removed redundant FileCreateTimeSecs and FileCreateTimeSubSecs fields
        -:   46:** Revision 1.1 2008/04/17 08:05:36EDT ruperera
        -:   47:** Initial revision
        -:   48:** Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/src/tbl/project.pj
        -:   49:** Revision 1.43 2007/09/12 16:06:11EDT David Kobe (dlkobe)
        -:   50:** Moved the definitions of CFE_ES_CRC_xx to the cfe_mission_cfg.h file and deleted TBL Services
        -:   51:** CRC #define statement.
        -:   52:** Revision 1.42 2007/07/07 09:20:35EDT dlkobe
        -:   53:** Added check for pending load in Load Cmd Processing
        -:   54:** Revision 1.41 2007/07/07 07:51:10EDT dlkobe
        -:   55:** Added CFE_TBL_ASSUMED_VALID_INFO_EID event message
        -:   56:** Revision 1.40 2007/07/05 15:38:36EDT dlkobe
        -:   57:** Added Critical Table Flag to Registry Dump/Tlm Cmds
        -:   58:**
        -:   59:*/
        -:   60:
        -:   61:
        -:   62:/*
        -:   63:** Required header files
        -:   64:*/
        -:   65:#include "cfe_version.h"
        -:   66:#include "cfe_evs.h"
        -:   67:#include "cfe_es.h"
        -:   68:#include "cfe_sb.h"
        -:   69:#include "cfe_fs.h"
        -:   70:#include "cfe_psp.h"
        -:   71:#include "cfe_tbl_internal.h"
        -:   72:#include "cfe_tbl_events.h"
        -:   73:#include "cfe_tbl_msg.h"
        -:   74:#include "cfe_tbl_task_cmds.h"
        -:   75:#include <string.h>
        -:   76:
        -:   77:
        -:   78:/*****************************************************************************/
        -:   79:/**
        -:   80:** CFE_ES_DeleteCDS() -- Deletes the specified CDS from the CDS Registry and frees CDS Memory
        -:   81:**
        -:   82:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:   83:******************************************************************************/
        -:   84:int32  CFE_ES_DeleteCDS(const char *CDSName, boolean CalledByTblServices);
        -:   85:
        -:   86:/*****************************************************************************/
        -:   87:/**
        -:   88:** \brief Gathers data and puts it into the Housekeeping Message format
        -:   89:**
        -:   90:** \par Description
        -:   91:**        Gathers data from the Table Services Application, computes necessary data values and identifies
        -:   92:**        what Table Validation information needs to be reported in Housekeeping Telemetry.
        -:   93:**
        -:   94:** \par Assumptions, External Events, and Notes:
        -:   95:**          None
        -:   96:**
        -:   97:** \retval None
        -:   98:******************************************************************************/
        -:   99:void CFE_TBL_GetHkData(void);
        -:  100:
        -:  101:
        -:  102:/*****************************************************************************/
        -:  103:/**
        -:  104:** \brief Convert Table Registry Entry for a Table into a Message
        -:  105:**
        -:  106:** \par Description
        -:  107:**        Extracts the Table Registry information for the table specified by the
        -:  108:**        #CFE_TBL_TaskData_t::HkTlmTblRegIndex variable.  It then formats the
        -:  109:**        Registry contents into a format appropriate for downlink.
        -:  110:**
        -:  111:** \par Assumptions, External Events, and Notes:
        -:  112:**        #CFE_TBL_TaskData_t::HkTlmTblRegIndex is assumed to be a valid index into
        -:  113:**           the Table Registry.
        -:  114:**
        -:  115:** \retval None
        -:  116:******************************************************************************/
        -:  117:void CFE_TBL_GetTblRegData(void);
        -:  118:
        -:  119:
        -:  120:/*****************************************************************************/
        -:  121:/**
        -:  122:** \brief Output block of data to file with standard cFE Table Image Headers
        -:  123:**
        -:  124:** \par Description
        -:  125:**        Writes the specified block of data in memory to the specified file
        -:  126:**        with the standard cFE File and cFE Table Image Headers.
        -:  127:**
        -:  128:** \par Assumptions, External Events, and Notes:
        -:  129:**          None
        -:  130:**
        -:  131:** \param[in] DumpFilename    Character string containing the full path of the file
        -:  132:**                            to which the contents of the table are to be written
        -:  133:**
        -:  134:** \param[in] TableName       Name of table being dumped to a file
        -:  135:**
        -:  136:** \param[in] DumpDataAddr    Address of data buffer whose contents are to be written
        -:  137:**                            to the specified file
        -:  138:**
        -:  139:** \param[in] TblSizeInBytes  Size of block of data to be written to the file
        -:  140:**
        -:  141:** \retval #CFE_TBL_INC_ERR_CTR  \copydoc CFE_TBL_INC_ERR_CTR
        -:  142:** \retval #CFE_TBL_INC_CMD_CTR  \copydoc CFE_TBL_INC_CMD_CTR
        -:  143:******************************************************************************/
        -:  144:CFE_TBL_CmdProcRet_t CFE_TBL_DumpToFile( char *DumpFilename, char *TableName,
        -:  145:                                         void *DumpDataAddr, uint32 TblSizeInBytes);
        -:  146:
        -:  147:
        -:  148:/*****************************************************************************/
        -:  149:/**
        -:  150:** \brief Aborts load by freeing associated inactive buffers and sending event message
        -:  151:**
        -:  152:** \par Description
        -:  153:**        This function aborts the load for the table whose registry entry is identified
        -:  154:**        by the registry record pointer given as an argument.  Aborting the load consists
        -:  155:**        of freeing any associated inactive buffer and issuing an event message.
        -:  156:**
        -:  157:** \par Assumptions, External Events, and Notes:
        -:  158:**        The given registry record pointer is assumed to be valid.
        -:  159:**
        -:  160:** \param[in] RegRecPtr   Pointer to registry record entry for the table whose load is to be aborted
        -:  161:**
        -:  162:** \return None
        -:  163:******************************************************************************/
        -:  164:void CFE_TBL_AbortLoad(CFE_TBL_RegistryRec_t *RegRecPtr);
        -:  165:
        -:  166:/*
        -:  167:** External Globals
        -:  168:*/
        -:  169:extern CFE_TBL_TaskData_t CFE_TBL_TaskData;
        -:  170:
        -:  171:/*******************************************************************
        -:  172:**
        -:  173:** CFE_TBL_HousekeepingCmd() -- Process Housekeeping Request Message
        -:  174:**
        -:  175:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  176:********************************************************************/
        -:  177:
        2:  178:CFE_TBL_CmdProcRet_t CFE_TBL_HousekeepingCmd( const CFE_SB_Msg_t *MessagePtr )
        -:  179:{
        -:  180:    int32                     Status;
        -:  181:    int32                     i;
        -:  182:    CFE_TBL_DumpControl_t    *DumpCtrlPtr;
        -:  183:    CFE_TIME_SysTime_t        DumpTime;
        -:  184:    int32                     FileDescriptor;
        -:  185:
        -:  186:    /*
        -:  187:    ** Collect housekeeping data from Table Services
        -:  188:    */
        2:  189:    CFE_TBL_GetHkData();
        -:  190:
        -:  191:    /*
        -:  192:    ** Send housekeeping telemetry packet
        -:  193:    */
        2:  194:    CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.HkPacket);
        2:  195:    Status = CFE_SB_SendMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.HkPacket);
        -:  196:
        2:  197:    if (Status != CFE_SUCCESS)
        -:  198:    {
        1:  199:        CFE_EVS_SendEvent(CFE_TBL_FAIL_HK_SEND_ERR_EID,
        -:  200:                          CFE_EVS_ERROR,
        -:  201:                          "Unable to send Hk Packet (Status=0x%08X)",
        -:  202:                          Status);
        -:  203:    }
        -:  204:
        -:  205:    /* If a table's registry entry has been requested for telemetry, then pack it and send it */
        2:  206:    if (CFE_TBL_TaskData.HkTlmTblRegIndex != CFE_TBL_NOT_FOUND)
        -:  207:    {
        2:  208:        CFE_TBL_GetTblRegData();
        -:  209:
        -:  210:        /*
        -:  211:        ** Send Table Registry Info Packet
        -:  212:        */
        2:  213:        CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.TblRegPacket);
        2:  214:        CFE_SB_SendMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.TblRegPacket);
        -:  215:
        -:  216:        /* Once the data has been sent, clear the index so that we don't send it again and again */
        2:  217:        CFE_TBL_TaskData.HkTlmTblRegIndex = CFE_TBL_NOT_FOUND;
        -:  218:    }
        -:  219:
        -:  220:    /* Check to see if there are any dump-only table dumps pending */
       10:  221:    for (i=0; i < CFE_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -:  222:    {
        8:  223:        if (CFE_TBL_TaskData.DumpControlBlocks[i].State == CFE_TBL_DUMP_PERFORMED)
        -:  224:        {
        2:  225:        	DumpCtrlPtr = &CFE_TBL_TaskData.DumpControlBlocks[i];
        4:  226:            Status = CFE_TBL_DumpToFile(DumpCtrlPtr->DumpBufferPtr->DataSource,
        -:  227:                                        DumpCtrlPtr->TableName,
        2:  228:                                        DumpCtrlPtr->DumpBufferPtr->BufferPtr,
        -:  229:                                        DumpCtrlPtr->Size);
        -:  230:
        -:  231:            /* If dump file was successfully written, update the file header so that the timestamp */
        -:  232:            /* is the time of the actual capturing of the data, NOT the time when it was written to the file */
        2:  233:            if (Status == CFE_TBL_INC_CMD_CTR)
        -:  234:            {
        2:  235:                DumpTime.Seconds = DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSecs;
        2:  236:                DumpTime.Subseconds = DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSubSecs;
        -:  237:
        2:  238:                FileDescriptor = OS_open(DumpCtrlPtr->DumpBufferPtr->DataSource, OS_READ_WRITE, 0);
        -:  239:
        2:  240:                if (FileDescriptor >= 0)
        -:  241:                {
        1:  242:                    Status = CFE_FS_SetTimestamp(FileDescriptor, DumpTime);
        -:  243:
        1:  244:                    if (Status != OS_FS_SUCCESS)
        -:  245:                    {
        1:  246:                        CFE_ES_WriteToSysLog("CFE_TBL:HkCmd-Unable to update timestamp in dump file '%s'\n",
        1:  247:                                             DumpCtrlPtr->DumpBufferPtr->DataSource);
        -:  248:                    }
        -:  249:
        1:  250:                    OS_close(FileDescriptor);
        -:  251:                }
        -:  252:                else
        -:  253:                {
        1:  254:                    CFE_ES_WriteToSysLog("CFE_TBL:HkCmd-Unable to open dump file '%s' to update timestamp\n",
        1:  255:                                         DumpCtrlPtr->DumpBufferPtr->DataSource);
        -:  256:                }
        -:  257:            }
        -:  258:
        -:  259:            /* Free the shared working buffer */
        2:  260:            CFE_TBL_TaskData.LoadBuffs[DumpCtrlPtr->RegRecPtr->LoadInProgress].Taken = FALSE;
        2:  261:            DumpCtrlPtr->RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -:  262:
        -:  263:            /* Free the Dump Control Block for later use */
        2:  264:            DumpCtrlPtr->State = CFE_TBL_DUMP_FREE;
        -:  265:        }
        -:  266:    }
        -:  267:
        2:  268:    return CFE_TBL_DONT_INC_CTR;
        -:  269:
        -:  270:} /* End of CFE_TBL_HousekeepingCmd() */
        -:  271:
        -:  272:
        -:  273:/*******************************************************************
        -:  274:**
        -:  275:** CFE_TBL_GetHkData() -- Collect data and store it into the Housekeeping Message
        -:  276:**
        -:  277:** NOTE: For complete prolog information, see prototype above
        -:  278:********************************************************************/
        -:  279:
        6:  280:void CFE_TBL_GetHkData(void)
        -:  281:{
        -:  282:    int32 i;
        -:  283:    uint16 Count;
        6:  284:    CFE_TBL_ValidationResult_t *ValPtr = NULL;
        -:  285:
        -:  286:    /* Copy command counter data */
        6:  287:    CFE_TBL_TaskData.HkPacket.CmdCounter = CFE_TBL_TaskData.CmdCounter;
        6:  288:    CFE_TBL_TaskData.HkPacket.ErrCounter = CFE_TBL_TaskData.ErrCounter;
        6:  289:    CFE_TBL_TaskData.HkPacket.FailedValCtr = CFE_TBL_TaskData.FailedValCtr;
        6:  290:    CFE_TBL_TaskData.HkPacket.NumLoadPending = 0;
        6:  291:    CFE_TBL_TaskData.HkPacket.MemPoolHandle = CFE_TBL_TaskData.Buf.PoolHdl;
        -:  292:
        -:  293:    /* Determine the number of tables currently registered and Number of Load Pending Tables */
        6:  294:    Count = 0;
      774:  295:    for (i=0; i<CFE_TBL_MAX_NUM_TABLES; i++)
        -:  296:    {
      768:  297:        if (CFE_TBL_TaskData.Registry[i].OwnerAppId != CFE_TBL_NOT_OWNED)
        -:  298:        {
      514:  299:            Count++;
        -:  300:
      514:  301:            if (CFE_TBL_TaskData.Registry[i].LoadPending)
        -:  302:            {
        4:  303:                CFE_TBL_TaskData.HkPacket.NumLoadPending++;
        -:  304:            }
        -:  305:        }
        -:  306:    }
        6:  307:    CFE_TBL_TaskData.HkPacket.NumTables = Count;
        -:  308:
        -:  309:    /* Determine the number of free shared buffers */
        6:  310:    CFE_TBL_TaskData.HkPacket.NumFreeSharedBufs = CFE_TBL_MAX_SIMULTANEOUS_LOADS;
       30:  311:    for (i=0; i<CFE_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -:  312:    {
       24:  313:        if (CFE_TBL_TaskData.LoadBuffs[i].Taken)
        -:  314:        {
       10:  315:            CFE_TBL_TaskData.HkPacket.NumFreeSharedBufs--;
        -:  316:        }
        -:  317:    }
        -:  318:
        -:  319:    /* Locate a completed, but unreported, validation request */
        6:  320:    i=0;
       72:  321:    while ((i < CFE_TBL_MAX_NUM_VALIDATIONS) && (ValPtr == NULL))
        -:  322:    {
       60:  323:        if (CFE_TBL_TaskData.ValidationResults[i].State == CFE_TBL_VALIDATION_PERFORMED)
        -:  324:        {
        2:  325:            ValPtr = &CFE_TBL_TaskData.ValidationResults[i];
        -:  326:        }
        -:  327:        else
        -:  328:        {
       58:  329:            i++;
        -:  330:        }
        -:  331:    }
        -:  332:
        6:  333:    if (ValPtr != NULL)
        -:  334:    {
        2:  335:        CFE_TBL_TaskData.HkPacket.LastValCrc = ValPtr->CrcOfTable;
        2:  336:        CFE_TBL_TaskData.HkPacket.LastValStatus = ValPtr->Result;
        2:  337:        CFE_TBL_TaskData.HkPacket.ActiveBuffer = ValPtr->ActiveBuffer;
        -:  338:
        -:  339:        /* Keep track of the number of failed and successful validations */
        2:  340:        if (ValPtr->Result == CFE_SUCCESS)
        -:  341:        {
        1:  342:            CFE_TBL_TaskData.SuccessValCtr++;
        -:  343:        }
        -:  344:        else
        -:  345:        {
        1:  346:            CFE_TBL_TaskData.FailedValCtr++;
        -:  347:        }
        -:  348:
        2:  349:        CFE_PSP_MemCpy(&CFE_TBL_TaskData.HkPacket.LastValTableName[0],
        -:  350:                  &ValPtr->TableName[0],
        -:  351:                  CFE_TBL_MAX_FULL_NAME_LEN);
        2:  352:        CFE_TBL_TaskData.ValidationCtr++;
        -:  353:
        -:  354:        /* Free the Validation Response Block for next time */
        2:  355:        ValPtr->Result = 0;
        2:  356:        ValPtr->CrcOfTable = 0;
        2:  357:        ValPtr->TableName[0] = '\0';
        2:  358:        ValPtr->ActiveBuffer = FALSE;
        2:  359:        ValPtr->State = CFE_TBL_VALIDATION_FREE;
        -:  360:    }
        -:  361:
        6:  362:    CFE_TBL_TaskData.HkPacket.ValidationCtr  = CFE_TBL_TaskData.ValidationCtr;
        6:  363:    CFE_TBL_TaskData.HkPacket.SuccessValCtr  = CFE_TBL_TaskData.SuccessValCtr;
        6:  364:    CFE_TBL_TaskData.HkPacket.FailedValCtr   = CFE_TBL_TaskData.FailedValCtr;
        6:  365:    CFE_TBL_TaskData.HkPacket.NumValRequests = CFE_TBL_TaskData.NumValRequests;
        -:  366:
        -:  367:    /* Validate the index of the last table updated before using it */
       12:  368:    if ((CFE_TBL_TaskData.LastTblUpdated >= 0) &&
        6:  369:        (CFE_TBL_TaskData.LastTblUpdated < CFE_TBL_MAX_NUM_TABLES))
        -:  370:    {
        -:  371:        /* Check to make sure the Registry Entry is still valid */
        6:  372:        if (CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.LastTblUpdated].OwnerAppId != CFE_TBL_NOT_OWNED)
        -:  373:        {
        -:  374:            /* Get the time at the last table update */
        6:  375:            CFE_TBL_TaskData.HkPacket.LastUpdateTime =
        6:  376:              CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.LastTblUpdated].TimeOfLastUpdate;
        -:  377:
        -:  378:            /* Get the table name used for the last table update */
        6:  379:            CFE_PSP_MemCpy(CFE_TBL_TaskData.HkPacket.LastUpdatedTbl,
        6:  380:              CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.LastTblUpdated].Name,
        -:  381:              CFE_TBL_MAX_FULL_NAME_LEN);
        -:  382:        }
        -:  383:    }
        6:  384:}
        -:  385:
        -:  386:/*******************************************************************
        -:  387:**
        -:  388:** CFE_TBL_GetTblRegData() -- Convert Table Registry Entry for a Table into a Message
        -:  389:**
        -:  390:** NOTE: For complete prolog information, see prototype above
        -:  391:********************************************************************/
        -:  392:
        5:  393:void CFE_TBL_GetTblRegData(void)
        -:  394:{
        -:  395:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -:  396:
        5:  397:    RegRecPtr = &CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.HkTlmTblRegIndex];
        -:  398:
        5:  399:    CFE_TBL_TaskData.TblRegPacket.Size = RegRecPtr->Size;
        5:  400:    CFE_TBL_TaskData.TblRegPacket.ActiveBufferAddr = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr;
        -:  401:
        5:  402:    if (RegRecPtr->DblBuffered)
        -:  403:    {
        -:  404:        /* For a double buffered table, the inactive is the other allocated buffer */
        1:  405:        CFE_TBL_TaskData.TblRegPacket.InactiveBufferAddr =
        1:  406:            RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr;
        -:  407:    }
        -:  408:    else
        -:  409:    {
        -:  410:        /* Check to see if an inactive buffer has currently been allocated to the single buffered table */
        4:  411:        if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  412:        {
        1:  413:            CFE_TBL_TaskData.TblRegPacket.InactiveBufferAddr =
        1:  414:                CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr;
        -:  415:        }
        -:  416:        else
        -:  417:        {
        3:  418:            CFE_TBL_TaskData.TblRegPacket.InactiveBufferAddr = NULL;
        -:  419:        }
        -:  420:    }
        -:  421:
        5:  422:    CFE_TBL_TaskData.TblRegPacket.ValidationFuncPtr = RegRecPtr->ValidationFuncPtr;
        5:  423:    CFE_TBL_TaskData.TblRegPacket.TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
        5:  424:    CFE_TBL_TaskData.TblRegPacket.TableLoadedOnce = RegRecPtr->TableLoadedOnce;
        5:  425:    CFE_TBL_TaskData.TblRegPacket.LoadPending = RegRecPtr->LoadPending;
        5:  426:    CFE_TBL_TaskData.TblRegPacket.DumpOnly = RegRecPtr->DumpOnly;
        5:  427:    CFE_TBL_TaskData.TblRegPacket.DblBuffered = RegRecPtr->DblBuffered;
        5:  428:    CFE_TBL_TaskData.TblRegPacket.FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
        5:  429:    CFE_TBL_TaskData.TblRegPacket.FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
        5:  430:    CFE_TBL_TaskData.TblRegPacket.Crc = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].Crc;
        5:  431:    CFE_TBL_TaskData.TblRegPacket.Critical = RegRecPtr->CriticalTable;
        -:  432:
        5:  433:    CFE_PSP_MemCpy(CFE_TBL_TaskData.TblRegPacket.Name, RegRecPtr->Name, CFE_TBL_MAX_FULL_NAME_LEN);
        5:  434:    CFE_PSP_MemCpy(CFE_TBL_TaskData.TblRegPacket.LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        5:  435:    CFE_PSP_MemSet(CFE_TBL_TaskData.TblRegPacket.OwnerAppName, 0, OS_MAX_API_NAME);
        5:  436:    CFE_ES_GetAppName(CFE_TBL_TaskData.TblRegPacket.OwnerAppName, RegRecPtr->OwnerAppId, OS_MAX_API_NAME);
        5:  437:}
        -:  438:
        -:  439:
        -:  440:/*******************************************************************
        -:  441:**
        -:  442:** CFE_TBL_NoopCmd() -- Process NO-Op Command Message
        -:  443:**
        -:  444:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  445:********************************************************************/
        -:  446:
        2:  447:CFE_TBL_CmdProcRet_t CFE_TBL_NoopCmd( const CFE_SB_Msg_t *MessagePtr )
        -:  448:{
        -:  449:    /* Acknowledge receipt of NOOP with Event Message */
        2:  450:    CFE_EVS_SendEvent(CFE_TBL_NOOP_INF_EID, CFE_EVS_INFORMATION, "No-op command. cFE Version %d.%d.%d.%d",
        -:  451:                      CFE_MAJOR_VERSION,CFE_MINOR_VERSION,CFE_REVISION,CFE_MISSION_REV);
        -:  452:
        2:  453:    return CFE_TBL_INC_CMD_CTR;
        -:  454:
        -:  455:} /* End of CFE_TBL_NoopCmd() */
        -:  456:
        -:  457:
        -:  458:/*******************************************************************
        -:  459:**
        -:  460:** CFE_TBL_ResetCmd() -- Process Reset Counters Command Message
        -:  461:**
        -:  462:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  463:********************************************************************/
        -:  464:
        1:  465:CFE_TBL_CmdProcRet_t CFE_TBL_ResetCmd( const CFE_SB_Msg_t *MessagePtr )
        -:  466:{
        1:  467:    CFE_TBL_TaskData.CmdCounter = 0;
        1:  468:    CFE_TBL_TaskData.ErrCounter = 0;
        1:  469:    CFE_TBL_TaskData.SuccessValCtr = 0;
        1:  470:    CFE_TBL_TaskData.FailedValCtr = 0;
        1:  471:    CFE_TBL_TaskData.NumValRequests = 0;
        1:  472:    CFE_TBL_TaskData.ValidationCtr = 0;
        -:  473:
        1:  474:    CFE_EVS_SendEvent(CFE_TBL_RESET_INF_EID,
        -:  475:                      CFE_EVS_DEBUG,
        -:  476:                      "Reset Counters command");
        -:  477:
        1:  478:    return CFE_TBL_DONT_INC_CTR;
        -:  479:
        -:  480:} /* End of CFE_TBL_ResetCmd() */
        -:  481:
        -:  482:
        -:  483:/*******************************************************************
        -:  484:**
        -:  485:** CFE_TBL_LoadCmd() -- Process Load Table File to Buffer Command Message
        -:  486:**
        -:  487:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  488:********************************************************************/
        -:  489:
       11:  490:CFE_TBL_CmdProcRet_t CFE_TBL_LoadCmd( const CFE_SB_Msg_t *MessagePtr )
        -:  491:{
       11:  492:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
       11:  493:    const CFE_TBL_LoadCmd_t    *CmdPtr = (const CFE_TBL_LoadCmd_t *) MessagePtr;
        -:  494:    CFE_FS_Header_t             StdFileHeader;
        -:  495:    CFE_TBL_File_Hdr_t          TblFileHeader;
        -:  496:    int32                       FileDescriptor;
        -:  497:    int32                       Status;
        -:  498:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -:  499:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
        -:  500:    char                        LoadFilename[OS_MAX_PATH_LEN];
        -:  501:    uint8                       ExtraByte;
        -:  502:
        -:  503:    /* Make sure all strings are null terminated before attempting to process them */
       11:  504:    CFE_PSP_MemCpy(LoadFilename, (void *)CmdPtr->LoadFilename, OS_MAX_PATH_LEN);
       11:  505:    LoadFilename[OS_MAX_PATH_LEN-1] = '\0';
        -:  506:
        -:  507:    /* Try to open the specified table file */
       11:  508:    FileDescriptor = OS_open(LoadFilename, OS_READ_ONLY, 0);
        -:  509:
       11:  510:    if (FileDescriptor >= 0)
        -:  511:    {
       10:  512:        Status = CFE_TBL_ReadHeaders(FileDescriptor, &StdFileHeader, &TblFileHeader, &LoadFilename[0]);
        -:  513:
       10:  514:        if (Status == CFE_SUCCESS)
        -:  515:        {
        -:  516:            /* Locate specified table in registry */
       10:  517:            Status = CFE_TBL_FindTableInRegistry(TblFileHeader.TableName);
        -:  518:
       10:  519:            if (Status == CFE_TBL_NOT_FOUND)
        -:  520:            {
        1:  521:                CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -:  522:                                  CFE_EVS_ERROR,
        -:  523:                                  "Unable to locate '%s' in Table Registry",
        -:  524:                                  TblFileHeader.TableName);
        -:  525:            }
        -:  526:            else
        -:  527:            {
        -:  528:                /* Translate the registry index into a record pointer */
        9:  529:                RegRecPtr = &CFE_TBL_TaskData.Registry[Status];
        -:  530:
        9:  531:                if (RegRecPtr->DumpOnly)
        -:  532:                {
        1:  533:                    CFE_EVS_SendEvent(CFE_TBL_LOADING_A_DUMP_ONLY_ERR_EID,
        -:  534:                                      CFE_EVS_ERROR,
        -:  535:                                      "Attempted to load DUMP-ONLY table '%s' from '%s'",
        -:  536:                                      TblFileHeader.TableName, LoadFilename);
        -:  537:                }
        8:  538:                else if (RegRecPtr->LoadPending)
        -:  539:                {
        1:  540:                    CFE_EVS_SendEvent(CFE_TBL_LOADING_PENDING_ERR_EID,
        -:  541:                                      CFE_EVS_ERROR,
        -:  542:                                      "Attempted to load table '%s' while previous load is still pending",
        -:  543:                                      TblFileHeader.TableName);
        -:  544:                }
        -:  545:                else
        -:  546:                {
        -:  547:                    /* Make sure of the following:                                               */
        -:  548:                    /*    1) If table has not been loaded previously, then make sure the current */
        -:  549:                    /*       load starts with the first byte                                     */
        -:  550:                    /*    2) The number of bytes to load is greater than zero                    */
        -:  551:                    /*    3) The offset plus the number of bytes does not exceed the table size  */
       22:  552:                    if (((RegRecPtr->TableLoadedOnce) || (TblFileHeader.Offset == 0)) &&
        6:  553:                        (TblFileHeader.NumBytes > 0) &&
        5:  554:                        ((TblFileHeader.NumBytes + TblFileHeader.Offset) <= RegRecPtr->Size))
        -:  555:                    {
        -:  556:                        /* Get a working buffer, either a free one or one allocated with previous load command */
        4:  557:                        Status = CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, FALSE);
        -:  558:
        4:  559:                        if (Status == CFE_SUCCESS)
        -:  560:                        {
        -:  561:                            /* Copy data from file into working buffer */
        9:  562:                            Status = OS_read(FileDescriptor,
        6:  563:                                             &WorkingBufferPtr->BufferPtr[TblFileHeader.Offset],
        -:  564:                                             TblFileHeader.NumBytes);
        -:  565:
        -:  566:                            /* Make sure the appropriate number of bytes were read */
        3:  567:                            if (Status == (int32)TblFileHeader.NumBytes)
        -:  568:                            {
        -:  569:                                /* Check to ensure the file does not have any extra data at the end */
        2:  570:                                Status = OS_read(FileDescriptor, &ExtraByte, 1);
        -:  571:
        -:  572:                                /* If another byte was successfully read, then file contains more data than header claims */
        2:  573:                                if (Status == 1)
        -:  574:                                {
        1:  575:                                    CFE_EVS_SendEvent(CFE_TBL_FILE_TOO_BIG_ERR_EID,
        -:  576:                                                      CFE_EVS_ERROR,
        -:  577:                                                      "File '%s' has more data than Tbl Hdr indicates (%d)",
        -:  578:                                                      LoadFilename,
        -:  579:                                                      TblFileHeader.NumBytes);
        -:  580:                                }
        -:  581:                                else /* If error reading file or zero bytes read, assume it was the perfect size */
        -:  582:                                {
        1:  583:                                    CFE_EVS_SendEvent(CFE_TBL_FILE_LOADED_INF_EID,
        -:  584:                                                      CFE_EVS_INFORMATION,
        -:  585:                                                      "Successful load of '%s' into '%s' working buffer",
        -:  586:                                                      LoadFilename,
        -:  587:                                                      TblFileHeader.TableName);
        -:  588:
        -:  589:                                    /* Save file information statistics for later use in registry */
        1:  590:                                    CFE_PSP_MemCpy(WorkingBufferPtr->DataSource, LoadFilename, OS_MAX_PATH_LEN);
        -:  591:
        -:  592:                                    /* Save file creation time for later storage into Registry */
        1:  593:                                    WorkingBufferPtr->FileCreateTimeSecs = StdFileHeader.TimeSeconds;
        1:  594:                                    WorkingBufferPtr->FileCreateTimeSubSecs = StdFileHeader.TimeSubSeconds;
        -:  595:
        -:  596:                                    /* Compute the CRC on the specified table buffer */
        1:  597:                                    WorkingBufferPtr->Crc = CFE_ES_CalculateCRC(WorkingBufferPtr->BufferPtr,
        -:  598:                                                                                RegRecPtr->Size,
        -:  599:                                                                                0,
        -:  600:                                                                                CFE_ES_DEFAULT_CRC);
        -:  601:
        -:  602:                                    /* Initialize validation flag with TRUE if no Validation Function is required to be called */
        1:  603:                                    WorkingBufferPtr->Validated = (RegRecPtr->ValidationFuncPtr == NULL);
        -:  604:
        -:  605:                                    /* Save file information statistics for housekeeping telemetry */
        1:  606:                                    CFE_PSP_MemCpy(CFE_TBL_TaskData.HkPacket.LastFileLoaded, LoadFilename, OS_MAX_PATH_LEN);
        1:  607:                                    CFE_PSP_MemCpy(CFE_TBL_TaskData.HkPacket.LastTableLoaded, TblFileHeader.TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        -:  608:
        -:  609:                                    /* Increment successful command completion counter */
        1:  610:                                    ReturnCode = CFE_TBL_INC_CMD_CTR;
        -:  611:                                }
        -:  612:                            }
        -:  613:                            else
        -:  614:                            {
        -:  615:                                /* A file whose header claims has 'x' amount of data but it only has 'y' */
        -:  616:                                /* is considered a fatal error during a load process                     */
        1:  617:                                CFE_EVS_SendEvent(CFE_TBL_FILE_INCOMPLETE_ERR_EID,
        -:  618:                                                  CFE_EVS_ERROR,
        -:  619:                                                  "Incomplete load of '%s' into '%s' working buffer",
        -:  620:                                                  LoadFilename,
        -:  621:                                                  TblFileHeader.TableName);
        -:  622:                            }
        -:  623:                        }
        1:  624:                        else if (Status == CFE_TBL_ERR_NO_BUFFER_AVAIL)
        -:  625:                        {
        1:  626:                            CFE_EVS_SendEvent(CFE_TBL_NO_WORK_BUFFERS_ERR_EID,
        -:  627:                                              CFE_EVS_ERROR,
        -:  628:                                              "No working buffers available for table '%s'",
        -:  629:                                              TblFileHeader.TableName);
        -:  630:                        }
        -:  631:                        else
        -:  632:                        {
    #####:  633:                            CFE_EVS_SendEvent(CFE_TBL_INTERNAL_ERROR_ERR_EID,
        -:  634:                                              CFE_EVS_ERROR,
        -:  635:                                              "Internal Error (Status=0x%08X)",
        -:  636:                                              Status);
        -:  637:                        }
        -:  638:                    }
        -:  639:                    else
        -:  640:                    {
        3:  641:                        if ((TblFileHeader.NumBytes + TblFileHeader.Offset) > RegRecPtr->Size)
        -:  642:                        {
        1:  643:                            CFE_EVS_SendEvent(CFE_TBL_LOAD_EXCEEDS_SIZE_ERR_EID,
        -:  644:                                              CFE_EVS_ERROR,
        -:  645:                                              "Cannot load '%s' (%d) at offset %d in '%s' (%d)",
        -:  646:                                              LoadFilename, TblFileHeader.NumBytes, TblFileHeader.Offset,
        -:  647:                                              TblFileHeader.TableName, RegRecPtr->Size);
        -:  648:                        }
        2:  649:                        else if (TblFileHeader.NumBytes == 0)
        -:  650:                        {
        1:  651:                            CFE_EVS_SendEvent(CFE_TBL_ZERO_LENGTH_LOAD_ERR_EID,
        -:  652:                                              CFE_EVS_ERROR,
        -:  653:                                              "Table Hdr in '%s' indicates no data in file",
        -:  654:                                              LoadFilename);
        -:  655:                        }
        -:  656:                        else
        -:  657:                        {
        1:  658:                            CFE_EVS_SendEvent(CFE_TBL_PARTIAL_LOAD_ERR_EID,
        -:  659:                                              CFE_EVS_ERROR,
        -:  660:                                              "'%s' has partial load for uninitialized table '%s'",
        -:  661:                                              LoadFilename, TblFileHeader.TableName);
        -:  662:                        }
        -:  663:                    }
        -:  664:                }
        -:  665:            }
        -:  666:        }  /* No need to issue event messages in response to errors reading headers */
        -:  667:           /* because the function that read the headers will generate messages     */
        -:  668:
        -:  669:        /* Close the file now that the contents have been read */
       10:  670:        OS_close(FileDescriptor);
        -:  671:    }
        -:  672:    else
        -:  673:    {
        -:  674:        /* Error opening specified file */
        1:  675:        CFE_EVS_SendEvent(CFE_TBL_FILE_ACCESS_ERR_EID,
        -:  676:                          CFE_EVS_ERROR,
        -:  677:                          "Unable to open file '%s' for table load, Status = 0x%08X",
        -:  678:                          LoadFilename, FileDescriptor);
        -:  679:    }
        -:  680:
       11:  681:    return ReturnCode;
        -:  682:
        -:  683:} /* End of CFE_TBL_LoadCmd() */
        -:  684:
        -:  685:
        -:  686:/*******************************************************************
        -:  687:**
        -:  688:** CFE_TBL_DumpCmd() -- Process Dump Table to File Command Message
        -:  689:**
        -:  690:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  691:********************************************************************/
        -:  692:
        8:  693:CFE_TBL_CmdProcRet_t CFE_TBL_DumpCmd( const CFE_SB_Msg_t *MessagePtr )
        -:  694:{
        8:  695:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -:  696:    int16                       RegIndex;
        8:  697:    const CFE_TBL_DumpCmd_t    *CmdPtr = (const CFE_TBL_DumpCmd_t *) MessagePtr;
        -:  698:    char                        DumpFilename[OS_MAX_PATH_LEN];
        -:  699:    char                        TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -:  700:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        8:  701:    void                       *DumpDataAddr = NULL;
        -:  702:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
        -:  703:    int32                       DumpIndex;
        -:  704:    int32                       Status;
        -:  705:    CFE_TBL_DumpControl_t      *DumpCtrlPtr;
        -:  706:
        -:  707:    /* Make sure all strings are null terminated before attempting to process them */
        8:  708:    CFE_PSP_MemCpy(DumpFilename, (void *)CmdPtr->DumpFilename, OS_MAX_PATH_LEN);
        8:  709:    DumpFilename[OS_MAX_PATH_LEN-1] = '\0';
        -:  710:
        8:  711:    CFE_PSP_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        8:  712:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -:  713:
        -:  714:    /* Before doing anything, lets make sure the table that is to be dumped exists */
        8:  715:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -:  716:
        8:  717:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -:  718:    {
        -:  719:        /* Obtain a pointer to registry information about specified table */
        7:  720:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -:  721:
        -:  722:        /* Determine what data is to be dumped */
        7:  723:        if (CmdPtr->ActiveTblFlag == CFE_TBL_ACTIVE_BUFFER)
        -:  724:        {
        3:  725:            DumpDataAddr = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr;
        -:  726:        }
        4:  727:        else if (CmdPtr->ActiveTblFlag == CFE_TBL_INACTIVE_BUFFER)/* Dumping Inactive Buffer */
        -:  728:        {
        -:  729:            /* If this is a double buffered table, locating the inactive buffer is trivial */
        3:  730:            if (RegRecPtr->DblBuffered)
        -:  731:            {
        1:  732:                DumpDataAddr = RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr;
        -:  733:            }
        -:  734:            else
        -:  735:            {
        -:  736:                /* For single buffered tables, the index to the inactive buffer is kept in 'LoadInProgress' */
        -:  737:                /* Unless this is a table whose address was defined by the owning Application.              */
        3:  738:                if ((RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS) && (!RegRecPtr->UserDefAddr))
        -:  739:                {
        1:  740:                    DumpDataAddr = CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr;
        -:  741:                }
        -:  742:                else
        -:  743:                {
        1:  744:                    CFE_EVS_SendEvent(CFE_TBL_NO_INACTIVE_BUFFER_ERR_EID,
        -:  745:                                      CFE_EVS_ERROR,
        -:  746:                                      "No Inactive Buffer for Table '%s' present",
        -:  747:                                      TableName);
        -:  748:                }
        -:  749:            }
        -:  750:        }
        -:  751:        else
        -:  752:        {
        1:  753:            CFE_EVS_SendEvent(CFE_TBL_ILLEGAL_BUFF_PARAM_ERR_EID,
        -:  754:                              CFE_EVS_ERROR,
        -:  755:                              "Cmd for Table '%s' had illegal buffer parameter (0x%08X)",
        1:  756:                              TableName, CmdPtr->ActiveTblFlag);
        -:  757:        }
        -:  758:
        -:  759:        /* If we have located the data to be dumped, then proceed with creating the file and dumping the data */
        7:  760:        if (DumpDataAddr != NULL)
        -:  761:        {
        -:  762:            /* If this is not a dump only table, then we can perform the dump immediately */
        5:  763:            if (!RegRecPtr->DumpOnly)
        -:  764:            {
        1:  765:                ReturnCode = CFE_TBL_DumpToFile(DumpFilename, TableName, DumpDataAddr, RegRecPtr->Size);
        -:  766:            }
        -:  767:            else /* Dump Only tables need to synchronize their dumps with the owner's execution */
        -:  768:            {
        -:  769:                /* Make sure a dump is not already in progress */
        4:  770:                if (RegRecPtr->DumpControlIndex == CFE_TBL_NO_DUMP_PENDING)
        -:  771:                {
        -:  772:                    /* Find a free Dump Control Block */
        3:  773:                    DumpIndex = 0;
       18:  774:                    while ((DumpIndex < CFE_TBL_MAX_SIMULTANEOUS_LOADS) &&
        7:  775:                           (CFE_TBL_TaskData.DumpControlBlocks[DumpIndex].State != CFE_TBL_DUMP_FREE))
        -:  776:                    {
        5:  777:                        DumpIndex++;
        -:  778:                    }
        -:  779:
        3:  780:                    if (DumpIndex < CFE_TBL_MAX_SIMULTANEOUS_LOADS)
        -:  781:                    {
        -:  782:                        /* Allocate a shared memory buffer for storing the data to be dumped */
        2:  783:                        Status = CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, FALSE);
        -:  784:
        2:  785:                        if (Status == CFE_SUCCESS)
        -:  786:                        {
        1:  787:                            DumpCtrlPtr = &CFE_TBL_TaskData.DumpControlBlocks[DumpIndex];
        1:  788:                            DumpCtrlPtr->State = CFE_TBL_DUMP_PENDING;
        1:  789:                            DumpCtrlPtr->RegRecPtr = RegRecPtr;
        -:  790:
        -:  791:                            /* Save the name of the desired dump filename, table name and size for later */
        1:  792:                            DumpCtrlPtr->DumpBufferPtr = WorkingBufferPtr;
        1:  793:                            CFE_PSP_MemCpy(DumpCtrlPtr->DumpBufferPtr->DataSource, DumpFilename, OS_MAX_PATH_LEN);
        1:  794:                            CFE_PSP_MemCpy(DumpCtrlPtr->TableName, TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        1:  795:                            DumpCtrlPtr->Size = RegRecPtr->Size;
        -:  796:
        -:  797:                            /* Notify the owning application that a dump is pending */
        1:  798:                            RegRecPtr->DumpControlIndex = DumpIndex;
        -:  799:
        -:  800:                            /* If application requested notification by message, then do so */
        1:  801:                            CFE_TBL_SendNotificationMsg(RegRecPtr);
        -:  802:
        -:  803:                            /* Consider the command completed successfully */
        1:  804:                            ReturnCode = CFE_TBL_INC_CMD_CTR;
        -:  805:                        }
        -:  806:                        else
        -:  807:                        {
        1:  808:                            CFE_EVS_SendEvent(CFE_TBL_NO_WORK_BUFFERS_ERR_EID,
        -:  809:                                              CFE_EVS_ERROR,
        -:  810:                                              "No working buffers available for table '%s'",
        -:  811:                                              TableName);
        -:  812:                        }
        -:  813:                    }
        -:  814:                    else
        -:  815:                    {
        1:  816:                        CFE_EVS_SendEvent(CFE_TBL_TOO_MANY_DUMPS_ERR_EID,
        -:  817:                                          CFE_EVS_ERROR,
        -:  818:                                          "Too many Dump Only Table Dumps have been requested");
        -:  819:                    }
        -:  820:                }
        -:  821:                else
        -:  822:                {
        1:  823:                    CFE_EVS_SendEvent(CFE_TBL_DUMP_PENDING_ERR_EID,
        -:  824:                                      CFE_EVS_ERROR,
        -:  825:                                      "A dump for '%s' is already pending",
        -:  826:                                      TableName);
        -:  827:                }
        -:  828:            }
        -:  829:        }
        -:  830:    }
        -:  831:    else /* Table could not be found in Registry */
        -:  832:    {
        1:  833:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -:  834:                          CFE_EVS_ERROR,
        -:  835:                          "Unable to locate '%s' in Table Registry",
        -:  836:                          TableName);
        -:  837:    }
        -:  838:
        8:  839:    return ReturnCode;
        -:  840:
        -:  841:} /* End of CFE_TBL_DumpCmd() */
        -:  842:
        -:  843:
        -:  844:/*******************************************************************
        -:  845:**
        -:  846:** CFE_TBL_DumpToFile() -- Write table data to a file
        -:  847:**
        -:  848:** NOTE: For complete prolog information, see prototype above
        -:  849:********************************************************************/
        -:  850:
        9:  851:CFE_TBL_CmdProcRet_t CFE_TBL_DumpToFile( char *DumpFilename, char *TableName, void *DumpDataAddr, uint32 TblSizeInBytes)
        -:  852:{
        9:  853:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        9:  854:    boolean                     FileExistedPrev = FALSE;
        -:  855:    CFE_FS_Header_t             StdFileHeader;
        -:  856:    CFE_TBL_File_Hdr_t          TblFileHeader;
        -:  857:    int32                       FileDescriptor;
        -:  858:    int32                       Status;
        9:  859:    int32                       EndianCheck = 0x01020304;
        -:  860:
        -:  861:    /* Clear Header of any garbage before copying content */
        9:  862:    CFE_PSP_MemSet(&StdFileHeader, 0, sizeof(CFE_FS_Header_t));
        9:  863:    CFE_PSP_MemSet(&TblFileHeader, 0, sizeof(CFE_TBL_File_Hdr_t));
        -:  864:
        -:  865:    /* Check to see if the dump file already exists */
        9:  866:    FileDescriptor = OS_open(DumpFilename, OS_READ_ONLY, 0);
        -:  867:
        9:  868:    if (FileDescriptor >= 0)
        -:  869:    {
        7:  870:        FileExistedPrev = TRUE;
        -:  871:
        7:  872:        OS_close(FileDescriptor);
        -:  873:    }
        -:  874:
        -:  875:    /* Create a new dump file, overwriting anything that may have existed previously */
        9:  876:    FileDescriptor = OS_creat(DumpFilename, OS_WRITE_ONLY);
        -:  877:
        9:  878:    if (FileDescriptor >= OS_FS_SUCCESS)
        -:  879:    {
        -:  880:        /* Initialize the standard cFE File Header for the Dump File */
        8:  881:        StdFileHeader.SubType = CFE_FS_TBL_IMG_SUBTYPE;
        8:  882:        strcpy(&StdFileHeader.Description[0], "Table Dump Image");
        -:  883:
        -:  884:        /* Output the Standard cFE File Header to the Dump File */
        8:  885:        Status = CFE_FS_WriteHeader(FileDescriptor, &StdFileHeader);
        -:  886:
        8:  887:        if (Status == sizeof(CFE_FS_Header_t))
        -:  888:        {
        -:  889:            /* Initialize the Table Image Header for the Dump File */
        7:  890:            CFE_PSP_MemCpy(TblFileHeader.TableName, TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        7:  891:            TblFileHeader.Offset = 0;
        7:  892:            TblFileHeader.NumBytes = TblSizeInBytes;
        7:  893:            TblFileHeader.Reserved = 0;
        -:  894:
        -:  895:            /* Determine if this is a little endian processor */
        7:  896:            if ((*(char *)&EndianCheck) == 0x04)
        -:  897:            {
        -:  898:                /* If this is a little endian processor, then byte swap the header to a big endian format */
        -:  899:                /* to maintain the cFE Header standards */
        -:  900:                /* NOTE: FOR THE REMAINDER OF THIS FUNCTION, THE CONTENTS OF THE HEADER IS UNREADABLE BY */
        -:  901:                /*       THIS PROCESSOR!  THE DATA WOULD NEED TO BE SWAPPED BACK BEFORE READING.         */
        7:  902:                CFE_TBL_ByteSwapTblHeader(&TblFileHeader);
        -:  903:            }
        -:  904:
        -:  905:            /* Output the Table Image Header to the Dump File */
        7:  906:            Status = OS_write(FileDescriptor, &TblFileHeader, sizeof(CFE_TBL_File_Hdr_t));
        -:  907:
        -:  908:            /* Make sure the header was output completely */
        7:  909:            if (Status == sizeof(CFE_TBL_File_Hdr_t))
        -:  910:            {
        -:  911:                /* Output the requested data to the dump file */
        -:  912:                /* Output the active table image data to the dump file */
        6:  913:                Status = OS_write(FileDescriptor,
        -:  914:                                  DumpDataAddr,
        -:  915:                                  TblSizeInBytes);
        -:  916:
        6:  917:                if (Status == (int32)TblSizeInBytes)
        -:  918:                {
        5:  919:                    if (FileExistedPrev)
        -:  920:                    {
        3:  921:                        CFE_EVS_SendEvent(CFE_TBL_OVERWRITE_DUMP_INF_EID,
        -:  922:                                          CFE_EVS_INFORMATION,
        -:  923:                                          "Successfully overwrote '%s' with Table '%s'",
        -:  924:                                          DumpFilename, TableName);
        -:  925:                    }
        -:  926:                    else
        -:  927:                    {
        2:  928:                        CFE_EVS_SendEvent(CFE_TBL_WRITE_DUMP_INF_EID,
        -:  929:                                          CFE_EVS_INFORMATION,
        -:  930:                                          "Successfully dumped Table '%s' to '%s'",
        -:  931:                                          TableName, DumpFilename);
        -:  932:                    }
        -:  933:
        -:  934:                    /* Save file information statistics for housekeeping telemetry */
        5:  935:                    CFE_PSP_MemCpy(CFE_TBL_TaskData.HkPacket.LastFileDumped, DumpFilename, OS_MAX_PATH_LEN);
        -:  936:
        -:  937:                    /* Increment Successful Command Counter */
        5:  938:                    ReturnCode = CFE_TBL_INC_CMD_CTR;
        -:  939:                }
        -:  940:                else
        -:  941:                {
        1:  942:                    CFE_EVS_SendEvent(CFE_TBL_WRITE_TBL_IMG_ERR_EID,
        -:  943:                                      CFE_EVS_ERROR,
        -:  944:                                      "Error writing Tbl image to '%s', Status=0x%08X",
        -:  945:                                      DumpFilename, Status);
        -:  946:                }
        -:  947:            }
        -:  948:            else
        -:  949:            {
        1:  950:                CFE_EVS_SendEvent(CFE_TBL_WRITE_TBL_HDR_ERR_EID,
        -:  951:                                  CFE_EVS_ERROR,
        -:  952:                                  "Error writing Tbl image File Header to '%s', Status=0x%08X",
        -:  953:                                  DumpFilename, Status);
        -:  954:            }
        -:  955:        }
        -:  956:        else
        -:  957:        {
        1:  958:            CFE_EVS_SendEvent(CFE_TBL_WRITE_CFE_HDR_ERR_EID,
        -:  959:                              CFE_EVS_ERROR,
        -:  960:                              "Error writing cFE File Header to '%s', Status=0x%08X",
        -:  961:                              DumpFilename, Status);
        -:  962:        }
        -:  963:
        -:  964:        /* We are done outputting data to the dump file.  Close it. */
        8:  965:        OS_close(FileDescriptor);
        -:  966:    }
        -:  967:    else
        -:  968:    {
        1:  969:        CFE_EVS_SendEvent(CFE_TBL_CREATING_DUMP_FILE_ERR_EID,
        -:  970:                          CFE_EVS_ERROR,
        -:  971:                          "Error creating dump file '%s', Status=0x%08X",
        -:  972:                          DumpFilename, FileDescriptor);
        -:  973:    }
        -:  974:
        9:  975:    return ReturnCode;
        -:  976:}
        -:  977:
        -:  978:/*******************************************************************
        -:  979:**
        -:  980:** CFE_TBL_ValidateCmd() -- Process Validate Table Command Message
        -:  981:**
        -:  982:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  983:********************************************************************/
        -:  984:
        8:  985:CFE_TBL_CmdProcRet_t CFE_TBL_ValidateCmd( const CFE_SB_Msg_t *MessagePtr )
        -:  986:{
        8:  987:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -:  988:    int16                        RegIndex;
        8:  989:    const CFE_TBL_ValidateCmd_t *CmdPtr = (const CFE_TBL_ValidateCmd_t *) MessagePtr;
        -:  990:    CFE_TBL_RegistryRec_t       *RegRecPtr;
        8:  991:    void                        *ValidationDataPtr = NULL;
        -:  992:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -:  993:    uint32                       CrcOfTable;
        -:  994:    int32                        ValIndex;
        -:  995:
        -:  996:    /* Make sure all strings are null terminated before attempting to process them */
        8:  997:    CFE_PSP_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        8:  998:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -:  999:
        -: 1000:    /* Before doing anything, lets make sure the table that is to be dumped exists */
        8: 1001:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1002:
        8: 1003:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -: 1004:    {
        -: 1005:        /* Obtain a pointer to registry information about specified table */
        7: 1006:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -: 1007:
        -: 1008:        /* Determine what data is to be validated */
        7: 1009:        if (CmdPtr->ActiveTblFlag == CFE_TBL_ACTIVE_BUFFER)
        -: 1010:        {
        3: 1011:            ValidationDataPtr = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr;
        -: 1012:        }
        4: 1013:        else if (CmdPtr->ActiveTblFlag == CFE_TBL_INACTIVE_BUFFER) /* Validating Inactive Buffer */
        -: 1014:        {
        -: 1015:            /* If this is a double buffered table, locating the inactive buffer is trivial */
        3: 1016:            if (RegRecPtr->DblBuffered)
        -: 1017:            {
        1: 1018:                ValidationDataPtr = RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr;
        -: 1019:            }
        -: 1020:            else
        -: 1021:            {
        -: 1022:                /* For single buffered tables, the index to the inactive buffer is kept in 'LoadInProgress' */
        2: 1023:                if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -: 1024:                {
        1: 1025:                    ValidationDataPtr = CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr;
        -: 1026:                }
        -: 1027:                else
        -: 1028:                {
        1: 1029:                    CFE_EVS_SendEvent(CFE_TBL_NO_INACTIVE_BUFFER_ERR_EID,
        -: 1030:                                      CFE_EVS_ERROR,
        -: 1031:                                      "No Inactive Buffer for Table '%s' present",
        -: 1032:                                      TableName);
        -: 1033:                }
        -: 1034:            }
        -: 1035:        }
        -: 1036:        else
        -: 1037:        {
        1: 1038:            CFE_EVS_SendEvent(CFE_TBL_ILLEGAL_BUFF_PARAM_ERR_EID,
        -: 1039:                              CFE_EVS_ERROR,
        -: 1040:                              "Cmd for Table '%s' had illegal buffer parameter (0x%08X)",
        1: 1041:                              TableName, CmdPtr->ActiveTblFlag);
        -: 1042:        }
        -: 1043:
        -: 1044:        /* If we have located the data to be validated, then proceed with notifying the application, if */
        -: 1045:        /* necessary, and computing the CRC value for the block of memory                               */
        7: 1046:        if (ValidationDataPtr != NULL)
        -: 1047:        {
        -: 1048:            /* Find a free Validation Response Block */
        5: 1049:            ValIndex = 0;
       34: 1050:            while ((ValIndex < CFE_TBL_MAX_NUM_VALIDATIONS) &&
       14: 1051:                   (CFE_TBL_TaskData.ValidationResults[ValIndex].State != CFE_TBL_VALIDATION_FREE))
        -: 1052:            {
       10: 1053:                ValIndex++;
        -: 1054:            }
        -: 1055:
        5: 1056:            if (ValIndex < CFE_TBL_MAX_NUM_VALIDATIONS)
        -: 1057:            {
        -: 1058:                /* Allocate this Validation Response Block */
        4: 1059:                CFE_TBL_TaskData.ValidationResults[ValIndex].State = CFE_TBL_VALIDATION_PENDING;
        4: 1060:                CFE_TBL_TaskData.ValidationResults[ValIndex].Result = 0;
        4: 1061:                CFE_PSP_MemCpy(CFE_TBL_TaskData.ValidationResults[ValIndex].TableName,
        -: 1062:                          TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        -: 1063:
        -: 1064:                /* Compute the CRC on the specified table buffer */
        4: 1065:                CrcOfTable = CFE_ES_CalculateCRC(ValidationDataPtr,
        -: 1066:                                                 RegRecPtr->Size,
        -: 1067:                                                 0,
        -: 1068:                                                 CFE_ES_DEFAULT_CRC);
        -: 1069:
        4: 1070:                CFE_TBL_TaskData.ValidationResults[ValIndex].CrcOfTable = CrcOfTable;
        4: 1071:                CFE_TBL_TaskData.ValidationResults[ValIndex].ActiveBuffer = (CmdPtr->ActiveTblFlag != 0);
        -: 1072:
        -: 1073:                /* If owner has a validation function, then notify the  */
        -: 1074:                /* table owner that there is data to be validated       */
        4: 1075:                if (RegRecPtr->ValidationFuncPtr != NULL)
        -: 1076:                {
        3: 1077:                    if (CmdPtr->ActiveTblFlag)
        -: 1078:                    {
        1: 1079:                        RegRecPtr->ValidateActiveIndex = ValIndex;
        -: 1080:                    }
        -: 1081:                    else
        -: 1082:                    {
        2: 1083:                        RegRecPtr->ValidateInactiveIndex = ValIndex;
        -: 1084:                    }
        -: 1085:
        -: 1086:                    /* If application requested notification by message, then do so */
        3: 1087:                    if (CFE_TBL_SendNotificationMsg(RegRecPtr) == CFE_SUCCESS)
        -: 1088:                    {
        -: 1089:                        /* Notify ground that validation request has been made */
        3: 1090:                        CFE_EVS_SendEvent(CFE_TBL_VAL_REQ_MADE_INF_EID,
        -: 1091:                                          CFE_EVS_DEBUG,
        -: 1092:                                          "Tbl Services issued validation request for '%s'",
        -: 1093:                                          TableName);
        -: 1094:                    }
        -: 1095:
        -: 1096:                    /* Maintain statistic on number of validation requests given to applications */
        3: 1097:                    CFE_TBL_TaskData.NumValRequests++;
        -: 1098:                }
        -: 1099:                else
        -: 1100:                {
        -: 1101:                    /* If there isn't a validation function pointer, then the process is complete  */
        -: 1102:                    /* By setting this value, we are letting the Housekeeping process recognize it */
        -: 1103:                    /* as data to be sent to the ground in telemetry.                              */
        1: 1104:                    CFE_TBL_TaskData.ValidationResults[ValIndex].State = CFE_TBL_VALIDATION_PERFORMED;
        -: 1105:
        1: 1106:                    CFE_EVS_SendEvent(CFE_TBL_ASSUMED_VALID_INF_EID,
        -: 1107:                                      CFE_EVS_INFORMATION,
        -: 1108:                                      "Tbl Services assumes '%s' is valid. No Validation Function has been registered",
        -: 1109:                                      TableName);
        -: 1110:                }
        -: 1111:
        -: 1112:                /* Increment Successful Command Counter */
        4: 1113:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1114:            }
        -: 1115:            else
        -: 1116:            {
        1: 1117:                CFE_EVS_SendEvent(CFE_TBL_TOO_MANY_VALIDATIONS_ERR_EID,
        -: 1118:                                  CFE_EVS_ERROR,
        -: 1119:                                  "Too many Table Validations have been requested");
        -: 1120:            }
        -: 1121:        }
        -: 1122:    }
        -: 1123:    else /* Table could not be found in Registry */
        -: 1124:    {
        1: 1125:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1126:                          CFE_EVS_ERROR,
        -: 1127:                          "Unable to locate '%s' in Table Registry",
        -: 1128:                          TableName);
        -: 1129:    }
        -: 1130:
        8: 1131:    return ReturnCode;
        -: 1132:
        -: 1133:} /* End of CFE_TBL_ValidateCmd() */
        -: 1134:
        -: 1135:
        -: 1136:/*******************************************************************
        -: 1137:**
        -: 1138:** CFE_TBL_ActivateCmd() -- Process Activate Table Command Message
        -: 1139:**
        -: 1140:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1141:********************************************************************/
        -: 1142:
        5: 1143:CFE_TBL_CmdProcRet_t CFE_TBL_ActivateCmd( const CFE_SB_Msg_t *MessagePtr )
        -: 1144:{
        5: 1145:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -: 1146:    int16                        RegIndex;
        5: 1147:    const CFE_TBL_ActivateCmd_t *CmdPtr = (const CFE_TBL_ActivateCmd_t *) MessagePtr;
        -: 1148:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -: 1149:    CFE_TBL_RegistryRec_t       *RegRecPtr;
        5: 1150:    boolean                      ValidationStatus = FALSE;
        -: 1151:
        -: 1152:    /* Make sure all strings are null terminated before attempting to process them */
        5: 1153:    CFE_PSP_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        5: 1154:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1155:
        -: 1156:    /* Before doing anything, lets make sure the table that is to be dumped exists */
        5: 1157:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1158:
        5: 1159:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -: 1160:    {
        -: 1161:        /* Obtain a pointer to registry information about specified table */
        4: 1162:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -: 1163:
        4: 1164:        if (RegRecPtr->DumpOnly)
        -: 1165:        {
        1: 1166:            CFE_EVS_SendEvent(CFE_TBL_ACTIVATE_DUMP_ONLY_ERR_EID,
        -: 1167:                              CFE_EVS_ERROR,
        -: 1168:                              "Illegal attempt to activate dump-only table '%s'",
        -: 1169:                              TableName);
        -: 1170:        }
        3: 1171:        else if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -: 1172:        {
        -: 1173:            /* Determine if the inactive buffer has been successfully validated or not */
        2: 1174:            if (RegRecPtr->DblBuffered)
        -: 1175:            {
        1: 1176:                ValidationStatus = RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].Validated;
        -: 1177:            }
        -: 1178:            else
        -: 1179:            {
        1: 1180:                ValidationStatus = CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Validated;
        -: 1181:            }
        -: 1182:
        2: 1183:            if (ValidationStatus == TRUE)
        -: 1184:            {
        1: 1185:                CFE_TBL_TaskData.Registry[RegIndex].LoadPending = TRUE;
        -: 1186:
        -: 1187:                /* If application requested notification by message, then do so */
        1: 1188:                if (CFE_TBL_SendNotificationMsg(RegRecPtr) == CFE_SUCCESS)
        -: 1189:                {
        1: 1190:                    CFE_EVS_SendEvent(CFE_TBL_LOAD_PEND_REQ_INF_EID,
        -: 1191:                                      CFE_EVS_DEBUG,
        -: 1192:                                      "Tbl Services notifying App that '%s' has a load pending",
        -: 1193:                                      TableName);
        -: 1194:                }
        -: 1195:
        -: 1196:                /* Increment Successful Command Counter */
        1: 1197:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1198:            }
        -: 1199:            else
        -: 1200:            {
        1: 1201:                CFE_EVS_SendEvent(CFE_TBL_UNVALIDATED_ERR_EID,
        -: 1202:                                  CFE_EVS_ERROR,
        -: 1203:                                  "Cannot activate table '%s'. Inactive image not Validated",
        -: 1204:                                  TableName);
        -: 1205:            }
        -: 1206:        }
        -: 1207:        else
        -: 1208:        {
        1: 1209:            CFE_EVS_SendEvent(CFE_TBL_ACTIVATE_ERR_EID,
        -: 1210:                              CFE_EVS_ERROR,
        -: 1211:                              "Cannot activate table '%s'. No Inactive image available",
        -: 1212:                              TableName);
        -: 1213:        }
        -: 1214:    }
        -: 1215:    else /* Table could not be found in Registry */
        -: 1216:    {
        1: 1217:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1218:                          CFE_EVS_ERROR,
        -: 1219:                          "Unable to locate '%s' in Table Registry",
        -: 1220:                          TableName);
        -: 1221:    }
        -: 1222:
        5: 1223:    return ReturnCode;
        -: 1224:
        -: 1225:} /* End of CFE_TBL_ActivateCmd() */
        -: 1226:
        -: 1227:
        -: 1228:/*******************************************************************
        -: 1229:**
        -: 1230:** CFE_TBL_DumpRegCmd() -- Process Dump Table Registry to file Command Message
        -: 1231:**
        -: 1232:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1233:********************************************************************/
        -: 1234:
        5: 1235:CFE_TBL_CmdProcRet_t CFE_TBL_DumpRegCmd( const CFE_SB_Msg_t *MessagePtr )
        -: 1236:{
        5: 1237:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        5: 1238:    boolean                     FileExistedPrev = FALSE;
        -: 1239:    CFE_FS_Header_t             StdFileHeader;
        -: 1240:    int32                       FileDescriptor;
        -: 1241:    int32                       Status;
        5: 1242:    int16                       RegIndex=0;
        5: 1243:    const CFE_TBL_DumpRegCmd_t *CmdPtr = (const CFE_TBL_DumpRegCmd_t *) MessagePtr;
        -: 1244:    char                        DumpFilename[OS_MAX_PATH_LEN];
        -: 1245:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -: 1246:    CFE_TBL_Handle_t            HandleIterator;
        -: 1247:    CFE_TBL_RegDumpRec_t        DumpRecord;
        5: 1248:    int32                       FileSize=0;
        5: 1249:    int32                       NumEntries=0;
        -: 1250:
        -: 1251:    /* Copy the commanded filename into local buffer to ensure size limitation and to allow for modification */
        5: 1252:    CFE_PSP_MemCpy(DumpFilename, (void *)CmdPtr->DumpFilename, OS_MAX_PATH_LEN);
        -: 1253:
        -: 1254:    /* Check to see if a default filename should be used */
        5: 1255:    if (DumpFilename[0] == '\0')
        -: 1256:    {
        5: 1257:        strncpy(DumpFilename, CFE_TBL_DEFAULT_REG_DUMP_FILE, OS_MAX_PATH_LEN);
        -: 1258:    }
        -: 1259:
        -: 1260:    /* Make sure all strings are null terminated before attempting to process them */
        5: 1261:    DumpFilename[OS_MAX_PATH_LEN-1] = '\0';
        -: 1262:
        -: 1263:    /* Check to see if the dump file already exists */
        5: 1264:    FileDescriptor = OS_open(DumpFilename, OS_READ_ONLY, 0);
        -: 1265:
        5: 1266:    if (FileDescriptor >= 0)
        -: 1267:    {
        4: 1268:        FileExistedPrev = TRUE;
        -: 1269:
        4: 1270:        OS_close(FileDescriptor);
        -: 1271:    }
        -: 1272:
        -: 1273:    /* Create a new dump file, overwriting anything that may have existed previously */
        5: 1274:    FileDescriptor = OS_creat(DumpFilename, OS_WRITE_ONLY);
        -: 1275:
        5: 1276:    if (FileDescriptor >= OS_FS_SUCCESS)
        -: 1277:    {
        -: 1278:        /* Initialize the standard cFE File Header for the Dump File */
        4: 1279:        StdFileHeader.SubType = CFE_FS_TBL_REG_SUBTYPE;
        4: 1280:        strcpy(&StdFileHeader.Description[0], "Table Registry");
        -: 1281:
        -: 1282:        /* Output the Standard cFE File Header to the Dump File */
        4: 1283:        Status = CFE_FS_WriteHeader(FileDescriptor, &StdFileHeader);
        -: 1284:
        -: 1285:        /* Maintain statistics of amount of data written to file */
        4: 1286:        FileSize += Status;
        -: 1287:
        4: 1288:        if (Status == sizeof(CFE_FS_Header_t))
        -: 1289:        {
        3: 1290:            Status = sizeof(CFE_TBL_RegDumpRec_t);
      263: 1291:            while ((RegIndex < CFE_TBL_MAX_NUM_TABLES) && (Status == sizeof(CFE_TBL_RegDumpRec_t)))
        -: 1292:            {
        -: 1293:                /* Make a pointer to simplify code look and to remove redundant indexing into registry */
      257: 1294:                RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -: 1295:
        -: 1296:                /* Check to see if the Registry entry is empty */
      260: 1297:                if ((RegRecPtr->OwnerAppId != CFE_TBL_NOT_OWNED) ||
        3: 1298:                    (RegRecPtr->HeadOfAccessList != CFE_TBL_END_OF_LIST))
        -: 1299:                {
        -: 1300:                    /* Fill Registry Dump Record with relevant information */
      255: 1301:                    DumpRecord.Size             = RegRecPtr->Size;
      255: 1302:                    DumpRecord.TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
      255: 1303:                    DumpRecord.LoadInProgress   = RegRecPtr->LoadInProgress;
      255: 1304:                    DumpRecord.ValidationFunc   = (RegRecPtr->ValidationFuncPtr != NULL);
      255: 1305:                    DumpRecord.TableLoadedOnce  = RegRecPtr->TableLoadedOnce;
      255: 1306:                    DumpRecord.LoadPending      = RegRecPtr->LoadPending;
      255: 1307:                    DumpRecord.DumpOnly         = RegRecPtr->DumpOnly;
      255: 1308:                    DumpRecord.DblBuffered      = RegRecPtr->DblBuffered;
      255: 1309:                    DumpRecord.FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
      255: 1310:                    DumpRecord.FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
      255: 1311:                    DumpRecord.Crc              = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].Crc;
      255: 1312:                    DumpRecord.CriticalTable    = RegRecPtr->CriticalTable;
        -: 1313:
        -: 1314:                    /* Convert LoadInProgress flag into more meaningful information */
        -: 1315:                    /* When a load is in progress, identify which buffer is being used as the inactive buffer */
      255: 1316:                    if (DumpRecord.LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -: 1317:                    {
      255: 1318:                        if (DumpRecord.DblBuffered)
        -: 1319:                        {
        -: 1320:                            /* For double buffered tables, the value of LoadInProgress, when a load is actually in progress, */
        -: 1321:                            /* should identify either buffer #0 or buffer #1.  Convert these to enumerated value for ground  */
        -: 1322:                            /* display.  LoadInProgress = -2 means Buffer #1, LoadInProgress = -3 means Buffer #0.           */
        3: 1323:                            DumpRecord.LoadInProgress = DumpRecord.LoadInProgress - 3;
        -: 1324:                        }
        -: 1325:                        /* For single buffered tables, the value of LoadInProgress, when a load is actually in progress,     */
        -: 1326:                        /* indicates which shared buffer is allocated for the inactive buffer.  Since the number of inactive */
        -: 1327:                        /* buffers is a platform configuration parameter, then 0 on up merely identifies the buffer number.  */
        -: 1328:                        /* No translation is necessary for single buffered tables.                                           */
        -: 1329:                    }
        -: 1330:
        -: 1331:                    /* Zero character arrays to remove garbage text */
      255: 1332:                    CFE_PSP_MemSet(DumpRecord.Name, 0, CFE_TBL_MAX_FULL_NAME_LEN);
      255: 1333:                    CFE_PSP_MemSet(DumpRecord.LastFileLoaded, 0, OS_MAX_PATH_LEN);
      255: 1334:                    CFE_PSP_MemSet(DumpRecord.OwnerAppName, 0, OS_MAX_API_NAME);
        -: 1335:
      255: 1336:                    strncpy(DumpRecord.Name, RegRecPtr->Name, CFE_TBL_MAX_FULL_NAME_LEN);
      255: 1337:                    strncpy(DumpRecord.LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        -: 1338:
        -: 1339:                    /* Walk the access descriptor list to determine the number of users */
      255: 1340:                    DumpRecord.NumUsers = 0;
      255: 1341:                    HandleIterator = RegRecPtr->HeadOfAccessList;
      511: 1342:                    while (HandleIterator != CFE_TBL_END_OF_LIST)
        -: 1343:                    {
        1: 1344:                        DumpRecord.NumUsers++;
        1: 1345:                        HandleIterator = CFE_TBL_TaskData.Handles[HandleIterator].NextLink;
        -: 1346:                    }
        -: 1347:
        -: 1348:                    /* Determine the name of the owning application */
      255: 1349:                    if (RegRecPtr->OwnerAppId != CFE_TBL_NOT_OWNED)
        -: 1350:                    {
      254: 1351:                        CFE_ES_GetAppName(DumpRecord.OwnerAppName, RegRecPtr->OwnerAppId, OS_MAX_API_NAME);
        -: 1352:                    }
        -: 1353:                    else
        -: 1354:                    {
        1: 1355:                        strncpy(DumpRecord.OwnerAppName, "--UNOWNED--", OS_MAX_API_NAME);
        -: 1356:                    }
        -: 1357:
        -: 1358:                    /* Output Registry Dump Record to Registry Dump File */
      255: 1359:                    Status = OS_write(FileDescriptor,
        -: 1360:                                      &DumpRecord,
        -: 1361:                                      sizeof(CFE_TBL_RegDumpRec_t));
        -: 1362:
      255: 1363:                    FileSize += Status;
      255: 1364:                    NumEntries++;
        -: 1365:                }
        -: 1366:
        -: 1367:                /* Look at the next entry in the Registry */
      257: 1368:                RegIndex++;
        -: 1369:            }
        -: 1370:
        3: 1371:            if (Status == sizeof(CFE_TBL_RegDumpRec_t))
        -: 1372:            {
        2: 1373:                if (FileExistedPrev)
        -: 1374:                {
        1: 1375:                    CFE_EVS_SendEvent(CFE_TBL_OVERWRITE_REG_DUMP_INF_EID,
        -: 1376:                                      CFE_EVS_DEBUG,
        -: 1377:                                      "Successfully overwrote '%s' with Table Registry:Size=%d,Entries=%d",
        -: 1378:                                      DumpFilename, FileSize, NumEntries);
        -: 1379:                }
        -: 1380:                else
        -: 1381:                {
        1: 1382:                    CFE_EVS_SendEvent(CFE_TBL_WRITE_REG_DUMP_INF_EID,
        -: 1383:                                      CFE_EVS_DEBUG,
        -: 1384:                                      "Successfully dumped Table Registry to '%s':Size=%d,Entries=%d",
        -: 1385:                                      DumpFilename, FileSize, NumEntries);
        -: 1386:                }
        -: 1387:
        -: 1388:                /* Increment Successful Command Counter */
        2: 1389:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1390:            }
        -: 1391:            else
        -: 1392:            {
        1: 1393:                CFE_EVS_SendEvent(CFE_TBL_WRITE_TBL_REG_ERR_EID,
        -: 1394:                                  CFE_EVS_ERROR,
        -: 1395:                                  "Error writing Registry to '%s', Status=0x%08X",
        -: 1396:                                  DumpFilename, Status);
        -: 1397:            }
        -: 1398:        }
        -: 1399:        else
        -: 1400:        {
        1: 1401:            CFE_EVS_SendEvent(CFE_TBL_WRITE_CFE_HDR_ERR_EID,
        -: 1402:                              CFE_EVS_ERROR,
        -: 1403:                              "Error writing cFE File Header to '%s', Status=0x%08X",
        -: 1404:                              DumpFilename, Status);
        -: 1405:        }
        -: 1406:
        -: 1407:        /* We are done outputting data to the dump file.  Close it. */
        4: 1408:        OS_close(FileDescriptor);
        -: 1409:    }
        -: 1410:    else
        -: 1411:    {
        1: 1412:        CFE_EVS_SendEvent(CFE_TBL_CREATING_DUMP_FILE_ERR_EID,
        -: 1413:                          CFE_EVS_ERROR,
        -: 1414:                          "Error creating dump file '%s', Status=0x%08X",
        -: 1415:                          DumpFilename, FileDescriptor);
        -: 1416:    }
        -: 1417:
        5: 1418:    return ReturnCode;
        -: 1419:
        -: 1420:} /* End of CFE_TBL_DumpRegCmd() */
        -: 1421:
        -: 1422:
        -: 1423:/*******************************************************************
        -: 1424:**
        -: 1425:** CFE_TBL_TlmRegCmd() -- Process Telemeter Table Registry Entry Command Message
        -: 1426:**
        -: 1427:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1428:********************************************************************/
        -: 1429:
        2: 1430:CFE_TBL_CmdProcRet_t CFE_TBL_TlmRegCmd( const CFE_SB_Msg_t *MessagePtr )
        -: 1431:{
        2: 1432:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -: 1433:    int16                        RegIndex;
        2: 1434:    const CFE_TBL_TlmRegCmd_t   *CmdPtr = (const CFE_TBL_TlmRegCmd_t *) MessagePtr;
        -: 1435:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -: 1436:
        -: 1437:    /* Make sure all strings are null terminated before attempting to process them */
        2: 1438:    CFE_PSP_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        2: 1439:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1440:
        -: 1441:    /* Before doing anything, lets make sure the table registry entry that is to be telemetered exists */
        2: 1442:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1443:
        2: 1444:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -: 1445:    {
        -: 1446:        /* Change the index used to identify what data is to be telemetered */
        1: 1447:        CFE_TBL_TaskData.HkTlmTblRegIndex = RegIndex;
        -: 1448:
        1: 1449:        CFE_EVS_SendEvent(CFE_TBL_TLM_REG_CMD_INF_EID,
        -: 1450:                          CFE_EVS_DEBUG,
        -: 1451:                          "Table Registry entry for '%s' will be telemetered",
        -: 1452:                          TableName);
        -: 1453:
        -: 1454:        /* Increment Successful Command Counter */
        1: 1455:        ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1456:    }
        -: 1457:    else /* Table could not be found in Registry */
        -: 1458:    {
        1: 1459:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1460:                          CFE_EVS_ERROR,
        -: 1461:                          "Unable to locate '%s' in Table Registry",
        -: 1462:                          TableName);
        -: 1463:    }
        -: 1464:
        2: 1465:    return ReturnCode;
        -: 1466:
        -: 1467:} /* End of CFE_TBL_TlmRegCmd() */
        -: 1468:
        -: 1469:
        -: 1470:/*******************************************************************
        -: 1471:**
        -: 1472:** CFE_TBL_DeleteCDSCmd() -- Process Delete Critical Table's CDS Command Message
        -: 1473:**
        -: 1474:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1475:********************************************************************/
        -: 1476:
        7: 1477:CFE_TBL_CmdProcRet_t CFE_TBL_DeleteCDSCmd( const CFE_SB_Msg_t *MessagePtr )
        -: 1478:{
        7: 1479:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        7: 1480:    const CFE_TBL_DelCDSCmd_t   *CmdPtr = (const CFE_TBL_DelCDSCmd_t *) MessagePtr;
        -: 1481:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        7: 1482:    CFE_TBL_CritRegRec_t        *CritRegRecPtr = NULL;
        -: 1483:    uint32                       i;
        -: 1484:    uint32                       RegIndex;
        -: 1485:    int32                        Status;
        -: 1486:
        -: 1487:    /* Make sure all strings are null terminated before attempting to process them */
        7: 1488:    CFE_PSP_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        7: 1489:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1490:
        -: 1491:    /* Before doing anything, lets make sure the table is no longer in the registry */
        -: 1492:    /* This would imply that the owning application has been terminated and that it */
        -: 1493:    /* is safe to delete the associated critical table image in the CDS. */
        7: 1494:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1495:
        7: 1496:    if (RegIndex == CFE_TBL_NOT_FOUND)
        -: 1497:    {
        -: 1498:        /* Find table in the Critical Table Registry */
      198: 1499:        for (i=0; i<CFE_TBL_MAX_CRITICAL_TABLES; i++)
        -: 1500:        {
      192: 1501:            if (strncmp(CFE_TBL_TaskData.CritReg[i].Name, TableName, CFE_TBL_MAX_FULL_NAME_LEN) == 0)
        -: 1502:            {
        5: 1503:                CritRegRecPtr = &CFE_TBL_TaskData.CritReg[i];
        5: 1504:                i=CFE_TBL_MAX_CRITICAL_TABLES;
        -: 1505:            }
        -: 1506:        }
        -: 1507:
        6: 1508:        if (CritRegRecPtr != NULL)
        -: 1509:        {
        5: 1510:            Status = CFE_ES_DeleteCDS(TableName, TRUE);
        -: 1511:
        5: 1512:            if (Status == CFE_ES_CDS_WRONG_TYPE_ERR)
        -: 1513:            {
        1: 1514:                CFE_EVS_SendEvent(CFE_TBL_NOT_CRITICAL_TBL_ERR_EID,
        -: 1515:                                  CFE_EVS_ERROR,
        -: 1516:                                  "Table '%s' is in Critical Table Registry but CDS is not tagged as a table",
        -: 1517:                                  TableName);
        -: 1518:            }
        4: 1519:            else if (Status == CFE_ES_CDS_OWNER_ACTIVE_ERR)
        -: 1520:            {
        1: 1521:                CFE_EVS_SendEvent(CFE_TBL_CDS_OWNER_ACTIVE_ERR_EID, CFE_EVS_ERROR,
        -: 1522:                                  "CDS '%s' owning app is still active",
        -: 1523:                                  TableName, Status);
        -: 1524:            }
        3: 1525:            else if (Status == CFE_ES_CDS_NOT_FOUND_ERR)
        -: 1526:            {
        1: 1527:                CFE_EVS_SendEvent(CFE_TBL_CDS_NOT_FOUND_ERR_EID, CFE_EVS_ERROR,
        -: 1528:                                 "Unable to locate '%s' in CDS Registry", TableName);
        -: 1529:            }
        2: 1530:            else if (Status != CFE_SUCCESS)
        -: 1531:            {
        1: 1532:                CFE_EVS_SendEvent(CFE_TBL_CDS_DELETE_ERR_EID, CFE_EVS_ERROR,
        -: 1533:                                  "Error while deleting '%s' from CDS, See SysLog.(Err=0x%08X)",
        -: 1534:                                  TableName, Status);
        -: 1535:            }
        -: 1536:            else
        -: 1537:            {
        1: 1538:                CFE_EVS_SendEvent(CFE_TBL_CDS_DELETED_INFO_EID, CFE_EVS_INFORMATION,
        -: 1539:                                  "Successfully removed '%s' from CDS", TableName);
        -: 1540:
        -: 1541:                /* Free the entry in the Critical Table Registry */
        1: 1542:                CritRegRecPtr->CDSHandle = CFE_ES_CDS_BAD_HANDLE;
        -: 1543:
        -: 1544:                /* Increment Successful Command Counter */
        1: 1545:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1546:            }
        -: 1547:        }
        -: 1548:        else
        -: 1549:        {
        1: 1550:            CFE_EVS_SendEvent(CFE_TBL_NOT_IN_CRIT_REG_ERR_EID,
        -: 1551:                              CFE_EVS_ERROR,
        -: 1552:                              "Table '%s' is not found in Critical Table Registry",
        -: 1553:                              TableName);
        -: 1554:        }
        -: 1555:    }
        -: 1556:    else /* Table was found in Registry */
        -: 1557:    {
        1: 1558:        CFE_EVS_SendEvent(CFE_TBL_IN_REGISTRY_ERR_EID,
        -: 1559:                          CFE_EVS_ERROR,
        -: 1560:                          "'%s' found in Table Registry. CDS cannot be deleted until table is unregistered",
        -: 1561:                          TableName);
        -: 1562:    }
        7: 1563:    return ReturnCode;
        -: 1564:
        -: 1565:} /* End of CFE_TBL_DeleteCDSCmd() */
        -: 1566:
        -: 1567:
        -: 1568:/*******************************************************************
        -: 1569:**
        -: 1570:** CFE_TBL_AbortLoadCmd() -- Process Abort Load Command Message
        -: 1571:**
        -: 1572:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1573:********************************************************************/
        -: 1574:
        3: 1575:CFE_TBL_CmdProcRet_t CFE_TBL_AbortLoadCmd( const CFE_SB_Msg_t *MessagePtr )
        -: 1576:{
        3: 1577:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -: 1578:    int16                        RegIndex;
        3: 1579:    const CFE_TBL_AbortLdCmd_t  *CmdPtr = (const CFE_TBL_AbortLdCmd_t *) MessagePtr;
        -: 1580:    CFE_TBL_RegistryRec_t       *RegRecPtr;
        -: 1581:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -: 1582:
        -: 1583:    /* Make sure all strings are null terminated before attempting to process them */
        3: 1584:    CFE_PSP_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        3: 1585:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1586:
        -: 1587:    /* Before doing anything, lets make sure the table registry entry that is to be telemetered exists */
        3: 1588:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1589:
        3: 1590:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -: 1591:    {
        -: 1592:        /* Make a pointer to simplify code look and to remove redundant indexing into registry */
        2: 1593:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -: 1594:
        -: 1595:        /* Check to make sure a load was in progress before trying to abort it */
        -: 1596:        /* NOTE: LoadInProgress contains index of buffer when dumping a dump-only table */
        -: 1597:        /* so we must ensure the table is not a dump-only table, otherwise, we would be aborting a dump */
        3: 1598:        if ((RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS) && (!RegRecPtr->DumpOnly))
        -: 1599:        {
        1: 1600:            CFE_TBL_AbortLoad(RegRecPtr);
        -: 1601:
        -: 1602:            /* Increment Successful Command Counter */
        1: 1603:            ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1604:        }
        -: 1605:        else
        -: 1606:        {
        1: 1607:            CFE_EVS_SendEvent(CFE_TBL_LOAD_ABORT_ERR_EID,
        -: 1608:                              CFE_EVS_ERROR,
        -: 1609:                              "Cannot abort load of '%s'. No load started.",
        -: 1610:                              TableName);
        -: 1611:        }
        -: 1612:    }
        -: 1613:    else /* Table could not be found in Registry */
        -: 1614:    {
        1: 1615:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1616:                          CFE_EVS_ERROR,
        -: 1617:                          "Unable to locate '%s' in Table Registry",
        -: 1618:                          TableName);
        -: 1619:    }
        -: 1620:
        3: 1621:    return ReturnCode;
        -: 1622:
        -: 1623:} /* End of CFE_TBL_AbortLoadCmd() */
        -: 1624:
        -: 1625:
        -: 1626:/*******************************************************************
        -: 1627:**
        -: 1628:** CFE_TBL_AbortLoad() -- Abort load, free buffers, issue event message
        -: 1629:**
        -: 1630:** NOTE: For complete prolog information, see above
        -: 1631:********************************************************************/
        -: 1632:
        1: 1633:void CFE_TBL_AbortLoad(CFE_TBL_RegistryRec_t *RegRecPtr)
        -: 1634:{
        -: 1635:    /* The ground has aborted the load, free the working buffer for another attempt */
        1: 1636:    if (!RegRecPtr->DblBuffered)
        -: 1637:    {
        -: 1638:        /* For single buffered tables, freeing shared buffer entails resetting flag */
        1: 1639:        CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        -: 1640:    }
        -: 1641:
        -: 1642:    /* For double buffered tables, freeing buffer is simple */
        1: 1643:    RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -: 1644:
        -: 1645:    /* Make sure the load was not already pending */
        1: 1646:    RegRecPtr->LoadPending = FALSE;
        -: 1647:
        1: 1648:    CFE_EVS_SendEvent(CFE_TBL_LOAD_ABORT_INF_EID,
        -: 1649:                      CFE_EVS_INFORMATION,
        -: 1650:                      "Table Load Aborted for '%s'",
        -: 1651:                      RegRecPtr->Name);
        1: 1652:}
        -: 1653:
        -: 1654:/************************/
        -: 1655:/*  End of File Comment */
        -: 1656:/************************/
        -: 1657:
