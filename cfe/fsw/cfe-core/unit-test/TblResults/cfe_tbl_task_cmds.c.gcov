        -:    0:Source:/mnt/hgfs/Proj/cFE/Builds/Trunk/fsw/cfe-core/src/tbl/cfe_tbl_task_cmds.c
        -:    0:Graph:cfe_tbl_task_cmds.gcno
        -:    0:Data:cfe_tbl_task_cmds.gcda
        -:    0:Runs:1
        -:    0:Programs:3
        -:    1:/*
        -:    2:** $Id: cfe_tbl_task_cmds.c.gcov 1.8 2009/05/01 16:37:27EDT dkobe Exp  $
        -:    3:**
        -:    4:**      Copyright © 2004-2006, United States government as represented by the 
        -:    5:**      administrator of the National Aeronautics Space Administration.  
        -:    6:**      All rights reserved. This software(cFE) was created at NASA’s Goddard 
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This software may be used only pursuant to a United States government 
        -:   10:**      sponsored project and the United States government may not be charged
        -:   11:**      for use thereof.  
        -:   12:**
        -:   13:** Subsystem: cFE TBL Task Command Processing Functions
        -:   14:**
        -:   15:** Author: David Kobe (the Hammers Company, Inc.)
        -:   16:**
        -:   17:** Notes:
        -:   18:**
        -:   19:** $Log: cfe_tbl_task_cmds.c.gcov  $
        -:   19:** Revision 1.8 2009/05/01 16:37:27EDT dkobe 
        -:   19:** Updated for checking for positive return codes from table validation functions
        -:   20:** Revision 1.3 2008/12/08 16:10:56EST dkobe 
        -:   21:** Correcting errors generated during detailed design document generation
        -:   22:** Revision 1.2 2008/07/29 14:05:34EDT dkobe 
        -:   23:** Removed redundant FileCreateTimeSecs and FileCreateTimeSubSecs fields
        -:   24:** Revision 1.1 2008/04/17 08:05:36EDT ruperera 
        -:   25:** Initial revision
        -:   26:** Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/src/tbl/project.pj
        -:   27:** Revision 1.43 2007/09/12 16:06:11EDT David Kobe (dlkobe) 
        -:   28:** Moved the definitions of CFE_ES_CRC_xx to the cfe_mission_cfg.h file and deleted TBL Services
        -:   29:** CRC #define statement.
        -:   30:** Revision 1.42 2007/07/07 09:20:35EDT dlkobe 
        -:   31:** Added check for pending load in Load Cmd Processing
        -:   32:** Revision 1.41 2007/07/07 07:51:10EDT dlkobe 
        -:   33:** Added CFE_TBL_ASSUMED_VALID_INFO_EID event message
        -:   34:** Revision 1.40 2007/07/05 15:38:36EDT dlkobe 
        -:   35:** Added Critical Table Flag to Registry Dump/Tlm Cmds
        -:   36:**
        -:   37:*/
        -:   38:
        -:   39:
        -:   40:/*
        -:   41:** Required header files
        -:   42:*/
        -:   43:#include "cfe_evs.h"
        -:   44:#include "cfe_es.h"
        -:   45:#include "cfe_sb.h"
        -:   46:#include "cfe_fs.h"
        -:   47:#include "cfe_tbl_internal.h"
        -:   48:#include "cfe_tbl_events.h"
        -:   49:#include "cfe_tbl_msg.h"
        -:   50:#include "cfe_tbl_task_cmds.h"
        -:   51:#include <string.h>
        -:   52:
        -:   53:
        -:   54:/*****************************************************************************/
        -:   55:/**
        -:   56:** CFE_ES_DeleteCDS() -- Deletes the specified CDS from the CDS Registry and frees CDS Memory
        -:   57:**
        -:   58:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:   59:******************************************************************************/
        -:   60:int32  CFE_ES_DeleteCDS(const char *CDSName, boolean CalledByTblServices);
        -:   61:
        -:   62:/*****************************************************************************/
        -:   63:/**
        -:   64:** \brief Gathers data and puts it into the Housekeeping Message format
        -:   65:**
        -:   66:** \par Description
        -:   67:**        Gathers data from the Table Services Application, computes necessary data values and identifies
        -:   68:**        what Table Validation information needs to be reported in Housekeeping Telemetry.
        -:   69:** 
        -:   70:** \par Assumptions, External Events, and Notes:
        -:   71:**          None
        -:   72:**
        -:   73:** \retval None
        -:   74:******************************************************************************/
        -:   75:void CFE_TBL_GetHkData(void);
        -:   76:
        -:   77:
        -:   78:/*****************************************************************************/
        -:   79:/**
        -:   80:** \brief Convert Table Registry Entry for a Table into a Message
        -:   81:**
        -:   82:** \par Description
        -:   83:**        Extracts the Table Registry information for the table specified by the
        -:   84:**        #CFE_TBL_TaskData_t::HkTlmTblRegIndex variable.  It then formats the
        -:   85:**        Registry contents into a format appropriate for downlink.
        -:   86:** 
        -:   87:** \par Assumptions, External Events, and Notes:
        -:   88:**        #CFE_TBL_TaskData_t::HkTlmTblRegIndex is assumed to be a valid index into
        -:   89:**           the Table Registry.
        -:   90:**
        -:   91:** \retval None
        -:   92:******************************************************************************/
        -:   93:void CFE_TBL_GetTblRegData(void);
        -:   94:
        -:   95:
        -:   96:/*****************************************************************************/
        -:   97:/**
        -:   98:** \brief Output block of data to file with standard cFE Table Image Headers
        -:   99:**
        -:  100:** \par Description
        -:  101:**        Writes the specified block of data in memory to the specified file 
        -:  102:**        with the standard cFE File and cFE Table Image Headers.
        -:  103:** 
        -:  104:** \par Assumptions, External Events, and Notes:
        -:  105:**          None
        -:  106:**
        -:  107:** \param[in] DumpFilename    Character string containing the full path of the file
        -:  108:**                            to which the contents of the table are to be written
        -:  109:**
        -:  110:** \param[in] TableName       Name of table being dumped to a file
        -:  111:**
        -:  112:** \param[in] DumpDataAddr    Address of data buffer whose contents are to be written
        -:  113:**                            to the specified file
        -:  114:**
        -:  115:** \param[in] TblSizeInBytes  Size of block of data to be written to the file
        -:  116:**
        -:  117:** \retval #CFE_TBL_INC_ERR_CTR  \copydoc CFE_TBL_INC_ERR_CTR
        -:  118:** \retval #CFE_TBL_INC_CMD_CTR  \copydoc CFE_TBL_INC_CMD_CTR
        -:  119:******************************************************************************/
        -:  120:CFE_TBL_CmdProcRet_t CFE_TBL_DumpToFile( char *DumpFilename, char *TableName, 
        -:  121:                                         void *DumpDataAddr, uint32 TblSizeInBytes);
        -:  122:
        -:  123:
        -:  124:/*****************************************************************************/
        -:  125:/**
        -:  126:** \brief Aborts load by freeing associated inactive buffers and sending event message
        -:  127:**
        -:  128:** \par Description
        -:  129:**        This function aborts the load for the table whose registry entry is identified
        -:  130:**        by the registry record pointer given as an argument.  Aborting the load consists
        -:  131:**        of freeing any associated inactive buffer and issuing an event message.
        -:  132:** 
        -:  133:** \par Assumptions, External Events, and Notes:
        -:  134:**        The given registry record pointer is assumed to be valid.
        -:  135:**
        -:  136:** \param[in] RegRecPtr   Pointer to registry record entry for the table whose load is to be aborted
        -:  137:**
        -:  138:** \return None
        -:  139:******************************************************************************/
        -:  140:void CFE_TBL_AbortLoad(CFE_TBL_RegistryRec_t *RegRecPtr);
        -:  141:
        -:  142:/*
        -:  143:** External Globals
        -:  144:*/
        -:  145:extern CFE_TBL_TaskData_t CFE_TBL_TaskData;
        -:  146:
        -:  147:/*******************************************************************
        -:  148:**
        -:  149:** CFE_TBL_HousekeepingCmd() -- Process Housekeeping Request Message
        -:  150:**
        -:  151:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  152:********************************************************************/
        -:  153:
        -:  154:CFE_TBL_CmdProcRet_t CFE_TBL_HousekeepingCmd( const CFE_SB_Msg_t *MessagePtr )
        3:  155:{
        -:  156:    int32                     Status;
        -:  157:    int32                     i;
        -:  158:    CFE_TBL_DumpControl_t    *DumpCtrlPtr;
        -:  159:    CFE_TIME_SysTime_t        DumpTime;
        -:  160:    int32                     FileDescriptor;
        -:  161:    
        -:  162:    /*
        -:  163:    ** Collect housekeeping data from Table Services
        -:  164:    */
        3:  165:    CFE_TBL_GetHkData();
        -:  166:
        -:  167:    /*
        -:  168:    ** Send housekeeping telemetry packet
        -:  169:    */
        3:  170:    CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.HkPacket);
        3:  171:    Status = CFE_SB_SendMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.HkPacket);
        -:  172:
        3:  173:    if (Status != CFE_SUCCESS)
        -:  174:    {
        1:  175:        CFE_EVS_SendEvent(CFE_TBL_FAIL_HK_SEND_ERR_EID,
        -:  176:                          CFE_EVS_ERROR,
        -:  177:                          "Unable to send Hk Packet (Status=0x%08X)",
        -:  178:                          Status);
        -:  179:    }
        -:  180:
        -:  181:    /* If a table's registry entry has been requested for telemetry, then pack it and send it */
        3:  182:    if (CFE_TBL_TaskData.HkTlmTblRegIndex != CFE_TBL_NOT_FOUND)
        -:  183:    {
        3:  184:        CFE_TBL_GetTblRegData();
        -:  185:
        -:  186:        /*
        -:  187:        ** Send Table Registry Info Packet
        -:  188:        */
        3:  189:        CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.TblRegPacket);
        3:  190:        CFE_SB_SendMsg((CFE_SB_Msg_t *) &CFE_TBL_TaskData.TblRegPacket);
        -:  191:
        -:  192:        /* Once the data has been sent, clear the index so that we don't send it again and again */
        3:  193:        CFE_TBL_TaskData.HkTlmTblRegIndex = CFE_TBL_NOT_FOUND;
        -:  194:    }
        -:  195:    
        -:  196:    /* Check to see if there are any dump-only table dumps pending */
       15:  197:    for (i=0; i < CFE_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -:  198:    {
       12:  199:        if (CFE_TBL_TaskData.DumpControlBlocks[i].State == CFE_TBL_DUMP_PERFORMED)
        -:  200:        {
        2:  201:        	DumpCtrlPtr = &CFE_TBL_TaskData.DumpControlBlocks[i];
        2:  202:            Status = CFE_TBL_DumpToFile(DumpCtrlPtr->DumpBufferPtr->DataSource,
        -:  203:                                        DumpCtrlPtr->TableName,
        -:  204:                                        DumpCtrlPtr->DumpBufferPtr->BufferPtr,
        -:  205:                                        DumpCtrlPtr->Size);
        -:  206:                                
        -:  207:            /* If dump file was successfully written, update the file header so that the timestamp */
        -:  208:            /* is the time of the actual capturing of the data, NOT the time when it was written to the file */        
        2:  209:            if (Status == CFE_TBL_INC_CMD_CTR)
        -:  210:            {
        2:  211:                DumpTime.Seconds = DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSecs;
        2:  212:                DumpTime.Subseconds = DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSubSecs;
        -:  213:            
        2:  214:                FileDescriptor = OS_open(DumpCtrlPtr->DumpBufferPtr->DataSource, OS_READ_WRITE, 0);
        -:  215:
        2:  216:                if (FileDescriptor >= 0)
        -:  217:                {
        1:  218:                    Status = CFE_FS_SetTimestamp(FileDescriptor, DumpTime);
        -:  219:                    
        1:  220:                    if (Status != OS_FS_SUCCESS)
        -:  221:                    {
        1:  222:                        CFE_ES_WriteToSysLog("CFE_TBL:HkCmd-Unable to update timestamp in dump file '%s'\n", 
        -:  223:                                             DumpCtrlPtr->DumpBufferPtr->DataSource);
        -:  224:                    }
        -:  225:                    
        1:  226:                    OS_close(FileDescriptor);
        -:  227:                }
        -:  228:                else
        -:  229:                {
        1:  230:                    CFE_ES_WriteToSysLog("CFE_TBL:HkCmd-Unable to open dump file '%s' to update timestamp\n", 
        -:  231:                                         DumpCtrlPtr->DumpBufferPtr->DataSource);
        -:  232:                }
        -:  233:            }       
        -:  234:                        
        -:  235:            /* Free the shared working buffer */
        2:  236:            CFE_TBL_TaskData.LoadBuffs[DumpCtrlPtr->RegRecPtr->LoadInProgress].Taken = FALSE;
        2:  237:            DumpCtrlPtr->RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -:  238:            
        -:  239:            /* Free the Dump Control Block for later use */
        2:  240:            DumpCtrlPtr->State = CFE_TBL_DUMP_FREE;       
        -:  241:        }
        -:  242:    }
        -:  243:
        3:  244:    return CFE_TBL_DONT_INC_CTR;
        -:  245:
        -:  246:} /* End of CFE_TBL_HousekeepingCmd() */
        -:  247:
        -:  248:
        -:  249:/*******************************************************************
        -:  250:**
        -:  251:** CFE_TBL_GetHkData() -- Collect data and store it into the Housekeeping Message
        -:  252:**
        -:  253:** NOTE: For complete prolog information, see prototype above
        -:  254:********************************************************************/
        -:  255:
        -:  256:void CFE_TBL_GetHkData(void)
        7:  257:{
        -:  258:    int32 i;
        -:  259:    uint16 Count;
        7:  260:    CFE_TBL_ValidationResult_t *ValPtr = NULL;
        -:  261:
        -:  262:    /* Copy command counter data */
        7:  263:    CFE_TBL_TaskData.HkPacket.CmdCounter = CFE_TBL_TaskData.CmdCounter;
        7:  264:    CFE_TBL_TaskData.HkPacket.ErrCounter = CFE_TBL_TaskData.ErrCounter;
        7:  265:    CFE_TBL_TaskData.HkPacket.FailedValCtr = CFE_TBL_TaskData.FailedValCtr;
        7:  266:    CFE_TBL_TaskData.HkPacket.NumLoadPending = 0;
        7:  267:    CFE_TBL_TaskData.HkPacket.MemPoolHandle = CFE_TBL_TaskData.Buf.PoolHdl;
        -:  268:
        -:  269:    /* Determine the number of tables currently registered and Number of Load Pending Tables */
        7:  270:    Count = 0;
      903:  271:    for (i=0; i<CFE_TBL_MAX_NUM_TABLES; i++)
        -:  272:    {
      896:  273:        if (CFE_TBL_TaskData.Registry[i].OwnerAppId != CFE_TBL_NOT_OWNED)
        -:  274:        {
      515:  275:            Count++;
        -:  276:
      515:  277:            if (CFE_TBL_TaskData.Registry[i].LoadPending)
        -:  278:            {
        8:  279:                CFE_TBL_TaskData.HkPacket.NumLoadPending++;
        -:  280:            }
        -:  281:        }
        -:  282:    }
        7:  283:    CFE_TBL_TaskData.HkPacket.NumTables = Count;
        -:  284:
        -:  285:    /* Determine the number of free shared buffers */
        7:  286:    CFE_TBL_TaskData.HkPacket.NumFreeSharedBufs = CFE_TBL_MAX_SIMULTANEOUS_LOADS;
       35:  287:    for (i=0; i<CFE_TBL_MAX_SIMULTANEOUS_LOADS; i++)
        -:  288:    {
       28:  289:        if (CFE_TBL_TaskData.LoadBuffs[i].Taken)
        -:  290:        {
       10:  291:            CFE_TBL_TaskData.HkPacket.NumFreeSharedBufs--;
        -:  292:        }
        -:  293:    }
        -:  294:
        -:  295:    /* Locate a completed, but unreported, validation request */
        7:  296:    i=0;
       84:  297:    while ((i < CFE_TBL_MAX_NUM_VALIDATIONS) && (ValPtr == NULL))
        -:  298:    {
       70:  299:        if (CFE_TBL_TaskData.ValidationResults[i].State == CFE_TBL_VALIDATION_PERFORMED)
        -:  300:        {
        2:  301:            ValPtr = &CFE_TBL_TaskData.ValidationResults[i];
        -:  302:        }
        -:  303:        else
        -:  304:        {
       68:  305:            i++;
        -:  306:        }
        -:  307:    }
        -:  308:
        7:  309:    if (ValPtr != NULL)
        -:  310:    {
        2:  311:        CFE_TBL_TaskData.HkPacket.LastValCrc = ValPtr->CrcOfTable;
        2:  312:        CFE_TBL_TaskData.HkPacket.LastValStatus = ValPtr->Result;
        2:  313:        CFE_TBL_TaskData.HkPacket.ActiveBuffer = ValPtr->ActiveBuffer;
        -:  314:
        -:  315:        /* Keep track of the number of failed and successful validations */
        2:  316:        if (ValPtr->Result == CFE_SUCCESS)
        -:  317:        {
        1:  318:            CFE_TBL_TaskData.SuccessValCtr++;
        -:  319:        }
        -:  320:        else
        -:  321:        {
        1:  322:            CFE_TBL_TaskData.FailedValCtr++;
        -:  323:        }
        -:  324:
        2:  325:        OS_MemCpy(&CFE_TBL_TaskData.HkPacket.LastValTableName[0],
        -:  326:                  &ValPtr->TableName[0],
        -:  327:                  CFE_TBL_MAX_FULL_NAME_LEN);
        2:  328:        CFE_TBL_TaskData.ValidationCtr++;
        -:  329:
        -:  330:        /* Free the Validation Response Block for next time */
        2:  331:        ValPtr->Result = 0;
        2:  332:        ValPtr->CrcOfTable = 0;
        2:  333:        ValPtr->TableName[0] = '\0';
        2:  334:        ValPtr->ActiveBuffer = FALSE;
        2:  335:        ValPtr->State = CFE_TBL_VALIDATION_FREE;
        -:  336:    }
        -:  337:
        7:  338:    CFE_TBL_TaskData.HkPacket.ValidationCtr  = CFE_TBL_TaskData.ValidationCtr;
        7:  339:    CFE_TBL_TaskData.HkPacket.SuccessValCtr  = CFE_TBL_TaskData.SuccessValCtr;
        7:  340:    CFE_TBL_TaskData.HkPacket.FailedValCtr   = CFE_TBL_TaskData.FailedValCtr;
        7:  341:    CFE_TBL_TaskData.HkPacket.NumValRequests = CFE_TBL_TaskData.NumValRequests;
        -:  342:    
        -:  343:    /* Validate the index of the last table updated before using it */
        7:  344:    if ((CFE_TBL_TaskData.LastTblUpdated >= 0) && 
        -:  345:        (CFE_TBL_TaskData.LastTblUpdated < CFE_TBL_MAX_NUM_TABLES))
        -:  346:    {
        -:  347:        /* Check to make sure the Registry Entry is still valid */
        7:  348:        if (CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.LastTblUpdated].OwnerAppId != CFE_TBL_NOT_OWNED)
        -:  349:        {
        -:  350:            /* Get the time and filename used for the last table update */
        7:  351:            CFE_TBL_TaskData.HkPacket.LastUpdateTime = CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.LastTblUpdated].TimeOfLastUpdate;
        7:  352:            OS_MemCpy(CFE_TBL_TaskData.HkPacket.LastUpdatedTbl, 
        -:  353:                      CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.LastTblUpdated].Name, 
        -:  354:                      CFE_TBL_MAX_FULL_NAME_LEN);
        -:  355:        }      
        -:  356:    }
        7:  357:}
        -:  358:
        -:  359:/*******************************************************************
        -:  360:**
        -:  361:** CFE_TBL_GetTblRegData() -- Convert Table Registry Entry for a Table into a Message
        -:  362:**
        -:  363:** NOTE: For complete prolog information, see prototype above
        -:  364:********************************************************************/
        -:  365:
        -:  366:void CFE_TBL_GetTblRegData(void)
        6:  367:{
        -:  368:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -:  369:
        6:  370:    RegRecPtr = &CFE_TBL_TaskData.Registry[CFE_TBL_TaskData.HkTlmTblRegIndex];
        -:  371:
        6:  372:    CFE_TBL_TaskData.TblRegPacket.Size = RegRecPtr->Size;
        6:  373:    CFE_TBL_TaskData.TblRegPacket.ActiveBufferAddr = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr;
        -:  374:
        6:  375:    if (RegRecPtr->DblBuffered)
        -:  376:    {
        -:  377:        /* For a double buffered table, the inactive is the other allocated buffer */
        1:  378:        CFE_TBL_TaskData.TblRegPacket.InactiveBufferAddr =
        -:  379:            RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr;
        -:  380:    }
        -:  381:    else
        -:  382:    {
        -:  383:        /* Check to see if an inactive buffer has currently been allocated to the single buffered table */
        5:  384:        if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  385:        {
        1:  386:            CFE_TBL_TaskData.TblRegPacket.InactiveBufferAddr =
        -:  387:                CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr;
        -:  388:        }
        -:  389:        else
        -:  390:        {
        4:  391:            CFE_TBL_TaskData.TblRegPacket.InactiveBufferAddr = NULL;
        -:  392:        }
        -:  393:    }
        -:  394:
        6:  395:    CFE_TBL_TaskData.TblRegPacket.ValidationFuncPtr = RegRecPtr->ValidationFuncPtr;
        6:  396:    CFE_TBL_TaskData.TblRegPacket.TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
        6:  397:    CFE_TBL_TaskData.TblRegPacket.TableLoadedOnce = RegRecPtr->TableLoadedOnce;
        6:  398:    CFE_TBL_TaskData.TblRegPacket.LoadPending = RegRecPtr->LoadPending;
        6:  399:    CFE_TBL_TaskData.TblRegPacket.DumpOnly = RegRecPtr->DumpOnly;
        6:  400:    CFE_TBL_TaskData.TblRegPacket.DblBuffered = RegRecPtr->DblBuffered;
        6:  401:    CFE_TBL_TaskData.TblRegPacket.FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
        6:  402:    CFE_TBL_TaskData.TblRegPacket.FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
        6:  403:    CFE_TBL_TaskData.TblRegPacket.Critical = RegRecPtr->CriticalTable;
        -:  404:
        6:  405:    OS_MemCpy(CFE_TBL_TaskData.TblRegPacket.Name, RegRecPtr->Name, CFE_TBL_MAX_FULL_NAME_LEN);
        6:  406:    OS_MemCpy(CFE_TBL_TaskData.TblRegPacket.LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        6:  407:    OS_MemSet(CFE_TBL_TaskData.TblRegPacket.OwnerAppName, 0, OS_MAX_API_NAME);
        6:  408:    CFE_ES_GetAppName(CFE_TBL_TaskData.TblRegPacket.OwnerAppName, RegRecPtr->OwnerAppId, OS_MAX_API_NAME);
        6:  409:}
        -:  410:
        -:  411:
        -:  412:/*******************************************************************
        -:  413:**
        -:  414:** CFE_TBL_NoopCmd() -- Process NO-Op Command Message
        -:  415:**
        -:  416:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  417:********************************************************************/
        -:  418:
        -:  419:CFE_TBL_CmdProcRet_t CFE_TBL_NoopCmd( const CFE_SB_Msg_t *MessagePtr )
        2:  420:{
        -:  421:    /* Acknowledge receipt of NOOP with Event Message */
        2:  422:    CFE_EVS_SendEvent(CFE_TBL_NOOP_INF_EID, CFE_EVS_INFORMATION, "No-op command");
        -:  423:
        2:  424:    return CFE_TBL_INC_CMD_CTR;
        -:  425:
        -:  426:} /* End of CFE_TBL_NoopCmd() */
        -:  427:
        -:  428:
        -:  429:/*******************************************************************
        -:  430:**
        -:  431:** CFE_TBL_ResetCmd() -- Process Reset Counters Command Message
        -:  432:**
        -:  433:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  434:********************************************************************/
        -:  435:
        -:  436:CFE_TBL_CmdProcRet_t CFE_TBL_ResetCmd( const CFE_SB_Msg_t *MessagePtr )
        1:  437:{
        1:  438:    CFE_TBL_TaskData.CmdCounter = 0;
        1:  439:    CFE_TBL_TaskData.ErrCounter = 0;
        1:  440:    CFE_TBL_TaskData.SuccessValCtr = 0;
        1:  441:    CFE_TBL_TaskData.FailedValCtr = 0;
        1:  442:    CFE_TBL_TaskData.NumValRequests = 0;
        1:  443:    CFE_TBL_TaskData.ValidationCtr = 0;
        -:  444:
        1:  445:    CFE_EVS_SendEvent(CFE_TBL_RESET_INF_EID,
        -:  446:                      CFE_EVS_DEBUG,
        -:  447:                      "Reset Counters command");
        -:  448:
        1:  449:    return CFE_TBL_DONT_INC_CTR;
        -:  450:
        -:  451:} /* End of CFE_TBL_ResetCmd() */
        -:  452:
        -:  453:
        -:  454:/*******************************************************************
        -:  455:**
        -:  456:** CFE_TBL_LoadCmd() -- Process Load Table File to Buffer Command Message
        -:  457:**
        -:  458:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  459:********************************************************************/
        -:  460:
        -:  461:CFE_TBL_CmdProcRet_t CFE_TBL_LoadCmd( const CFE_SB_Msg_t *MessagePtr )
       12:  462:{
       12:  463:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
       12:  464:    const CFE_TBL_LoadCmd_t    *CmdPtr = (const CFE_TBL_LoadCmd_t *) MessagePtr;
        -:  465:    CFE_FS_Header_t             StdFileHeader;
        -:  466:    CFE_TBL_File_Hdr_t          TblFileHeader;
        -:  467:    int32                       FileDescriptor;
        -:  468:    int32                       Status;
        -:  469:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -:  470:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
        -:  471:    char                        LoadFilename[OS_MAX_PATH_LEN];
        -:  472:    uint8                       ExtraByte;
        -:  473:
        -:  474:    /* Make sure all strings are null terminated before attempting to process them */
       12:  475:    OS_MemCpy(LoadFilename, (void *)CmdPtr->LoadFilename, OS_MAX_PATH_LEN);
       12:  476:    LoadFilename[OS_MAX_PATH_LEN-1] = '\0';
        -:  477:
        -:  478:    /* Try to open the specified table file */
        -:  479:    /* TODO: Put in PATH search capability to locate file */
       12:  480:    FileDescriptor = OS_open(LoadFilename, OS_READ_ONLY, 0);
        -:  481:
       12:  482:    if (FileDescriptor >= 0)
        -:  483:    {
       11:  484:        Status = CFE_TBL_ReadHeaders(FileDescriptor, &StdFileHeader, &TblFileHeader, &LoadFilename[0]);
        -:  485:
       11:  486:        if (Status == CFE_SUCCESS)
        -:  487:        {
        -:  488:            /* Locate specified table in registry */
       11:  489:            Status = CFE_TBL_FindTableInRegistry(TblFileHeader.TableName);
        -:  490:
       11:  491:            if (Status == CFE_TBL_NOT_FOUND)
        -:  492:            {
        1:  493:                CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -:  494:                                  CFE_EVS_ERROR,
        -:  495:                                  "Unable to locate '%s' in Table Registry",
        -:  496:                                  TblFileHeader.TableName);
        -:  497:            }
        -:  498:            else
        -:  499:            {
        -:  500:                /* Translate the registry index into a record pointer */
       10:  501:                RegRecPtr = &CFE_TBL_TaskData.Registry[Status];
        -:  502:
       10:  503:                if (RegRecPtr->DumpOnly)
        -:  504:                {
        1:  505:                    CFE_EVS_SendEvent(CFE_TBL_LOADING_A_DUMP_ONLY_ERR_EID,
        -:  506:                                      CFE_EVS_ERROR,
        -:  507:                                      "Attempted to load DUMP-ONLY table '%s' from '%s'",
        -:  508:                                      TblFileHeader.TableName, LoadFilename);
        -:  509:                }
        9:  510:                else if (RegRecPtr->LoadPending)
        -:  511:                {
        1:  512:                    CFE_EVS_SendEvent(CFE_TBL_LOADING_PENDING_ERR_EID,
        -:  513:                                      CFE_EVS_ERROR,
        -:  514:                                      "Attempted to load table '%s' while previous load is still pending",
        -:  515:                                      TblFileHeader.TableName);
        -:  516:                }
        -:  517:                else
        -:  518:                {
        -:  519:                    /* Make sure of the following:                                               */
        -:  520:                    /*    1) If table has not been loaded previously, then make sure the current */
        -:  521:                    /*       load starts with the first byte                                     */
        -:  522:                    /*    2) The number of bytes to load is greater than zero                    */
        -:  523:                    /*    3) The offset plus the number of bytes does not exceed the table size  */
       12:  524:                    if (((RegRecPtr->TableLoadedOnce) || (TblFileHeader.Offset == 0)) &&
        -:  525:                        (TblFileHeader.NumBytes > 0) &&
        -:  526:                        ((TblFileHeader.NumBytes + TblFileHeader.Offset) <= RegRecPtr->Size))
        -:  527:                    {
        -:  528:                        /* Get a working buffer, either a free one or one allocated with previous load command */
        4:  529:                        Status = CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, FALSE);
        -:  530:
        4:  531:                        if (Status == CFE_SUCCESS)
        -:  532:                        {
        -:  533:                            /* Copy data from file into working buffer */
        3:  534:                            Status = OS_read(FileDescriptor,
        -:  535:                                             &WorkingBufferPtr->BufferPtr[TblFileHeader.Offset],
        -:  536:                                             TblFileHeader.NumBytes);
        -:  537:                                    
        -:  538:                            /* Make sure the appropriate number of bytes were read */
        3:  539:                            if (Status == (int32)TblFileHeader.NumBytes)
        -:  540:                            {
        -:  541:                                /* Check to ensure the file does not have any extra data at the end */
        2:  542:                                Status = OS_read(FileDescriptor, &ExtraByte, 1);
        -:  543:
        -:  544:                                /* If another byte was successfully read, then file contains more data than header claims */
        2:  545:                                if (Status == 1)
        -:  546:                                {
        1:  547:                                    CFE_EVS_SendEvent(CFE_TBL_FILE_TOO_BIG_ERR_EID,
        -:  548:                                                      CFE_EVS_ERROR,
        -:  549:                                                      "File '%s' has more data than Tbl Hdr indicates (%d)",
        -:  550:                                                      LoadFilename,
        -:  551:                                                      TblFileHeader.NumBytes);
        -:  552:                                }
        -:  553:                                else /* If error reading file or zero bytes read, assume it was the perfect size */
        -:  554:                                {
        1:  555:                                    CFE_EVS_SendEvent(CFE_TBL_FILE_LOADED_INF_EID,
        -:  556:                                                      CFE_EVS_INFORMATION,
        -:  557:                                                      "Successful load of '%s' into '%s' working buffer",
        -:  558:                                                      LoadFilename,
        -:  559:                                                      TblFileHeader.TableName);
        -:  560:
        -:  561:                                    /* Save file information statistics for later use in registry */
        1:  562:                                    OS_MemCpy(WorkingBufferPtr->DataSource, LoadFilename, OS_MAX_PATH_LEN);
        -:  563:
        -:  564:                                    /* Save file creation time for later storage into Registry */
        1:  565:                                    WorkingBufferPtr->FileCreateTimeSecs = StdFileHeader.TimeSeconds;
        1:  566:                                    WorkingBufferPtr->FileCreateTimeSubSecs = StdFileHeader.TimeSubSeconds;
        -:  567:                                    
        -:  568:                                    /* Initialize validation flag with TRUE if no Validation Function is required to be called */
        1:  569:                                    WorkingBufferPtr->Validated = (RegRecPtr->ValidationFuncPtr == NULL);
        -:  570:                            
        -:  571:                                    /* Save file information statistics for housekeeping telemetry */
        1:  572:                                    OS_MemCpy(CFE_TBL_TaskData.HkPacket.LastFileLoaded, LoadFilename, OS_MAX_PATH_LEN);
        -:  573:
        -:  574:                                    /* Increment successful command completion counter */
        1:  575:                                    ReturnCode = CFE_TBL_INC_CMD_CTR;
        -:  576:                                }
        -:  577:                            }
        -:  578:                            else
        -:  579:                            {
        -:  580:                                /* A file whose header claims has 'x' amount of data but it only has 'y' */
        -:  581:                                /* is considered a fatal error during a load process                     */
        1:  582:                                CFE_EVS_SendEvent(CFE_TBL_FILE_INCOMPLETE_ERR_EID,
        -:  583:                                                  CFE_EVS_ERROR,
        -:  584:                                                  "Incomplete load of '%s' into '%s' working buffer",
        -:  585:                                                  LoadFilename,
        -:  586:                                                  TblFileHeader.TableName);
        -:  587:                            }
        -:  588:                        }
        1:  589:                        else if (Status == CFE_TBL_ERR_NO_BUFFER_AVAIL)
        -:  590:                        {
        1:  591:                            CFE_EVS_SendEvent(CFE_TBL_NO_WORK_BUFFERS_ERR_EID,
        -:  592:                                              CFE_EVS_ERROR,
        -:  593:                                              "No working buffers available for table '%s'",
        -:  594:                                              TblFileHeader.TableName);
        -:  595:                        }
        -:  596:                        else
        -:  597:                        {
    #####:  598:                            CFE_EVS_SendEvent(CFE_TBL_INTERNAL_ERROR_ERR_EID,
        -:  599:                                              CFE_EVS_ERROR,
        -:  600:                                              "Internal Error (Status=0x%08X)",
        -:  601:                                              Status);
        -:  602:                        }
        -:  603:                    }
        -:  604:                    else
        -:  605:                    {
        4:  606:                        if ((TblFileHeader.NumBytes + TblFileHeader.Offset) > RegRecPtr->Size)
        -:  607:                        {
        2:  608:                            CFE_EVS_SendEvent(CFE_TBL_LOAD_EXCEEDS_SIZE_ERR_EID,
        -:  609:                                              CFE_EVS_ERROR,
        -:  610:                                              "Table Hdr in '%s' indicates data beyond size of '%s' (%d)",
        -:  611:                                              LoadFilename, TblFileHeader.TableName, RegRecPtr->Size);
        -:  612:                        }
        2:  613:                        else if (TblFileHeader.NumBytes == 0)
        -:  614:                        {
        1:  615:                            CFE_EVS_SendEvent(CFE_TBL_ZERO_LENGTH_LOAD_ERR_EID,
        -:  616:                                              CFE_EVS_ERROR,
        -:  617:                                              "Table Hdr in '%s' indicates no data in file",
        -:  618:                                              LoadFilename);
        -:  619:                        }
        -:  620:                        else
        -:  621:                        {
        1:  622:                            CFE_EVS_SendEvent(CFE_TBL_PARTIAL_LOAD_ERR_EID,
        -:  623:                                              CFE_EVS_ERROR,
        -:  624:                                              "'%s' has partial load for uninitialized table '%s'",
        -:  625:                                              LoadFilename, TblFileHeader.TableName);
        -:  626:                        }
        -:  627:                    }
        -:  628:                }
        -:  629:            }
        -:  630:        }  /* No need to issue event messages in response to errors reading headers */
        -:  631:           /* because the function that read the headers will generate messages     */
        -:  632:
        -:  633:        /* Close the file now that the contents have been read */
       11:  634:        OS_close(FileDescriptor);
        -:  635:    }
        -:  636:    else
        -:  637:    {
        -:  638:        /* Error opening specified file */
        1:  639:        CFE_EVS_SendEvent(CFE_TBL_FILE_ACCESS_ERR_EID,
        -:  640:                          CFE_EVS_ERROR,
        -:  641:                          "Unable to open file '%s' for table load, Status = 0x%08X",
        -:  642:                          LoadFilename, FileDescriptor);
        -:  643:    }
        -:  644:
       12:  645:    return ReturnCode;
        -:  646:
        -:  647:} /* End of CFE_TBL_LoadCmd() */
        -:  648:
        -:  649:
        -:  650:/*******************************************************************
        -:  651:**
        -:  652:** CFE_TBL_DumpCmd() -- Process Dump Table to File Command Message
        -:  653:**
        -:  654:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  655:********************************************************************/
        -:  656:
        -:  657:CFE_TBL_CmdProcRet_t CFE_TBL_DumpCmd( const CFE_SB_Msg_t *MessagePtr )
        8:  658:{
        8:  659:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -:  660:    int16                       RegIndex;
        8:  661:    const CFE_TBL_DumpCmd_t    *CmdPtr = (const CFE_TBL_DumpCmd_t *) MessagePtr;
        -:  662:    char                        DumpFilename[OS_MAX_PATH_LEN];
        -:  663:    char                        TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -:  664:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        8:  665:    void                       *DumpDataAddr = NULL;
        -:  666:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
        -:  667:    int32                       DumpIndex;
        -:  668:    int32                       Status;
        -:  669:    CFE_TBL_DumpControl_t      *DumpCtrlPtr;
        -:  670:
        -:  671:    /* Make sure all strings are null terminated before attempting to process them */
        8:  672:    OS_MemCpy(DumpFilename, (void *)CmdPtr->DumpFilename, OS_MAX_PATH_LEN);
        8:  673:    DumpFilename[OS_MAX_PATH_LEN-1] = '\0';
        -:  674:
        8:  675:    OS_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        8:  676:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -:  677:
        -:  678:    /* Before doing anything, lets make sure the table that is to be dumped exists */
        8:  679:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -:  680:
        8:  681:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -:  682:    {
        -:  683:        /* Obtain a pointer to registry information about specified table */
        7:  684:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -:  685:
        -:  686:        /* Determine what data is to be dumped */
        7:  687:        if (CmdPtr->ActiveTblFlag == CFE_TBL_ACTIVE_BUFFER)
        -:  688:        {
        3:  689:            DumpDataAddr = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr;
        -:  690:        }
        4:  691:        else if (CmdPtr->ActiveTblFlag == CFE_TBL_INACTIVE_BUFFER)/* Dumping Inactive Buffer */
        -:  692:        {
        -:  693:            /* If this is a double buffered table, locating the inactive buffer is trivial */
        3:  694:            if (RegRecPtr->DblBuffered)
        -:  695:            {
        1:  696:                DumpDataAddr = RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr;
        -:  697:            }
        -:  698:            else
        -:  699:            {
        -:  700:                /* For single buffered tables, the index to the inactive buffer is kept in 'LoadInProgress' */
        -:  701:                /* Unless this is a table whose address was defined by the owning Application.              */
        3:  702:                if ((RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS) && (!RegRecPtr->UserDefAddr))
        -:  703:                {
        1:  704:                    DumpDataAddr = CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr;
        -:  705:                }
        -:  706:                else
        -:  707:                {
        1:  708:                    CFE_EVS_SendEvent(CFE_TBL_NO_INACTIVE_BUFFER_ERR_EID,
        -:  709:                                      CFE_EVS_ERROR,
        -:  710:                                      "No Inactive Buffer for Table '%s' present",
        -:  711:                                      TableName);
        -:  712:                }
        -:  713:            }
        -:  714:        }
        -:  715:        else
        -:  716:        {
        1:  717:            CFE_EVS_SendEvent(CFE_TBL_ILLEGAL_BUFF_PARAM_ERR_EID,
        -:  718:                              CFE_EVS_ERROR,
        -:  719:                              "Cmd for Table '%s' had illegal buffer parameter (0x%08X)",
        -:  720:                              TableName, CmdPtr->ActiveTblFlag);
        -:  721:        }
        -:  722:
        -:  723:        /* If we have located the data to be dumped, then proceed with creating the file and dumping the data */
        7:  724:        if (DumpDataAddr != NULL)
        -:  725:        {
        -:  726:            /* If this is not a dump only table, then we can perform the dump immediately */
        5:  727:            if (!RegRecPtr->DumpOnly)
        -:  728:            {
        1:  729:                ReturnCode = CFE_TBL_DumpToFile(DumpFilename, TableName, DumpDataAddr, RegRecPtr->Size);
        -:  730:            }
        -:  731:            else /* Dump Only tables need to synchronize their dumps with the owner's execution */
        -:  732:            {
        -:  733:                /* Make sure a dump is not already in progress */
        4:  734:                if (RegRecPtr->DumpControlIndex == CFE_TBL_NO_DUMP_PENDING)
        -:  735:                {
        -:  736:                    /* Find a free Dump Control Block */
        3:  737:                    DumpIndex = 0;
       11:  738:                    while ((DumpIndex < CFE_TBL_MAX_SIMULTANEOUS_LOADS) &&
        -:  739:                           (CFE_TBL_TaskData.DumpControlBlocks[DumpIndex].State != CFE_TBL_DUMP_FREE))
        -:  740:                    {
        5:  741:                        DumpIndex++;
        -:  742:                    }
        -:  743:
        3:  744:                    if (DumpIndex < CFE_TBL_MAX_SIMULTANEOUS_LOADS)
        -:  745:                    {
        -:  746:                        /* Allocate a shared memory buffer for storing the data to be dumped */
        2:  747:                        Status = CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, FALSE);
        -:  748:                        
        2:  749:                        if (Status == CFE_SUCCESS)
        -:  750:                        {
        1:  751:                            DumpCtrlPtr = &CFE_TBL_TaskData.DumpControlBlocks[DumpIndex];
        1:  752:                            DumpCtrlPtr->State = CFE_TBL_DUMP_PENDING;
        1:  753:                            DumpCtrlPtr->RegRecPtr = RegRecPtr;
        -:  754:                        
        -:  755:                            /* Save the name of the desired dump filename, table name and size for later */
        1:  756:                            DumpCtrlPtr->DumpBufferPtr = WorkingBufferPtr;
        1:  757:                            OS_MemCpy(DumpCtrlPtr->DumpBufferPtr->DataSource, DumpFilename, OS_MAX_PATH_LEN);
        1:  758:                            OS_MemCpy(DumpCtrlPtr->TableName, TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        1:  759:                            DumpCtrlPtr->Size = RegRecPtr->Size;
        -:  760:                        
        -:  761:                            /* Notify the owning application that a dump is pending */
        1:  762:                            RegRecPtr->DumpControlIndex = DumpIndex;
        -:  763:                            
        -:  764:                            /* Consider the command completed successfully */
        1:  765:                            ReturnCode = CFE_TBL_INC_CMD_CTR;
        -:  766:                        }
        -:  767:                        else
        -:  768:                        {
        1:  769:                            CFE_EVS_SendEvent(CFE_TBL_NO_WORK_BUFFERS_ERR_EID,
        -:  770:                                              CFE_EVS_ERROR,
        -:  771:                                              "No working buffers available for table '%s'",
        -:  772:                                              TableName);
        -:  773:                        }
        -:  774:                    }
        -:  775:                    else
        -:  776:                    {
        1:  777:                        CFE_EVS_SendEvent(CFE_TBL_TOO_MANY_DUMPS_ERR_EID,
        -:  778:                                          CFE_EVS_ERROR,
        -:  779:                                          "Too many Dump Only Table Dumps have been requested");
        -:  780:                    }
        -:  781:                }
        -:  782:                else
        -:  783:                {
        1:  784:                    CFE_EVS_SendEvent(CFE_TBL_DUMP_PENDING_ERR_EID,
        -:  785:                                      CFE_EVS_ERROR,
        -:  786:                                      "A dump for '%s' is already pending",
        -:  787:                                      TableName);
        -:  788:                }
        -:  789:            }
        -:  790:        }
        -:  791:    }
        -:  792:    else /* Table could not be found in Registry */
        -:  793:    {
        1:  794:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -:  795:                          CFE_EVS_ERROR,
        -:  796:                          "Unable to locate '%s' in Table Registry",
        -:  797:                          TableName);
        -:  798:    }
        -:  799:
        8:  800:    return ReturnCode;
        -:  801:
        -:  802:} /* End of CFE_TBL_DumpCmd() */
        -:  803:
        -:  804:
        -:  805:/*******************************************************************
        -:  806:**
        -:  807:** CFE_TBL_DumpToFile() -- Write table data to a file
        -:  808:**
        -:  809:** NOTE: For complete prolog information, see prototype above
        -:  810:********************************************************************/
        -:  811:
        -:  812:CFE_TBL_CmdProcRet_t CFE_TBL_DumpToFile( char *DumpFilename, char *TableName, void *DumpDataAddr, uint32 TblSizeInBytes)
        9:  813:{
        9:  814:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        9:  815:    boolean                     FileExistedPrev = FALSE;
        -:  816:    CFE_FS_Header_t             StdFileHeader;
        -:  817:    CFE_TBL_File_Hdr_t          TblFileHeader;
        -:  818:    int32                       FileDescriptor;
        -:  819:    int32                       Status;
        9:  820:    int32                       EndianCheck = 0x01020304;
        -:  821:    
        -:  822:    /* Clear Header of any garbage before copying content */
        9:  823:    OS_MemSet(&StdFileHeader, 0, sizeof(CFE_FS_Header_t));
        9:  824:    OS_MemSet(&TblFileHeader, 0, sizeof(CFE_TBL_File_Hdr_t));
        -:  825:
        -:  826:    /* Check to see if the dump file already exists */
        9:  827:    FileDescriptor = OS_open(DumpFilename, OS_READ_ONLY, 0);
        -:  828:
        9:  829:    if (FileDescriptor >= 0)
        -:  830:    {
        7:  831:        FileExistedPrev = TRUE;
        -:  832:
        7:  833:        OS_close(FileDescriptor);
        -:  834:    }
        -:  835:
        -:  836:    /* Create a new dump file, overwriting anything that may have existed previously */
        9:  837:    FileDescriptor = OS_creat(DumpFilename, OS_WRITE_ONLY);
        -:  838:
        9:  839:    if (FileDescriptor >= OS_FS_SUCCESS)
        -:  840:    {
        -:  841:        /* Initialize the standard cFE File Header for the Dump File */
        8:  842:        StdFileHeader.SubType = CFE_FS_TBL_IMG_SUBTYPE;
        8:  843:        strcpy(&StdFileHeader.Description[0], "Table Dump Image");
        -:  844:
        -:  845:        /* Output the Standard cFE File Header to the Dump File */
        8:  846:        Status = CFE_FS_WriteHeader(FileDescriptor, &StdFileHeader);
        -:  847:
        8:  848:        if (Status == sizeof(CFE_FS_Header_t))
        -:  849:        {
        -:  850:            /* Initialize the Table Image Header for the Dump File */
        7:  851:            OS_MemCpy(TblFileHeader.TableName, TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        7:  852:            TblFileHeader.Offset = 0;
        7:  853:            TblFileHeader.NumBytes = TblSizeInBytes;
        7:  854:            TblFileHeader.Reserved = 0;
        -:  855:            
        -:  856:            /* Determine if this is a little endian processor */
        7:  857:            if ((*(char *)&EndianCheck) == 0x04)
        -:  858:            {
        -:  859:                /* If this is a little endian processor, then byte swap the header to a big endian format */
        -:  860:                /* to maintain the cFE Header standards */
        -:  861:                /* NOTE: FOR THE REMAINDER OF THIS FUNCTION, THE CONTENTS OF THE HEADER IS UNREADABLE BY */
        -:  862:                /*       THIS PROCESSOR!  THE DATA WOULD NEED TO BE SWAPPED BACK BEFORE READING.         */
        7:  863:                CFE_TBL_ByteSwapTblHeader(&TblFileHeader);
        -:  864:            }
        -:  865:
        -:  866:            /* Output the Table Image Header to the Dump File */
        7:  867:            Status = OS_write(FileDescriptor, &TblFileHeader, sizeof(CFE_TBL_File_Hdr_t));
        -:  868:
        -:  869:            /* Make sure the header was output completely */
        7:  870:            if (Status == sizeof(CFE_TBL_File_Hdr_t))
        -:  871:            {
        -:  872:                /* Output the requested data to the dump file */
        -:  873:                /* Output the active table image data to the dump file */
        6:  874:                Status = OS_write(FileDescriptor,
        -:  875:                                  DumpDataAddr,
        -:  876:                                  TblSizeInBytes);
        -:  877:
        6:  878:                if (Status == (int32)TblSizeInBytes)
        -:  879:                {
        5:  880:                    if (FileExistedPrev)
        -:  881:                    {
        3:  882:                        CFE_EVS_SendEvent(CFE_TBL_OVERWRITE_DUMP_INF_EID,
        -:  883:                                          CFE_EVS_INFORMATION,
        -:  884:                                          "Successfully overwrote '%s' with Table '%s'",
        -:  885:                                          DumpFilename, TableName);
        -:  886:                    }
        -:  887:                    else
        -:  888:                    {
        2:  889:                        CFE_EVS_SendEvent(CFE_TBL_WRITE_DUMP_INF_EID,
        -:  890:                                          CFE_EVS_INFORMATION,
        -:  891:                                          "Successfully dumped Table '%s' to '%s'",
        -:  892:                                          TableName, DumpFilename);
        -:  893:                    }
        -:  894:
        -:  895:                    /* Save file information statistics for housekeeping telemetry */
        5:  896:                    OS_MemCpy(CFE_TBL_TaskData.HkPacket.LastFileDumped, DumpFilename, OS_MAX_PATH_LEN);
        -:  897:
        -:  898:                    /* Increment Successful Command Counter */
        5:  899:                    ReturnCode = CFE_TBL_INC_CMD_CTR;
        -:  900:                }
        -:  901:                else
        -:  902:                {
        1:  903:                    CFE_EVS_SendEvent(CFE_TBL_WRITE_TBL_IMG_ERR_EID,
        -:  904:                                      CFE_EVS_ERROR,
        -:  905:                                      "Error writing Tbl image to '%s', Status=0x%08X",
        -:  906:                                      DumpFilename, Status);
        -:  907:                }
        -:  908:            }
        -:  909:            else
        -:  910:            {
        1:  911:                CFE_EVS_SendEvent(CFE_TBL_WRITE_TBL_HDR_ERR_EID,
        -:  912:                                  CFE_EVS_ERROR,
        -:  913:                                  "Error writing Tbl image File Header to '%s', Status=0x%08X",
        -:  914:                                  DumpFilename, Status);
        -:  915:            }
        -:  916:        }
        -:  917:        else
        -:  918:        {
        1:  919:            CFE_EVS_SendEvent(CFE_TBL_WRITE_CFE_HDR_ERR_EID,
        -:  920:                              CFE_EVS_ERROR,
        -:  921:                              "Error writing cFE File Header to '%s', Status=0x%08X",
        -:  922:                              DumpFilename, Status);
        -:  923:        }
        -:  924:
        -:  925:        /* We are done outputting data to the dump file.  Close it. */
        8:  926:        OS_close(FileDescriptor);
        -:  927:    }
        -:  928:    else
        -:  929:    {
        1:  930:        CFE_EVS_SendEvent(CFE_TBL_CREATING_DUMP_FILE_ERR_EID,
        -:  931:                          CFE_EVS_ERROR,
        -:  932:                          "Error creating dump file '%s', Status=0x%08X",
        -:  933:                          DumpFilename, FileDescriptor);
        -:  934:    }
        -:  935:    
        9:  936:    return ReturnCode;
        -:  937:}
        -:  938:
        -:  939:/*******************************************************************
        -:  940:**
        -:  941:** CFE_TBL_ValidateCmd() -- Process Validate Table Command Message
        -:  942:**
        -:  943:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -:  944:********************************************************************/
        -:  945:
        -:  946:CFE_TBL_CmdProcRet_t CFE_TBL_ValidateCmd( const CFE_SB_Msg_t *MessagePtr )
        8:  947:{
        8:  948:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -:  949:    int16                        RegIndex;
        8:  950:    const CFE_TBL_ValidateCmd_t *CmdPtr = (const CFE_TBL_ValidateCmd_t *) MessagePtr;
        -:  951:    CFE_TBL_RegistryRec_t       *RegRecPtr;
        8:  952:    void                        *ValidationDataPtr = NULL;
        -:  953:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -:  954:    uint32                       CrcOfTable;
        -:  955:    int32                        ValIndex;
        -:  956:
        -:  957:    /* Make sure all strings are null terminated before attempting to process them */
        8:  958:    OS_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        8:  959:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -:  960:
        -:  961:    /* Before doing anything, lets make sure the table that is to be dumped exists */
        8:  962:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -:  963:
        8:  964:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -:  965:    {
        -:  966:        /* Obtain a pointer to registry information about specified table */
        7:  967:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -:  968:
        -:  969:        /* Determine what data is to be validated */
        7:  970:        if (CmdPtr->ActiveTblFlag == CFE_TBL_ACTIVE_BUFFER)
        -:  971:        {
        3:  972:            ValidationDataPtr = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr;
        -:  973:        }
        4:  974:        else if (CmdPtr->ActiveTblFlag == CFE_TBL_INACTIVE_BUFFER) /* Validating Inactive Buffer */
        -:  975:        {
        -:  976:            /* If this is a double buffered table, locating the inactive buffer is trivial */
        3:  977:            if (RegRecPtr->DblBuffered)
        -:  978:            {
        1:  979:                ValidationDataPtr = RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr;
        -:  980:            }
        -:  981:            else
        -:  982:            {
        -:  983:                /* For single buffered tables, the index to the inactive buffer is kept in 'LoadInProgress' */
        2:  984:                if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  985:                {
        1:  986:                    ValidationDataPtr = CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr;
        -:  987:                }
        -:  988:                else
        -:  989:                {
        1:  990:                    CFE_EVS_SendEvent(CFE_TBL_NO_INACTIVE_BUFFER_ERR_EID,
        -:  991:                                      CFE_EVS_ERROR,
        -:  992:                                      "No Inactive Buffer for Table '%s' present",
        -:  993:                                      TableName);
        -:  994:                }
        -:  995:            }
        -:  996:        }
        -:  997:        else
        -:  998:        {
        1:  999:            CFE_EVS_SendEvent(CFE_TBL_ILLEGAL_BUFF_PARAM_ERR_EID,
        -: 1000:                              CFE_EVS_ERROR,
        -: 1001:                              "Cmd for Table '%s' had illegal buffer parameter (0x%08X)",
        -: 1002:                              TableName, CmdPtr->ActiveTblFlag);
        -: 1003:        }
        -: 1004:
        -: 1005:        /* If we have located the data to be validated, then proceed with notifying the application, if */
        -: 1006:        /* necessary, and computing the CRC value for the block of memory                               */
        7: 1007:        if (ValidationDataPtr != NULL)
        -: 1008:        {
        -: 1009:            /* Find a free Validation Response Block */
        5: 1010:            ValIndex = 0;
       20: 1011:            while ((ValIndex < CFE_TBL_MAX_NUM_VALIDATIONS) &&
        -: 1012:                   (CFE_TBL_TaskData.ValidationResults[ValIndex].State != CFE_TBL_VALIDATION_FREE))
        -: 1013:            {
       10: 1014:                ValIndex++;
        -: 1015:            }
        -: 1016:
        5: 1017:            if (ValIndex < CFE_TBL_MAX_NUM_VALIDATIONS)
        -: 1018:            {
        -: 1019:                /* Allocate this Validation Response Block */
        4: 1020:                CFE_TBL_TaskData.ValidationResults[ValIndex].State = CFE_TBL_VALIDATION_PENDING;
        4: 1021:                CFE_TBL_TaskData.ValidationResults[ValIndex].Result = 0;
        4: 1022:                OS_MemCpy(CFE_TBL_TaskData.ValidationResults[ValIndex].TableName,
        -: 1023:                          TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        -: 1024:
        -: 1025:                /* Compute the CRC on the specified table buffer */
        4: 1026:                CrcOfTable = CFE_ES_CalculateCRC(ValidationDataPtr,
        -: 1027:                                                 RegRecPtr->Size,
        -: 1028:                                                 0,
        -: 1029:                                                 CFE_ES_DEFAULT_CRC);
        -: 1030:
        4: 1031:                CFE_TBL_TaskData.ValidationResults[ValIndex].CrcOfTable = CrcOfTable;
        4: 1032:                CFE_TBL_TaskData.ValidationResults[ValIndex].ActiveBuffer = (CmdPtr->ActiveTblFlag != 0);
        -: 1033:
        -: 1034:                /* If owner has a validation function, then notify the  */
        -: 1035:                /* table owner that there is data to be validated       */
        4: 1036:                if (RegRecPtr->ValidationFuncPtr != NULL)
        -: 1037:                {
        3: 1038:                    if (CmdPtr->ActiveTblFlag)
        -: 1039:                    {
        1: 1040:                        RegRecPtr->ValidateActiveIndex = ValIndex;
        -: 1041:                    }
        -: 1042:                    else
        -: 1043:                    {
        2: 1044:                        RegRecPtr->ValidateInactiveIndex = ValIndex;
        -: 1045:                    }
        -: 1046:
        -: 1047:                    /* Notify ground that validation request has been made */
        3: 1048:                    CFE_EVS_SendEvent(CFE_TBL_VAL_REQ_MADE_INF_EID,
        -: 1049:                                      CFE_EVS_DEBUG,
        -: 1050:                                      "Tbl Services issued validation request for '%s'",
        -: 1051:                                      TableName);
        -: 1052:
        -: 1053:                    /* Maintain statistic on number of validation requests given to applications */
        3: 1054:                    CFE_TBL_TaskData.NumValRequests++;
        -: 1055:                }
        -: 1056:                else
        -: 1057:                {
        -: 1058:                    /* If there isn't a validation function pointer, then the process is complete  */
        -: 1059:                    /* By setting this value, we are letting the Housekeeping process recognize it */
        -: 1060:                    /* as data to be sent to the ground in telemetry.                              */
        1: 1061:                    CFE_TBL_TaskData.ValidationResults[ValIndex].State = CFE_TBL_VALIDATION_PERFORMED;
        -: 1062:                    
        1: 1063:                    CFE_EVS_SendEvent(CFE_TBL_ASSUMED_VALID_INF_EID,
        -: 1064:                                      CFE_EVS_INFORMATION,
        -: 1065:                                      "Tbl Services assumes '%s' is valid. No Validation Function has been registered",
        -: 1066:                                      TableName);
        -: 1067:                }
        -: 1068:
        -: 1069:                /* Increment Successful Command Counter */
        4: 1070:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1071:            }
        -: 1072:            else
        -: 1073:            {
        1: 1074:                CFE_EVS_SendEvent(CFE_TBL_TOO_MANY_VALIDATIONS_ERR_EID,
        -: 1075:                                  CFE_EVS_ERROR,
        -: 1076:                                  "Too many Table Validations have been requested");
        -: 1077:            }
        -: 1078:        }
        -: 1079:    }
        -: 1080:    else /* Table could not be found in Registry */
        -: 1081:    {
        1: 1082:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1083:                          CFE_EVS_ERROR,
        -: 1084:                          "Unable to locate '%s' in Table Registry",
        -: 1085:                          TableName);
        -: 1086:    }
        -: 1087:
        8: 1088:    return ReturnCode;
        -: 1089:
        -: 1090:} /* End of CFE_TBL_ValidateCmd() */
        -: 1091:
        -: 1092:
        -: 1093:/*******************************************************************
        -: 1094:**
        -: 1095:** CFE_TBL_ActivateCmd() -- Process Activate Table Command Message
        -: 1096:**
        -: 1097:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1098:********************************************************************/
        -: 1099:
        -: 1100:CFE_TBL_CmdProcRet_t CFE_TBL_ActivateCmd( const CFE_SB_Msg_t *MessagePtr )
        5: 1101:{
        5: 1102:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -: 1103:    int16                        RegIndex;
        5: 1104:    const CFE_TBL_ActivateCmd_t *CmdPtr = (const CFE_TBL_ActivateCmd_t *) MessagePtr;
        -: 1105:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -: 1106:    CFE_TBL_RegistryRec_t       *RegRecPtr;
        5: 1107:    boolean                      ValidationStatus = FALSE;
        -: 1108:
        -: 1109:    /* Make sure all strings are null terminated before attempting to process them */
        5: 1110:    OS_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        5: 1111:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1112:
        -: 1113:    /* Before doing anything, lets make sure the table that is to be dumped exists */
        5: 1114:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1115:
        5: 1116:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -: 1117:    {
        -: 1118:        /* Obtain a pointer to registry information about specified table */
        4: 1119:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -: 1120:        
        4: 1121:        if (RegRecPtr->DumpOnly)
        -: 1122:        {
        1: 1123:            CFE_EVS_SendEvent(CFE_TBL_ACTIVATE_DUMP_ONLY_ERR_EID,
        -: 1124:                              CFE_EVS_ERROR,
        -: 1125:                              "Illegal attempt to activate dump-only table '%s'",
        -: 1126:                              TableName);
        -: 1127:        }
        3: 1128:        else if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -: 1129:        {
        -: 1130:            /* Determine if the inactive buffer has been successfully validated or not */
        2: 1131:            if (RegRecPtr->DblBuffered)
        -: 1132:            {
        1: 1133:                ValidationStatus = RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].Validated;
        -: 1134:            }
        -: 1135:            else
        -: 1136:            {
        1: 1137:                ValidationStatus = CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Validated;
        -: 1138:            }
        -: 1139:            
        2: 1140:            if (ValidationStatus == TRUE)
        -: 1141:            {
        1: 1142:                CFE_TBL_TaskData.Registry[RegIndex].LoadPending = TRUE;
        -: 1143:
        1: 1144:                CFE_EVS_SendEvent(CFE_TBL_LOAD_PEND_REQ_INF_EID,
        -: 1145:                                  CFE_EVS_DEBUG,
        -: 1146:                                  "Tbl Services notifying App that '%s' has a load pending",
        -: 1147:                                  TableName);
        -: 1148:
        -: 1149:                /* Increment Successful Command Counter */
        1: 1150:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1151:            }
        -: 1152:            else
        -: 1153:            {
        1: 1154:                CFE_EVS_SendEvent(CFE_TBL_UNVALIDATED_ERR_EID,
        -: 1155:                                  CFE_EVS_ERROR,
        -: 1156:                                  "Cannot activate table '%s'. Inactive image not Validated",
        -: 1157:                                  TableName);
        -: 1158:            }
        -: 1159:        }
        -: 1160:        else
        -: 1161:        {
        1: 1162:            CFE_EVS_SendEvent(CFE_TBL_ACTIVATE_ERR_EID,
        -: 1163:                              CFE_EVS_ERROR,
        -: 1164:                              "Cannot activate table '%s'. No Inactive image available",
        -: 1165:                              TableName);
        -: 1166:        }
        -: 1167:    }
        -: 1168:    else /* Table could not be found in Registry */
        -: 1169:    {
        1: 1170:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1171:                          CFE_EVS_ERROR,
        -: 1172:                          "Unable to locate '%s' in Table Registry",
        -: 1173:                          TableName);
        -: 1174:    }
        -: 1175:
        5: 1176:    return ReturnCode;
        -: 1177:
        -: 1178:} /* End of CFE_TBL_ActivateCmd() */
        -: 1179:
        -: 1180:
        -: 1181:/*******************************************************************
        -: 1182:**
        -: 1183:** CFE_TBL_DumpRegCmd() -- Process Dump Table Registry to file Command Message
        -: 1184:**
        -: 1185:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1186:********************************************************************/
        -: 1187:
        -: 1188:CFE_TBL_CmdProcRet_t CFE_TBL_DumpRegCmd( const CFE_SB_Msg_t *MessagePtr )
        5: 1189:{
        5: 1190:    CFE_TBL_CmdProcRet_t        ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        5: 1191:    boolean                     FileExistedPrev = FALSE;
        -: 1192:    CFE_FS_Header_t             StdFileHeader;
        -: 1193:    int32                       FileDescriptor;
        -: 1194:    int32                       Status;
        5: 1195:    int16                       RegIndex=0;
        5: 1196:    const CFE_TBL_DumpRegCmd_t *CmdPtr = (const CFE_TBL_DumpRegCmd_t *) MessagePtr;
        -: 1197:    char                        DumpFilename[OS_MAX_PATH_LEN];
        -: 1198:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -: 1199:    CFE_TBL_Handle_t            HandleIterator;
        -: 1200:    CFE_TBL_RegDumpRec_t        DumpRecord;
        5: 1201:    int32                       FileSize=0;
        5: 1202:    int32                       NumEntries=0;
        -: 1203:
        -: 1204:    /* Copy the commanded filename into local buffer to ensure size limitation and to allow for modification */
        5: 1205:    OS_MemCpy(DumpFilename, (void *)CmdPtr->DumpFilename, OS_MAX_PATH_LEN);
        -: 1206:    
        -: 1207:    /* Check to see if a default filename should be used */
        5: 1208:    if (DumpFilename[0] == '\0')
        -: 1209:    {
        5: 1210:        strncpy(DumpFilename, CFE_TBL_DEFAULT_REG_DUMP_FILE, OS_MAX_PATH_LEN);
        -: 1211:    }
        -: 1212:
        -: 1213:    /* Make sure all strings are null terminated before attempting to process them */
        5: 1214:    DumpFilename[OS_MAX_PATH_LEN-1] = '\0';
        -: 1215:    
        -: 1216:    /* Check to see if the dump file already exists */
        5: 1217:    FileDescriptor = OS_open(DumpFilename, OS_READ_ONLY, 0);
        -: 1218:
        5: 1219:    if (FileDescriptor >= 0)
        -: 1220:    {
        4: 1221:        FileExistedPrev = TRUE;
        -: 1222:
        4: 1223:        OS_close(FileDescriptor);
        -: 1224:    }
        -: 1225:
        -: 1226:    /* Create a new dump file, overwriting anything that may have existed previously */
        5: 1227:    FileDescriptor = OS_creat(DumpFilename, OS_WRITE_ONLY);
        -: 1228:
        5: 1229:    if (FileDescriptor >= OS_FS_SUCCESS)
        -: 1230:    {
        -: 1231:        /* Initialize the standard cFE File Header for the Dump File */
        4: 1232:        StdFileHeader.SubType = CFE_FS_TBL_REG_SUBTYPE;
        4: 1233:        strcpy(&StdFileHeader.Description[0], "Table Registry");
        -: 1234:
        -: 1235:        /* Output the Standard cFE File Header to the Dump File */
        4: 1236:        Status = CFE_FS_WriteHeader(FileDescriptor, &StdFileHeader);
        -: 1237:        
        -: 1238:        /* Maintain statistics of amount of data written to file */
        4: 1239:        FileSize += Status;
        -: 1240:
        4: 1241:        if (Status == sizeof(CFE_FS_Header_t))
        -: 1242:        {
        3: 1243:            Status = sizeof(CFE_TBL_RegDumpRec_t);
      263: 1244:            while ((RegIndex < CFE_TBL_MAX_NUM_TABLES) && (Status == sizeof(CFE_TBL_RegDumpRec_t)))
        -: 1245:            {
        -: 1246:                /* Make a pointer to simplify code look and to remove redundant indexing into registry */
      257: 1247:                RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -: 1248:
        -: 1249:                /* Check to see if the Registry entry is empty */
      257: 1250:                if ((RegRecPtr->OwnerAppId != CFE_TBL_NOT_OWNED) ||
        -: 1251:                    (RegRecPtr->HeadOfAccessList != CFE_TBL_END_OF_LIST))
        -: 1252:                {
        -: 1253:                    /* Fill Registry Dump Record with relevant information */
      255: 1254:                    DumpRecord.Size             = RegRecPtr->Size;
      255: 1255:                    DumpRecord.TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
      255: 1256:                    DumpRecord.LoadInProgress   = RegRecPtr->LoadInProgress;
      255: 1257:                    DumpRecord.ValidationFunc   = (RegRecPtr->ValidationFuncPtr != NULL);
      255: 1258:                    DumpRecord.TableLoadedOnce  = RegRecPtr->TableLoadedOnce;
      255: 1259:                    DumpRecord.LoadPending      = RegRecPtr->LoadPending;
      255: 1260:                    DumpRecord.DumpOnly         = RegRecPtr->DumpOnly;
      255: 1261:                    DumpRecord.DblBuffered      = RegRecPtr->DblBuffered;
      255: 1262:                    DumpRecord.FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
      255: 1263:                    DumpRecord.FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
      255: 1264:                    DumpRecord.CriticalTable    = RegRecPtr->CriticalTable;
        -: 1265:
        -: 1266:                    /* Convert LoadInProgress flag into more meaningful information */
        -: 1267:                    /* When a load is in progress, identify which buffer is being used as the inactive buffer */
      255: 1268:                    if (DumpRecord.LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -: 1269:                    {
      255: 1270:                        if (DumpRecord.DblBuffered)
        -: 1271:                        {
        -: 1272:                            /* For double buffered tables, the value of LoadInProgress, when a load is actually in progress, */
        -: 1273:                            /* should identify either buffer #0 or buffer #1.  Convert these to enumerated value for ground  */
        -: 1274:                            /* display.  LoadInProgress = -2 means Buffer #1, LoadInProgress = -3 means Buffer #0.           */
        3: 1275:                            DumpRecord.LoadInProgress = DumpRecord.LoadInProgress - 3;
        -: 1276:                        }
        -: 1277:                        /* For single buffered tables, the value of LoadInProgress, when a load is actually in progress,     */
        -: 1278:                        /* indicates which shared buffer is allocated for the inactive buffer.  Since the number of inactive */
        -: 1279:                        /* buffers is a platform configuration parameter, then 0 on up merely identifies the buffer number.  */
        -: 1280:                        /* No translation is necessary for single buffered tables.                                           */
        -: 1281:                    }
        -: 1282:                    
        -: 1283:                    /* Zero character arrays to remove garbage text */
      255: 1284:                    OS_MemSet(DumpRecord.Name, 0, CFE_TBL_MAX_FULL_NAME_LEN);
      255: 1285:                    OS_MemSet(DumpRecord.LastFileLoaded, 0, OS_MAX_PATH_LEN);
      255: 1286:                    OS_MemSet(DumpRecord.OwnerAppName, 0, OS_MAX_API_NAME);
        -: 1287:
      255: 1288:                    strncpy(DumpRecord.Name, RegRecPtr->Name, CFE_TBL_MAX_FULL_NAME_LEN);
      255: 1289:                    strncpy(DumpRecord.LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        -: 1290:
        -: 1291:                    /* Walk the access descriptor list to determine the number of users */
      255: 1292:                    DumpRecord.NumUsers = 0;
      255: 1293:                    HandleIterator = RegRecPtr->HeadOfAccessList;
      511: 1294:                    while (HandleIterator != CFE_TBL_END_OF_LIST)
        -: 1295:                    {
        1: 1296:                        DumpRecord.NumUsers++;
        1: 1297:                        HandleIterator = CFE_TBL_TaskData.Handles[HandleIterator].NextLink;
        -: 1298:                    }
        -: 1299:
        -: 1300:                    /* Determine the name of the owning application */
      255: 1301:                    if (RegRecPtr->OwnerAppId != CFE_TBL_NOT_OWNED)
        -: 1302:                    {
      254: 1303:                        CFE_ES_GetAppName(DumpRecord.OwnerAppName, RegRecPtr->OwnerAppId, OS_MAX_API_NAME);
        -: 1304:                    }
        -: 1305:                    else
        -: 1306:                    {
        1: 1307:                        strncpy(DumpRecord.OwnerAppName, "--UNOWNED--", OS_MAX_API_NAME);
        -: 1308:                    }
        -: 1309:
        -: 1310:                    /* Output Registry Dump Record to Registry Dump File */
      255: 1311:                    Status = OS_write(FileDescriptor,
        -: 1312:                                      &DumpRecord,
        -: 1313:                                      sizeof(CFE_TBL_RegDumpRec_t));
        -: 1314:                    
      255: 1315:                    FileSize += Status;
      255: 1316:                    NumEntries++;      
        -: 1317:                }
        -: 1318:
        -: 1319:                /* Look at the next entry in the Registry */
      257: 1320:                RegIndex++;
        -: 1321:            }
        -: 1322:
        3: 1323:            if (Status == sizeof(CFE_TBL_RegDumpRec_t))
        -: 1324:            {
        2: 1325:                if (FileExistedPrev)
        -: 1326:                {
        1: 1327:                    CFE_EVS_SendEvent(CFE_TBL_OVERWRITE_REG_DUMP_INF_EID,
        -: 1328:                                      CFE_EVS_DEBUG,
        -: 1329:                                      "Successfully overwrote '%s' with Table Registry:Size=%d,Entries=%d",
        -: 1330:                                      DumpFilename, FileSize, NumEntries);
        -: 1331:                }
        -: 1332:                else
        -: 1333:                {
        1: 1334:                    CFE_EVS_SendEvent(CFE_TBL_WRITE_REG_DUMP_INF_EID,
        -: 1335:                                      CFE_EVS_DEBUG,
        -: 1336:                                      "Successfully dumped Table Registry to '%s':Size=%d,Entries=%d",
        -: 1337:                                      DumpFilename, FileSize, NumEntries);
        -: 1338:                }
        -: 1339:
        -: 1340:                /* Increment Successful Command Counter */
        2: 1341:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1342:            }
        -: 1343:            else
        -: 1344:            {
        1: 1345:                CFE_EVS_SendEvent(CFE_TBL_WRITE_TBL_REG_ERR_EID,
        -: 1346:                                  CFE_EVS_ERROR,
        -: 1347:                                  "Error writing Registry to '%s', Status=0x%08X",
        -: 1348:                                  DumpFilename, Status);
        -: 1349:            }
        -: 1350:        }
        -: 1351:        else
        -: 1352:        {
        1: 1353:            CFE_EVS_SendEvent(CFE_TBL_WRITE_CFE_HDR_ERR_EID,
        -: 1354:                              CFE_EVS_ERROR,
        -: 1355:                              "Error writing cFE File Header to '%s', Status=0x%08X",
        -: 1356:                              DumpFilename, Status);
        -: 1357:        }
        -: 1358:
        -: 1359:        /* We are done outputting data to the dump file.  Close it. */
        4: 1360:        OS_close(FileDescriptor);
        -: 1361:    }
        -: 1362:    else
        -: 1363:    {
        1: 1364:        CFE_EVS_SendEvent(CFE_TBL_CREATING_DUMP_FILE_ERR_EID,
        -: 1365:                          CFE_EVS_ERROR,
        -: 1366:                          "Error creating dump file '%s', Status=0x%08X",
        -: 1367:                          DumpFilename, FileDescriptor);
        -: 1368:    }
        -: 1369:
        5: 1370:    return ReturnCode;
        -: 1371:
        -: 1372:} /* End of CFE_TBL_DumpRegCmd() */
        -: 1373:
        -: 1374:
        -: 1375:/*******************************************************************
        -: 1376:**
        -: 1377:** CFE_TBL_TlmRegCmd() -- Process Telemeter Table Registry Entry Command Message
        -: 1378:**
        -: 1379:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1380:********************************************************************/
        -: 1381:
        -: 1382:CFE_TBL_CmdProcRet_t CFE_TBL_TlmRegCmd( const CFE_SB_Msg_t *MessagePtr )
        3: 1383:{
        3: 1384:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -: 1385:    int16                        RegIndex;
        3: 1386:    const CFE_TBL_TlmRegCmd_t   *CmdPtr = (const CFE_TBL_TlmRegCmd_t *) MessagePtr;
        -: 1387:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -: 1388:
        -: 1389:    /* Make sure all strings are null terminated before attempting to process them */
        3: 1390:    OS_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        3: 1391:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1392:
        -: 1393:    /* Before doing anything, lets make sure the table registry entry that is to be telemetered exists */
        3: 1394:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1395:
        3: 1396:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -: 1397:    {
        -: 1398:        /* Change the index used to identify what data is to be telemetered */
        2: 1399:        CFE_TBL_TaskData.HkTlmTblRegIndex = RegIndex;
        -: 1400:
        2: 1401:        CFE_EVS_SendEvent(CFE_TBL_TLM_REG_CMD_INF_EID,
        -: 1402:                          CFE_EVS_DEBUG,
        -: 1403:                          "Table Registry entry for '%s' will be telemetered",
        -: 1404:                          TableName);
        -: 1405:
        -: 1406:        /* Increment Successful Command Counter */
        2: 1407:        ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1408:    }
        -: 1409:    else /* Table could not be found in Registry */
        -: 1410:    {
        1: 1411:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1412:                          CFE_EVS_ERROR,
        -: 1413:                          "Unable to locate '%s' in Table Registry",
        -: 1414:                          TableName);
        -: 1415:    }
        -: 1416:
        3: 1417:    return ReturnCode;
        -: 1418:
        -: 1419:} /* End of CFE_TBL_TlmRegCmd() */
        -: 1420:
        -: 1421:
        -: 1422:/*******************************************************************
        -: 1423:**
        -: 1424:** CFE_TBL_DeleteCDSCmd() -- Process Delete Critical Table's CDS Command Message
        -: 1425:**
        -: 1426:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1427:********************************************************************/
        -: 1428:
        -: 1429:CFE_TBL_CmdProcRet_t CFE_TBL_DeleteCDSCmd( const CFE_SB_Msg_t *MessagePtr )
        7: 1430:{
        7: 1431:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        7: 1432:    const CFE_TBL_DelCDSCmd_t   *CmdPtr = (const CFE_TBL_DelCDSCmd_t *) MessagePtr;
        -: 1433:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        7: 1434:    CFE_TBL_CritRegRec_t        *CritRegRecPtr = NULL;
        -: 1435:    uint32                       i;
        -: 1436:    uint32                       RegIndex;
        -: 1437:    int32                        Status;
        -: 1438:
        -: 1439:    /* Make sure all strings are null terminated before attempting to process them */
        7: 1440:    OS_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        7: 1441:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1442:
        -: 1443:    /* Before doing anything, lets make sure the table is no longer in the registry */
        -: 1444:    /* This would imply that the owning application has been terminated and that it */
        -: 1445:    /* is safe to delete the associated critical table image in the CDS. */
        7: 1446:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1447:
        7: 1448:    if (RegIndex == CFE_TBL_NOT_FOUND)
        -: 1449:    {
        -: 1450:        /* Find table in the Critical Table Registry */
      198: 1451:        for (i=0; i<CFE_TBL_MAX_CRITICAL_TABLES; i++)
        -: 1452:        {
      192: 1453:            if (strncmp(CFE_TBL_TaskData.CritReg[i].Name, TableName, CFE_TBL_MAX_FULL_NAME_LEN) == 0)
        -: 1454:            {
        5: 1455:                CritRegRecPtr = &CFE_TBL_TaskData.CritReg[i];
        5: 1456:                i=CFE_TBL_MAX_CRITICAL_TABLES;
        -: 1457:            }
        -: 1458:        }
        -: 1459:        
        6: 1460:        if (CritRegRecPtr != NULL)
        -: 1461:        {
        5: 1462:            Status = CFE_ES_DeleteCDS(TableName, TRUE);
        -: 1463:        
        5: 1464:            if (Status == CFE_ES_CDS_WRONG_TYPE_ERR)
        -: 1465:            {
        1: 1466:                CFE_EVS_SendEvent(CFE_TBL_NOT_CRITICAL_TBL_ERR_EID,
        -: 1467:                                  CFE_EVS_ERROR,
        -: 1468:                                  "Table '%s' is in Critical Table Registry but CDS is not tagged as a table",
        -: 1469:                                  TableName);
        -: 1470:            }
        4: 1471:            else if (Status == CFE_ES_CDS_OWNER_ACTIVE_ERR)
        -: 1472:            {
        1: 1473:                CFE_EVS_SendEvent(CFE_TBL_CDS_OWNER_ACTIVE_ERR_EID, CFE_EVS_ERROR,
        -: 1474:                                  "CDS '%s' owning app is still active", 
        -: 1475:                                  TableName, Status);
        -: 1476:            }
        3: 1477:            else if (Status == CFE_ES_CDS_NOT_FOUND_ERR)
        -: 1478:            {
        1: 1479:                CFE_EVS_SendEvent(CFE_TBL_CDS_NOT_FOUND_ERR_EID, CFE_EVS_ERROR,        
        -: 1480:                                 "Unable to locate '%s' in CDS Registry", TableName);
        -: 1481:            }
        2: 1482:            else if (Status != CFE_SUCCESS)
        -: 1483:            {
        1: 1484:                CFE_EVS_SendEvent(CFE_TBL_CDS_DELETE_ERR_EID, CFE_EVS_ERROR,
        -: 1485:                                  "Error while deleting '%s' from CDS, See SysLog.(Err=0x%08X)", 
        -: 1486:                                  TableName, Status);
        -: 1487:            }
        -: 1488:            else
        -: 1489:            {
        1: 1490:                CFE_EVS_SendEvent(CFE_TBL_CDS_DELETED_INFO_EID, CFE_EVS_INFORMATION,
        -: 1491:                                  "Successfully removed '%s' from CDS", TableName);
        -: 1492:                            
        -: 1493:                /* Free the entry in the Critical Table Registry */      
        1: 1494:                CritRegRecPtr->CDSHandle = CFE_ES_CDS_BAD_HANDLE;
        -: 1495:                     
        -: 1496:                /* Increment Successful Command Counter */
        1: 1497:                ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1498:            }
        -: 1499:        }
        -: 1500:        else
        -: 1501:        {
        1: 1502:            CFE_EVS_SendEvent(CFE_TBL_NOT_IN_CRIT_REG_ERR_EID,
        -: 1503:                              CFE_EVS_ERROR,
        -: 1504:                              "Table '%s' is not found in Critical Table Registry",
        -: 1505:                              TableName);
        -: 1506:        }      
        -: 1507:    }
        -: 1508:    else /* Table was found in Registry */
        -: 1509:    {
        1: 1510:        CFE_EVS_SendEvent(CFE_TBL_IN_REGISTRY_ERR_EID,
        -: 1511:                          CFE_EVS_ERROR,
        -: 1512:                          "'%s' found in Table Registry. CDS cannot be deleted until table is unregistered",
        -: 1513:                          TableName);
        -: 1514:    }
        7: 1515:    return ReturnCode;
        -: 1516:
        -: 1517:} /* End of CFE_TBL_DeleteCDSCmd() */
        -: 1518:
        -: 1519:
        -: 1520:/*******************************************************************
        -: 1521:**
        -: 1522:** CFE_TBL_AbortLoadCmd() -- Process Abort Load Command Message
        -: 1523:**
        -: 1524:** NOTE: For complete prolog information, see 'cfe_tbl_task_cmds.h'
        -: 1525:********************************************************************/
        -: 1526:
        -: 1527:CFE_TBL_CmdProcRet_t CFE_TBL_AbortLoadCmd( const CFE_SB_Msg_t *MessagePtr )
        3: 1528:{
        3: 1529:    CFE_TBL_CmdProcRet_t         ReturnCode = CFE_TBL_INC_ERR_CTR;        /* Assume failure */
        -: 1530:    int16                        RegIndex;
        3: 1531:    const CFE_TBL_AbortLdCmd_t  *CmdPtr = (const CFE_TBL_AbortLdCmd_t *) MessagePtr;
        -: 1532:    CFE_TBL_RegistryRec_t       *RegRecPtr;
        -: 1533:    char                         TableName[CFE_TBL_MAX_FULL_NAME_LEN];
        -: 1534:
        -: 1535:    /* Make sure all strings are null terminated before attempting to process them */
        3: 1536:    OS_MemCpy(TableName, (void *)CmdPtr->TableName, CFE_TBL_MAX_FULL_NAME_LEN);
        3: 1537:    TableName[CFE_TBL_MAX_FULL_NAME_LEN-1] = '\0';
        -: 1538:
        -: 1539:    /* Before doing anything, lets make sure the table registry entry that is to be telemetered exists */
        3: 1540:    RegIndex = CFE_TBL_FindTableInRegistry(TableName);
        -: 1541:
        3: 1542:    if (RegIndex != CFE_TBL_NOT_FOUND)
        -: 1543:    {
        -: 1544:        /* Make a pointer to simplify code look and to remove redundant indexing into registry */
        2: 1545:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndex];
        -: 1546:
        -: 1547:        /* Check to make sure a load was in progress before trying to abort it */
        -: 1548:        /* NOTE: LoadInProgress contains index of buffer when dumping a dump-only table */
        -: 1549:        /* so we must ensure the table is not a dump-only table, otherwise, we would be aborting a dump */
        3: 1550:        if ((RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS) && (!RegRecPtr->DumpOnly))
        -: 1551:        {
        1: 1552:            CFE_TBL_AbortLoad(RegRecPtr);
        -: 1553:
        -: 1554:            /* Increment Successful Command Counter */
        1: 1555:            ReturnCode = CFE_TBL_INC_CMD_CTR;
        -: 1556:        }
        -: 1557:        else
        -: 1558:        {
        1: 1559:            CFE_EVS_SendEvent(CFE_TBL_LOAD_ABORT_ERR_EID,
        -: 1560:                              CFE_EVS_ERROR,
        -: 1561:                              "Cannot abort load of '%s'. No load started.",
        -: 1562:                              TableName);
        -: 1563:        }
        -: 1564:    }
        -: 1565:    else /* Table could not be found in Registry */
        -: 1566:    {
        1: 1567:        CFE_EVS_SendEvent(CFE_TBL_NO_SUCH_TABLE_ERR_EID,
        -: 1568:                          CFE_EVS_ERROR,
        -: 1569:                          "Unable to locate '%s' in Table Registry",
        -: 1570:                          TableName);
        -: 1571:    }
        -: 1572:
        3: 1573:    return ReturnCode;
        -: 1574:
        -: 1575:} /* End of CFE_TBL_AbortLoadCmd() */
        -: 1576:
        -: 1577:
        -: 1578:/*******************************************************************
        -: 1579:**
        -: 1580:** CFE_TBL_AbortLoad() -- Abort load, free buffers, issue event message
        -: 1581:**
        -: 1582:** NOTE: For complete prolog information, see above
        -: 1583:********************************************************************/
        -: 1584:
        -: 1585:void CFE_TBL_AbortLoad(CFE_TBL_RegistryRec_t *RegRecPtr)
        1: 1586:{
        -: 1587:    /* The ground has aborted the load, free the working buffer for another attempt */
        1: 1588:    if (!RegRecPtr->DblBuffered)
        -: 1589:    {
        -: 1590:        /* For single buffered tables, freeing shared buffer entails resetting flag */
        1: 1591:        CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        -: 1592:    }
        -: 1593:
        -: 1594:    /* For double buffered tables, freeing buffer is simple */
        1: 1595:    RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -: 1596:    
        -: 1597:    /* Make sure the load was not already pending */
        1: 1598:    RegRecPtr->LoadPending = FALSE;
        -: 1599:
        1: 1600:    CFE_EVS_SendEvent(CFE_TBL_LOAD_ABORT_INF_EID,
        -: 1601:                      CFE_EVS_INFORMATION,
        -: 1602:                      "Table Load Aborted for '%s'",
        -: 1603:                      RegRecPtr->Name);
        1: 1604:}
        -: 1605:
        -: 1606:/************************/
        -: 1607:/*  End of File Comment */
        -: 1608:/************************/
        -: 1609:
