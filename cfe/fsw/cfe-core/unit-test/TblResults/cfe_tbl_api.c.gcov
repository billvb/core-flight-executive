        -:    0:Source:/mnt/hgfs/Proj/cFE/Builds/Trunk/fsw/cfe-core/src/tbl/cfe_tbl_api.c
        -:    0:Graph:cfe_tbl_api.gcno
        -:    0:Data:cfe_tbl_api.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:** $Id: cfe_tbl_api.c.gcov 1.8 2009/05/01 16:37:20EDT dkobe Exp  $
        -:    3:**
        -:    4:**      Copyright © 2004-2006, United States government as represented by the 
        -:    5:**      administrator of the National Aeronautics Space Administration.  
        -:    6:**      All rights reserved. This software(cFE) was created at NASA’s Goddard 
        -:    7:**      Space Flight Center pursuant to government contracts.
        -:    8:**
        -:    9:**      This software may be used only pursuant to a United States government 
        -:   10:**      sponsored project and the United States government may not be charged
        -:   11:**      for use thereof.  
        -:   12:**
        -:   13:** Purpose:  cFE Table Services (TBL) library API source file
        -:   14:**
        -:   15:** Author:   D. Kobe/the Hammers Company, Inc.
        -:   16:**
        -:   17:** Notes:
        -:   18:**
        -:   19:** $Log: cfe_tbl_api.c.gcov  $
        -:   19:** Revision 1.8 2009/05/01 16:37:20EDT dkobe 
        -:   19:** Updated for checking for positive return codes from table validation functions
        -:   20:** Revision 1.8 2009/05/01 15:12:41EDT dkobe 
        -:   21:** Corrected SysLog format string
        -:   22:** Revision 1.7 2009/05/01 13:41:38EDT dkobe 
        -:   23:** Modified SysLog Msg for zero length table name
        -:   24:** Revision 1.6 2008/07/29 18:32:16EDT dkobe 
        -:   25:** Added CFE_TBL_Modified API
        -:   26:** Revision 1.5 2008/07/29 15:55:17EDT dkobe 
        -:   27:** Moved CFE_TBL_DumpToBuffer from cfe_tbl_internal.c to cfe_tbl_api.c
        -:   28:** Revision 1.4 2008/07/29 14:05:37EDT dkobe 
        -:   29:** Removed redundant FileCreateTimeSecs and FileCreateTimeSubSecs fields
        -:   30:** Revision 1.3 2008/07/21 14:58:07EDT dkobe 
        -:   31:** Added check in CFE_TBL_Manage function that forces the CFE_TBL_INFO_UPDATED 
        -:   32:** return status code when a CFE_TBL_Update call is made successfully.
        -:   33:** Revision 1.2 2008/07/21 14:49:55EDT dkobe 
        -:   34:** Corrected temporary code with proper assignment statement in CFE_TBL_GetInfo
        -:   35:** Revision 1.1 2008/04/17 08:05:34EDT ruperera 
        -:   36:** Initial revision
        -:   37:**
        -:   38:**
        -:   39:*/
        -:   40:
        -:   41:
        -:   42:/*
        -:   43:** Required header files...
        -:   44:*/
        -:   45:#include <string.h>
        -:   46:#include "cfe_es.h"
        -:   47:#include "cfe_tbl.h"
        -:   48:#include "cfe_error.h"
        -:   49:#include "cfe_tbl_internal.h"
        -:   50:
        -:   51:
        -:   52:/*
        -:   53:** External Globals
        -:   54:*/
        -:   55:extern CFE_TBL_TaskData_t CFE_TBL_TaskData;
        -:   56:
        -:   57:/*******************************************************************
        -:   58:**
        -:   59:** CFE_ES_RegisterCDSEx
        -:   60:**
        -:   61:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:   62:********************************************************************/
        -:   63:int32 CFE_ES_RegisterCDSEx(CFE_ES_CDSHandle_t *HandlePtr, int32 BlockSize, const char *Name, boolean CriticalTbl);
        -:   64:
        -:   65:/*
        -:   66:** Local Macros
        -:   67:*/
        -:   68:
        -:   69:/*******************************************************************
        -:   70:**
        -:   71:** CFE_TBL_Register() -- Register a table with cFE to obtain
        -:   72:**                       Table Management Services
        -:   73:**
        -:   74:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:   75:********************************************************************/
        -:   76:int32 CFE_TBL_Register( CFE_TBL_Handle_t *TblHandlePtr,
        -:   77:                        const char *Name,
        -:   78:                        uint32  Size,
        -:   79:                        uint16  TblOptionFlags,
        -:   80:                        CFE_TBL_CallbackFuncPtr_t TblValidationFuncPtr )
      170:   81:{
      170:   82:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
      170:   83:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        -:   84:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
      170:   85:    CFE_TBL_CritRegRec_t       *CritRegRecPtr = NULL;
      170:   86:    int32                       Status = CFE_SUCCESS;
      170:   87:    int32                       NameLen = 0;
      170:   88:    int16                       RegIndx = -1;
        -:   89:    uint32                      ThisAppId;
      170:   90:    char                        AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
      170:   91:    char                        TblName[CFE_TBL_MAX_FULL_NAME_LEN] = {""};
        -:   92:    char                        LogMsg[128];
        -:   93:    CFE_TBL_Handle_t            AccessIndex;
        -:   94:
        -:   95:    /* Check to make sure calling application is legit */
      170:   96:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -:   97:
      170:   98:    if (Status == CFE_SUCCESS)
        -:   99:    {
        -:  100:        /* Assume we can't make a table and return a bad handle for now */
      168:  101:        *TblHandlePtr = CFE_TBL_BAD_TABLE_HANDLE;
        -:  102:
        -:  103:        /* Make sure specified table name is not too long or too short */
      168:  104:        NameLen = strlen(Name);
      170:  105:        if ((NameLen > CFE_TBL_MAX_NAME_LENGTH) || (NameLen == 0))
        -:  106:        {
        2:  107:            Status = CFE_TBL_ERR_INVALID_NAME;
        -:  108:
        -:  109:            /* Perform a buffer overrun safe copy of name for debug log message */
        2:  110:            strncpy(LogMsg, "CFE_TBL:Register-Table Name (", 29);
        2:  111:            strncpy(&LogMsg[29], Name, 70);
        2:  112:            if (NameLen == 0)
        -:  113:            {
        1:  114:                strcat(LogMsg, ") is zero length\n");
        -:  115:            }
        -:  116:            else
        -:  117:            {
        1:  118:                strcat(LogMsg, ") is too long\n");
        -:  119:            }
        2:  120:            CFE_ES_WriteToSysLog(LogMsg);
        -:  121:
        2:  122:            strncpy(TblName, Name, CFE_TBL_MAX_NAME_LENGTH);
        2:  123:            TblName[CFE_TBL_MAX_NAME_LENGTH-1] = '\0';
        -:  124:        }
        -:  125:        else
        -:  126:        {
        -:  127:            /* Modify specified name to be processor specific name */
        -:  128:            /* of the form "AppName.TableName"                     */
      166:  129:            CFE_TBL_FormTableName(TblName, Name, ThisAppId);
        -:  130:
        -:  131:           /* Make sure the specified size is acceptable */
        -:  132:            /* Single buffered tables are allowed to be up to CFE_TBL_MAX_SNGL_TABLE_SIZE */
        -:  133:            /* Double buffered tables are allowed to be up to CFE_TBL_MAX_DBL_TABLE_SIZE  */
      166:  134:            if (Size == 0)
        -:  135:            {
        1:  136:                Status = CFE_TBL_ERR_INVALID_SIZE;
        -:  137:
        1:  138:                CFE_ES_WriteToSysLog("CFE_TBL:Register-Table %s has size of zero\n", Name);
        -:  139:            }
      166:  140:            else if ((Size > CFE_TBL_MAX_SNGL_TABLE_SIZE) &&
        -:  141:                     ((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_SNGL_BUFFER))
        -:  142:            {
        1:  143:                Status = CFE_TBL_ERR_INVALID_SIZE;
        -:  144:
        1:  145:                CFE_ES_WriteToSysLog("CFE_TBL:Register-Single Buffered Table '%s' has size %d > %d\n",
        -:  146:                                     Name, Size, CFE_TBL_MAX_SNGL_TABLE_SIZE);
        -:  147:            }
      164:  148:            else if ((Size > CFE_TBL_MAX_DBL_TABLE_SIZE) &&
        -:  149:                     ((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_DBL_BUFFER))
        -:  150:            {
        1:  151:                Status = CFE_TBL_ERR_INVALID_SIZE;
        -:  152:
        1:  153:                CFE_ES_WriteToSysLog("CFE_TBL:Register-Dbl Buffered Table '%s' has size %d > %d\n",
        -:  154:                                     Name, Size, CFE_TBL_MAX_DBL_TABLE_SIZE);
        -:  155:            }
        -:  156:            
        -:  157:            /* Verify Table Option settings are legal */
        -:  158:            /* User defined table addresses are only legal for single buffered, dump-only, non-critical tables */
      166:  159:            if ((TblOptionFlags & CFE_TBL_OPT_USR_DEF_MSK) == (CFE_TBL_OPT_USR_DEF_ADDR & CFE_TBL_OPT_USR_DEF_MSK))
        -:  160:            {
        5:  161:                if (((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_DBL_BUFFER) ||
        -:  162:                    ((TblOptionFlags & CFE_TBL_OPT_LD_DMP_MSK) == CFE_TBL_OPT_LOAD_DUMP) ||
        -:  163:                    ((TblOptionFlags & CFE_TBL_OPT_CRITICAL_MSK) == CFE_TBL_OPT_CRITICAL))
        -:  164:                {
        3:  165:                    Status = CFE_TBL_ERR_INVALID_OPTIONS;
        -:  166:                    
        3:  167:                    CFE_ES_WriteToSysLog("CFE_TBL:Register-User Def tbl '%s' cannot be dbl buff, load/dump or critical\n",
        -:  168:                                         Name);
        -:  169:                }
        -:  170:            }
      161:  171:            else if ((TblOptionFlags & CFE_TBL_OPT_LD_DMP_MSK) == CFE_TBL_OPT_DUMP_ONLY)
        -:  172:            {
        -:  173:                /* Dump Only tables cannot be double buffered, nor critical */
        3:  174:                if (((TblOptionFlags & CFE_TBL_OPT_BUFFER_MSK) == CFE_TBL_OPT_DBL_BUFFER) ||
        -:  175:                    ((TblOptionFlags & CFE_TBL_OPT_CRITICAL_MSK) == CFE_TBL_OPT_CRITICAL))
        -:  176:                {
        1:  177:                    Status = CFE_TBL_ERR_INVALID_OPTIONS;
        -:  178:                    
        1:  179:                    CFE_ES_WriteToSysLog("CFE_TBL:Register-Dump Only tbl '%s' cannot be double buffered or critical\n",
        -:  180:                                         Name);
        -:  181:                }
        -:  182:            }
        -:  183:        }
        -:  184:    }
        -:  185:    else  /* Application ID was invalid */
        -:  186:    {
        2:  187:        CFE_ES_WriteToSysLog("CFE_TBL:Register-Bad AppId(%d)\n", ThisAppId);
        -:  188:    }
        -:  189:
        -:  190:    /* If input parameters appear acceptable, register the table */
      170:  191:    if (Status == CFE_SUCCESS)
        -:  192:    {
        -:  193:        /* Lock Registry for update.  This prevents two applications from        */
        -:  194:        /* trying to register/share tables at the same location at the same time */
      159:  195:        CFE_TBL_LockRegistry();
        -:  196:
        -:  197:        /* Check for duplicate table name */
      159:  198:        RegIndx = CFE_TBL_FindTableInRegistry(TblName);
        -:  199:
        -:  200:        /* Check to see if table is already in the registry */
      159:  201:        if (RegIndx != CFE_TBL_NOT_FOUND)
        -:  202:        {
        -:  203:            /* Get pointer to Registry Record Entry to speed up processing */
        3:  204:            RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -:  205:
        -:  206:            /* If this app previously owned the table, then allow them to re-register */
        3:  207:            if (RegRecPtr->OwnerAppId == ThisAppId)
        -:  208:            {
        -:  209:                /* If the new table is the same size as the old, then no need to reallocate memory */
        2:  210:                if (Size != RegRecPtr->Size)
        -:  211:                {
        -:  212:                    /* If the new size is different, the old table must deleted      */
        -:  213:                    /* but this function can't do that because it is probably shared */
        -:  214:                    /* and is probably still being accessed.  Someone else will need */
        -:  215:                    /* to clean up this mess.                                        */
        1:  216:                    Status = CFE_TBL_ERR_DUPLICATE_DIFF_SIZE;
        -:  217:
        1:  218:                    CFE_ES_WriteToSysLog("CFE_TBL:Register-Attempt to register existing table ('%s') with different size(%d!=%d)\n",
        -:  219:                                         TblName, Size, RegRecPtr->Size);
        -:  220:                }
        -:  221:                else
        -:  222:                {
        -:  223:                    /* Warn calling application that this is a duplicate registration */
        1:  224:                    Status = CFE_TBL_WARN_DUPLICATE;
        -:  225:                    
        -:  226:                    /* Find the existing access descriptor for the table       */
        -:  227:                    /* and return the same handle that was returned previously */
        1:  228:                    AccessIndex = RegRecPtr->HeadOfAccessList;
        4:  229:                    while ((AccessIndex != CFE_TBL_END_OF_LIST) && (*TblHandlePtr == CFE_TBL_BAD_TABLE_HANDLE))
        -:  230:                    {
        3:  231:                        if ((CFE_TBL_TaskData.Handles[AccessIndex].UsedFlag == TRUE) &&
        -:  232:                            (CFE_TBL_TaskData.Handles[AccessIndex].AppId == ThisAppId) &&
        -:  233:                            (CFE_TBL_TaskData.Handles[AccessIndex].RegIndex == RegIndx))
        -:  234:                        {
        1:  235:                            *TblHandlePtr = AccessIndex;
        -:  236:                        }
        -:  237:                        else
        -:  238:                        {
        1:  239:                            AccessIndex = CFE_TBL_TaskData.Handles[AccessIndex].NextLink;
        -:  240:                        }
        -:  241:                    }
        -:  242:                }
        -:  243:            }
        -:  244:            else /* Duplicate named table owned by another Application */
        -:  245:            {
        1:  246:                Status = CFE_TBL_ERR_DUPLICATE_NOT_OWNED;
        -:  247:
        1:  248:                CFE_ES_WriteToSysLog("CFE_TBL:Register-App(%d) Registering Duplicate Table '%s' owned by App(%d)\n",
        -:  249:                                     ThisAppId, TblName, RegRecPtr->OwnerAppId);
        -:  250:            }
        -:  251:        }
        -:  252:        else  /* Table not already in registry */
        -:  253:        {
        -:  254:            /* Locate empty slot in table registry */
      156:  255:            RegIndx = CFE_TBL_FindFreeRegistryEntry();
        -:  256:        }
        -:  257:
        -:  258:        /* Check to make sure we found a free entry in registry */
      159:  259:        if (RegIndx == CFE_TBL_NOT_FOUND)
        -:  260:        {
        1:  261:            Status = CFE_TBL_ERR_REGISTRY_FULL;
        1:  262:            CFE_ES_WriteToSysLog("CFE_TBL:Register-Registry full\n");
        -:  263:        }
        -:  264:
        -:  265:        /* If this is a duplicate registration, no other work is required */
      159:  266:        if (Status != CFE_TBL_WARN_DUPLICATE)
        -:  267:        {
        -:  268:            /* Search Access Descriptor Array for free Descriptor */
      158:  269:            *TblHandlePtr = CFE_TBL_FindFreeHandle();
        -:  270:
        -:  271:            /* Check to make sure there was a handle available */
      158:  272:            if (*TblHandlePtr == CFE_TBL_END_OF_LIST)
        -:  273:            {
        1:  274:                Status = CFE_TBL_ERR_HANDLES_FULL;
        1:  275:                CFE_ES_WriteToSysLog("CFE_TBL:Register-No more free handles\n");
        -:  276:            }
        -:  277:
        -:  278:            /* If no errors, then initialize the table registry entry     */
        -:  279:            /* and return the registry index to the caller as the handle  */
      158:  280:            if ((Status & CFE_SEVERITY_BITMASK) != CFE_SEVERITY_ERROR)
        -:  281:            {
        -:  282:                /* Get pointer to Registry Record Entry to speed up processing */
      154:  283:                RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -:  284:            
        -:  285:                /* Initialize Registry Record to default settings */
      154:  286:                CFE_TBL_InitRegistryRecord(RegRecPtr);
        -:  287:
      154:  288:                if ((TblOptionFlags & CFE_TBL_OPT_USR_DEF_MSK) != (CFE_TBL_OPT_USR_DEF_ADDR & CFE_TBL_OPT_USR_DEF_MSK))
        -:  289:                {
      152:  290:                    RegRecPtr->UserDefAddr = FALSE;
        -:  291:                
        -:  292:                    /* Allocate the memory buffer(s) for the table and inactive table, if necessary */
      152:  293:                    Status = CFE_ES_GetPoolBuf((uint32 **)&RegRecPtr->Buffers[0].BufferPtr,
        -:  294:                                               CFE_TBL_TaskData.Buf.PoolHdl,                                           
        -:  295:                                               Size);
      152:  296:                    if(Status < 0)
        -:  297:                    {
        2:  298:                        CFE_ES_WriteToSysLog("CFE_TBL:Register-1st Buf Alloc GetPool fail Stat=0x%08X MemPoolHndl=0x%08X\n",
        -:  299:                                             Status, CFE_TBL_TaskData.Buf.PoolHdl);
        -:  300:                    }
        -:  301:                    else
        -:  302:                    {
        -:  303:                        /* Zero the memory buffer */
      150:  304:                        Status = CFE_SUCCESS;
      150:  305:                        OS_MemSet(RegRecPtr->Buffers[0].BufferPtr, 0x0, Size);
        -:  306:                    }
        -:  307:                }
        -:  308:                else
        -:  309:                {
        -:  310:                    /* Set buffer pointer to NULL for user defined address tables */
        2:  311:                    RegRecPtr->Buffers[0].BufferPtr = NULL;
        2:  312:                    RegRecPtr->UserDefAddr = TRUE;
        -:  313:                }
        -:  314:
      158:  315:                if (((TblOptionFlags & CFE_TBL_OPT_DBL_BUFFER) == CFE_TBL_OPT_DBL_BUFFER) &&
        -:  316:                    ((Status & CFE_SEVERITY_BITMASK) != CFE_SEVERITY_ERROR))
        -:  317:                {
        -:  318:                    /* Allocate memory for the dedicated secondary buffer */
        4:  319:                    Status = CFE_ES_GetPoolBuf((uint32 **)&RegRecPtr->Buffers[1].BufferPtr,
        -:  320:                                               CFE_TBL_TaskData.Buf.PoolHdl,                                           
        -:  321:                                               Size);
        4:  322:                    if(Status < 0)
        -:  323:                    {
        1:  324:                        CFE_ES_WriteToSysLog("CFE_TBL:Register-2nd Buf Alloc GetPool fail Stat=0x%08X MemPoolHndl=0x%08X\n",
        -:  325:                                             Status, CFE_TBL_TaskData.Buf.PoolHdl);
        -:  326:                    }
        -:  327:                    else
        -:  328:                    {
        -:  329:                        /* Zero the dedicated secondary buffer */
        3:  330:                        Status = CFE_SUCCESS;
        3:  331:                        OS_MemSet(RegRecPtr->Buffers[1].BufferPtr, 0x0, Size);
        -:  332:                    }
        -:  333:
        4:  334:                    RegRecPtr->ActiveBufferIndex = 0;
        4:  335:                    RegRecPtr->DblBuffered = TRUE;
        -:  336:                }
        -:  337:                else  /* Single Buffered Table */
        -:  338:                {
      150:  339:                    RegRecPtr->DblBuffered = FALSE;
      150:  340:                    RegRecPtr->ActiveBufferIndex = 0;
        -:  341:                }
        -:  342:            
      154:  343:                if ((Status & CFE_SEVERITY_BITMASK) != CFE_SEVERITY_ERROR)
        -:  344:                {
        -:  345:                    /* Save the size of the table */
      151:  346:                    RegRecPtr->Size = Size;
        -:  347:
        -:  348:                    /* Save the Callback function pointer */
      151:  349:                    RegRecPtr->ValidationFuncPtr = TblValidationFuncPtr;
        -:  350:
        -:  351:                    /* Save Table Name in Registry */
      151:  352:                    strncpy(RegRecPtr->Name, TblName, CFE_TBL_MAX_FULL_NAME_LEN);
        -:  353:
        -:  354:                    /* Set the "Dump Only" flag to value based upon selected option */
      151:  355:                    if ((TblOptionFlags & CFE_TBL_OPT_LD_DMP_MSK) == CFE_TBL_OPT_DUMP_ONLY)
        -:  356:                    {
        4:  357:                        RegRecPtr->DumpOnly = TRUE;
        -:  358:                    }
        -:  359:                    else
        -:  360:                    {
      147:  361:                        RegRecPtr->DumpOnly = FALSE;
        -:  362:                    }
        -:  363:
        -:  364:                    /* Initialize the Table Access Descriptor */
      151:  365:                    AccessDescPtr = &CFE_TBL_TaskData.Handles[*TblHandlePtr];
        -:  366:
      151:  367:                    AccessDescPtr->AppId = ThisAppId;
      151:  368:                    AccessDescPtr->LockFlag = FALSE;
      151:  369:                    AccessDescPtr->Updated = FALSE;
        -:  370:
      151:  371:                    if ((RegRecPtr->DumpOnly) && (!RegRecPtr->UserDefAddr))
        -:  372:                    {
        -:  373:                        /* Dump Only Tables are assumed to be loaded at all times    */
        -:  374:                        /* unless the address is specified by the application. In    */
        -:  375:                        /* that case, it isn't loaded until the address is specified */
        2:  376:                        RegRecPtr->TableLoadedOnce = TRUE;
        -:  377:                    }
        -:  378:
      151:  379:                    AccessDescPtr->RegIndex = RegIndx;
        -:  380:
      151:  381:                    AccessDescPtr->PrevLink = CFE_TBL_END_OF_LIST;         /* We are the head of the list */
      151:  382:                    AccessDescPtr->NextLink = CFE_TBL_END_OF_LIST;         /* We are the end of the list */
        -:  383:
      151:  384:                    AccessDescPtr->UsedFlag = TRUE;
        -:  385:
        -:  386:                    /* Make sure the Table Registry entry points to First Access Descriptor */
      151:  387:                    RegRecPtr->HeadOfAccessList = *TblHandlePtr;
        -:  388:
        -:  389:                    /* If the table is a critical table, allocate space for it in the Critical Data Store */
        -:  390:                    /* OR locate its previous incarnation there and extract its previous contents */
      151:  391:                    if ((TblOptionFlags & CFE_TBL_OPT_CRITICAL_MSK) == CFE_TBL_OPT_CRITICAL)
        -:  392:                    {
        -:  393:                        /* Register a CDS under the table name and determine if the table already exists there */
       11:  394:                        Status = CFE_ES_RegisterCDSEx(&RegRecPtr->CDSHandle, Size, TblName, TRUE);
        -:  395:                
       11:  396:                        if (Status == CFE_ES_CDS_ALREADY_EXISTS)
        -:  397:                        {
        3:  398:                            CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, TRUE);
        3:  399:                            Status = CFE_ES_RestoreFromCDS(WorkingBufferPtr->BufferPtr, RegRecPtr->CDSHandle);
        -:  400:                        
        3:  401:                            if (Status != CFE_SUCCESS)
        -:  402:                            {
        -:  403:                                /* If an error occurred while trying to get the previous contents, */
        -:  404:                                /* Log the error in the System Log and pretend like we created a new CDS */
        1:  405:                                CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        1:  406:                                CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to recover '%s.%s' from CDS (ErrCode=0x%08X)\n",
        -:  407:                                                     AppName, Name, Status);
        1:  408:                                Status = CFE_SUCCESS;     
        -:  409:                            }
        -:  410:                            else
        -:  411:                            {
        -:  412:                                /* Try to locate the associated information in the Critical Table Registry */
        2:  413:                                CFE_TBL_FindCriticalTblInfo(&CritRegRecPtr, RegRecPtr->CDSHandle);
        -:  414:                            
        2:  415:                                if (CritRegRecPtr != NULL)
        -:  416:                                {
        1:  417:                                    strncpy(WorkingBufferPtr->DataSource, CritRegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        1:  418:                                    WorkingBufferPtr->FileCreateTimeSecs = CritRegRecPtr->FileCreateTimeSecs;
        1:  419:                                    WorkingBufferPtr->FileCreateTimeSubSecs = CritRegRecPtr->FileCreateTimeSubSecs;
        1:  420:                                    RegRecPtr->TimeOfLastUpdate.Seconds = CritRegRecPtr->TimeOfLastUpdate.Seconds;
        1:  421:                                    RegRecPtr->TimeOfLastUpdate.Subseconds = CritRegRecPtr->TimeOfLastUpdate.Subseconds;
        -:  422:                                }
        -:  423:                                else
        -:  424:                                {
        -:  425:                                    /* Save source information into the registry */
        1:  426:                                    sprintf(WorkingBufferPtr->DataSource, "--UNKNOWN--");
        1:  427:                                    WorkingBufferPtr->FileCreateTimeSecs = 0;
        1:  428:                                    WorkingBufferPtr->FileCreateTimeSubSecs = 0;
        1:  429:                                    RegRecPtr->TimeOfLastUpdate.Seconds = 0;
        1:  430:                                    RegRecPtr->TimeOfLastUpdate.Subseconds = 0;
        -:  431:                                }
        -:  432:                            
        -:  433:                                /* Flag the table as having been successfully initialized */
        2:  434:                                RegRecPtr->TableLoadedOnce = TRUE;
        -:  435:                            
        -:  436:                                /* Make sure everyone who sees the table knows that it has been updated */
        2:  437:                                CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        -:  438:                            
        -:  439:                                /* Make sure the caller realizes the contents have been initialized */
        2:  440:                                Status = CFE_TBL_INFO_RECOVERED_TBL;
        -:  441:                            }
        -:  442:                        
        -:  443:                            /* Mark the table as critical for future reference */
        3:  444:                            RegRecPtr->CriticalTable = TRUE;
        -:  445:                        }
        8:  446:                        else if (Status == CFE_SUCCESS)
        -:  447:                        {
        -:  448:                            /* Find and initialize a free entry in the Critical Table Registry */
        7:  449:                            CFE_TBL_FindCriticalTblInfo(&CritRegRecPtr, CFE_ES_CDS_BAD_HANDLE);
        -:  450:                        
        7:  451:                            if (CritRegRecPtr != NULL)
        -:  452:                            {
        6:  453:                                CritRegRecPtr->CDSHandle = RegRecPtr->CDSHandle;
        6:  454:                                strncpy(CritRegRecPtr->Name, TblName, CFE_TBL_MAX_FULL_NAME_LEN);
        6:  455:                                CritRegRecPtr->FileCreateTimeSecs = 0;
        6:  456:                                CritRegRecPtr->FileCreateTimeSubSecs = 0;
        6:  457:                                CritRegRecPtr->LastFileLoaded[0] = '\0';
        6:  458:                                CritRegRecPtr->TimeOfLastUpdate.Seconds = 0;
        6:  459:                                CritRegRecPtr->TimeOfLastUpdate.Subseconds = 0;
        -:  460:                            
        6:  461:                                CFE_ES_CopyToCDS(CFE_TBL_TaskData.CritRegHandle, CFE_TBL_TaskData.CritReg);
        -:  462:                            }
        -:  463:                            else
        -:  464:                            {
        1:  465:                                CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to find a free Crit Tbl Reg Rec for '%s'\n", 
        -:  466:                                                     RegRecPtr->Name);
        -:  467:                            }     
        -:  468:                        
        -:  469:                            /* Mark the table as critical for future reference */
        7:  470:                            RegRecPtr->CriticalTable = TRUE;
        -:  471:                        }
        -:  472:                        else
        -:  473:                        {
        1:  474:                            CFE_ES_WriteToSysLog("CFE_TBL:Register-Failed to register '%s.%s' as a CDS (ErrCode=0x%08X)\n",
        -:  475:                                                 AppName, Name, Status);
        -:  476:                                                 
        -:  477:                            /* Notify caller that although they asked for it to be critical, it isn't */
        1:  478:                            Status = CFE_TBL_WARN_NOT_CRITICAL;
        -:  479:                        }
        -:  480:                    }
        -:  481:
        -:  482:                    /* The last step of the registration process is claiming ownership.    */
        -:  483:                    /* By making it the last step, other APIs do not have to lock registry */
        -:  484:                    /* to share the table or get its address because registry entries that */
        -:  485:                    /* are unowned are not checked to see if they match names, etc.        */
      151:  486:                    RegRecPtr->OwnerAppId = ThisAppId;
        -:  487:                }
        -:  488:            }
        -:  489:        }
        -:  490:
        -:  491:        /* Unlock Registry for update */
      159:  492:        CFE_TBL_UnlockRegistry();
        -:  493:    }
        -:  494:
        -:  495:    /* On Error conditions, notify ground of screw up */
      170:  496:    if (Status < 0)
        -:  497:    {
        -:  498:        /* Make sure the returned handle is invalid when an error occurs */
       18:  499:        *TblHandlePtr = CFE_TBL_BAD_TABLE_HANDLE;
        -:  500:        
        -:  501:        /* Translate AppID of caller into App Name */
       18:  502:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  503:
       18:  504:        CFE_EVS_SendEventWithAppID(CFE_TBL_REGISTER_ERR_EID,
        -:  505:                                   CFE_EVS_ERROR,
        -:  506:                                   CFE_TBL_TaskData.TableTaskAppId,
        -:  507:                                   "%s Failed to Register '%s', Status=0x%08X",
        -:  508:                                   AppName, TblName, Status);
        -:  509:    }
        -:  510:
      170:  511:    return Status;
        -:  512:}   /* End of CFE_TBL_Register() */
        -:  513:
        -:  514:
        -:  515:/*******************************************************************
        -:  516:**
        -:  517:** CFE_TBL_Share() -- Obtain handle of table registered by another
        -:  518:**                    application
        -:  519:**
        -:  520:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  521:********************************************************************/
        -:  522:
        -:  523:int32 CFE_TBL_Share( CFE_TBL_Handle_t *TblHandlePtr,
        -:  524:                     const char *TblName )
      139:  525:{
      139:  526:    int32   Status = CFE_SUCCESS;
        -:  527:    uint32  ThisAppId;
      139:  528:    int16   RegIndx = CFE_TBL_NOT_FOUND;
      139:  529:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
      139:  530:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
      139:  531:    char    AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
        -:  532:
        -:  533:    /* Get a valid Application ID for calling App */
      139:  534:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -:  535:
      139:  536:    if (Status == CFE_SUCCESS)
        -:  537:    {
        -:  538:        /* Lock Registry for update.  This prevents two applications from        */
        -:  539:        /* trying to register/share tables at the same location at the same time */
      137:  540:        CFE_TBL_LockRegistry();
        -:  541:
      137:  542:        RegIndx = CFE_TBL_FindTableInRegistry(TblName);
        -:  543:
        -:  544:        /* If we found the table, then get a new Access Descriptor and initialize it */
      137:  545:        if (RegIndx != CFE_TBL_NOT_FOUND)
        -:  546:        {
        -:  547:            /* Get pointer to Registry Record Entry to speed up processing */
      136:  548:            RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -:  549:
        -:  550:            /* Search Access Descriptor Array for free Descriptor */
      136:  551:            *TblHandlePtr = CFE_TBL_FindFreeHandle();
        -:  552:
        -:  553:            /* Check to make sure there was a handle available */
      136:  554:            if (*TblHandlePtr == CFE_TBL_END_OF_LIST)
        -:  555:            {
        1:  556:                Status = CFE_TBL_ERR_HANDLES_FULL;
        1:  557:                CFE_ES_WriteToSysLog("CFE_TBL:Share-No more free handles\n");
        -:  558:            }
        -:  559:            else
        -:  560:            {
        -:  561:                /* Initialize the Table Access Descriptor */
      135:  562:                AccessDescPtr = &CFE_TBL_TaskData.Handles[*TblHandlePtr];
        -:  563:
      135:  564:                AccessDescPtr->AppId = ThisAppId;
      135:  565:                AccessDescPtr->LockFlag = FALSE;
      135:  566:                AccessDescPtr->Updated = FALSE;
        -:  567:
        -:  568:                /* Check current state of table in order to set Notification flags properly */
      135:  569:                if (RegRecPtr->TableLoadedOnce)
        -:  570:                {
        3:  571:                    AccessDescPtr->Updated = TRUE;
        -:  572:                }
        -:  573:
      135:  574:                AccessDescPtr->RegIndex = RegIndx;
      135:  575:                AccessDescPtr->UsedFlag = TRUE;
        -:  576:
      135:  577:                AccessDescPtr->PrevLink = CFE_TBL_END_OF_LIST;             /* We are the new head of the list */
      135:  578:                AccessDescPtr->NextLink = RegRecPtr->HeadOfAccessList;
        -:  579:
        -:  580:                /* Make sure the old head of the list now sees this as the head */
      135:  581:                CFE_TBL_TaskData.Handles[RegRecPtr->HeadOfAccessList].PrevLink = *TblHandlePtr;
        -:  582:
        -:  583:                /* Make sure the Registry Record see this as the head of the list */
      135:  584:                RegRecPtr->HeadOfAccessList = *TblHandlePtr;
        -:  585:            }
        -:  586:        }
        -:  587:        else  /* Table could not be found in registry */
        -:  588:        {
        1:  589:            Status = CFE_TBL_ERR_INVALID_NAME;
        -:  590:
        1:  591:            CFE_ES_WriteToSysLog("CFE_TBL:Share-Table '%s' not found in Registry\n", TblName);
        -:  592:        }
        -:  593:
      137:  594:        CFE_TBL_UnlockRegistry();
        -:  595:    }
        -:  596:    else  /* Application ID was invalid */
        -:  597:    {
        2:  598:        CFE_ES_WriteToSysLog("CFE_TBL:Share-Bad AppId(%d)\n", ThisAppId);
        -:  599:    }
        -:  600:
        -:  601:    /* On Error conditions, notify ground of screw up */
      139:  602:    if (Status < 0)
        -:  603:    {
        -:  604:        /* Translate AppID of caller into App Name */
        4:  605:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  606:
        4:  607:        CFE_EVS_SendEventWithAppID(CFE_TBL_SHARE_ERR_EID,
        -:  608:                                   CFE_EVS_ERROR,
        -:  609:                                   CFE_TBL_TaskData.TableTaskAppId,
        -:  610:                                   "%s Failed to Share '%s', Status=0x%08X",
        -:  611:                                   AppName, TblName, Status);
        -:  612:    }
        -:  613:
      139:  614:    return Status;
        -:  615:}   /* End of CFE_TBL_Share() */
        -:  616:
        -:  617:
        -:  618:/*******************************************************************
        -:  619:**
        -:  620:** CFE_TBL_Unregister() -- Unregister a previously registered
        -:  621:**                         table and free associated resources
        -:  622:**
        -:  623:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  624:********************************************************************/
        -:  625:
        -:  626:int32 CFE_TBL_Unregister ( CFE_TBL_Handle_t TblHandle )
       19:  627:{
        -:  628:    int32   Status;
        -:  629:    uint32  ThisAppId;
       19:  630:    CFE_TBL_RegistryRec_t *RegRecPtr = NULL;
       19:  631:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
       19:  632:    char    AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
        -:  633:
        -:  634:    /* Verify that this application has the right to perform operation */
       19:  635:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -:  636:
       19:  637:    if (Status == CFE_SUCCESS)
        -:  638:    {
        -:  639:        /* Get a pointer to the relevant Access Descriptor */
       18:  640:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        -:  641:
        -:  642:        /* Get a pointer to the relevant entry in the registry */
       18:  643:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  644:
        -:  645:        /* Verify that the application unregistering the table owns the table */
       18:  646:        if (RegRecPtr->OwnerAppId == ThisAppId)
        -:  647:        {
        -:  648:            /* Mark table as free, although, technically, it isn't free until the */
        -:  649:            /* linked list of Access Descriptors has no links in it.              */
        -:  650:            /* NOTE: Allocated memory is freed when all Access Links have been    */
        -:  651:            /*       removed.  This allows Applications to continue to use the    */
        -:  652:            /*       data until they acknowledge that the table has been removed. */
       14:  653:            RegRecPtr->OwnerAppId = (uint32)CFE_TBL_NOT_OWNED;
        -:  654:
        -:  655:            /* Remove Table Name */
       14:  656:            RegRecPtr->Name[0] = '\0';
        -:  657:        }
        -:  658:
        -:  659:        /* Remove the Access Descriptor Link from linked list */
        -:  660:        /* NOTE: If this removes the last access link, then   */
        -:  661:        /*       memory buffers are set free as well.         */
       18:  662:        CFE_TBL_RemoveAccessLink(TblHandle);
        -:  663:    }
        -:  664:    else
        -:  665:    {
        1:  666:        CFE_ES_WriteToSysLog("CFE_TBL:Unregister-App(%d) does not have access to Tbl Handle=%d\n",
        -:  667:                             ThisAppId, TblHandle);
        -:  668:    }
        -:  669:
        -:  670:    /* On Error conditions, notify ground of screw up */
       19:  671:    if (Status < 0)
        -:  672:    {
        -:  673:        /* Translate AppID of caller into App Name */
        1:  674:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  675:
        1:  676:        CFE_EVS_SendEventWithAppID(CFE_TBL_UNREGISTER_ERR_EID,
        -:  677:                                   CFE_EVS_ERROR,
        -:  678:                                   CFE_TBL_TaskData.TableTaskAppId,
        -:  679:                                   "%s Failed to Unregister '?', Status=0x%08X",
        -:  680:                                   AppName, Status);
        -:  681:    }
        -:  682:
       19:  683:    return Status;
        -:  684:}   /* End of CFE_TBL_Unregister() */
        -:  685:
        -:  686:
        -:  687:/*******************************************************************
        -:  688:**
        -:  689:** CFE_TBL_Load() -- Load a specified table with data from the
        -:  690:**                   specified source
        -:  691:**
        -:  692:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  693:********************************************************************/
        -:  694:
        -:  695:int32 CFE_TBL_Load( CFE_TBL_Handle_t TblHandle,
        -:  696:                    CFE_TBL_SrcEnum_t SrcType,
        -:  697:                    const void *SrcDataPtr )
       25:  698:{
        -:  699:    int32                       Status;
        -:  700:    uint32                      ThisAppId;
        -:  701:    CFE_TBL_LoadBuff_t         *WorkingBufferPtr;
       25:  702:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        -:  703:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
       25:  704:    char                        AppName[OS_MAX_API_NAME]={"UNKNOWN"};
       25:  705:    uint16                      EventMsgType = CFE_EVS_INFORMATION;
       25:  706:    boolean                     FirstTime = FALSE;
        -:  707:
        -:  708:
        -:  709:    /* Initialize return pointer to NULL */
       25:  710:    WorkingBufferPtr = NULL;
        -:  711:
        -:  712:    /* Verify access rights and get a valid Application ID for calling App */
       25:  713:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -:  714:
       25:  715:    if (Status == CFE_SUCCESS)
        -:  716:    {
        -:  717:        /* Get pointers to pertinent records in registry and handles */
       23:  718:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       23:  719:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  720:
        -:  721:        /* Check to see if this is a dump only table */
       23:  722:        if (RegRecPtr->DumpOnly)
        -:  723:        {
        3:  724:            if ((RegRecPtr->UserDefAddr) && (!RegRecPtr->TableLoadedOnce))
        -:  725:            {
        -:  726:                /* The Application is allowed to call Load once when the address  */
        -:  727:                /* of the dump only table is being defined by the application.    */
        1:  728:                RegRecPtr->Buffers[0].BufferPtr = (void *)SrcDataPtr;
        1:  729:                RegRecPtr->TableLoadedOnce = TRUE;
        -:  730:                
        1:  731:                sprintf(RegRecPtr->Buffers[0].DataSource, "Addr 0x%08X", (int)SrcDataPtr);
        1:  732:                RegRecPtr->Buffers[0].FileCreateTimeSecs = 0;
        1:  733:                RegRecPtr->Buffers[0].FileCreateTimeSubSecs = 0;
        -:  734:
        1:  735:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_SUCCESS_INF_EID,
        -:  736:                                           CFE_EVS_DEBUG,
        -:  737:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  738:                                           "Successfully loaded '%s' from '%s'",
        -:  739:                                           RegRecPtr->Name,
        -:  740:                                           RegRecPtr->Buffers[0].DataSource);
        -:  741:            }
        -:  742:            else
        -:  743:            {
        1:  744:                Status = CFE_TBL_ERR_DUMP_ONLY;
        -:  745:
        1:  746:                CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) attempted to load Dump Only Tbl '%s'\n",
        -:  747:                                     ThisAppId, RegRecPtr->Name);
        -:  748:            }     
        -:  749:        }
        -:  750:        else
        -:  751:        {
        -:  752:            /* Loads by an Application are not allowed if a table load is already in progress */
       21:  753:            if (RegRecPtr->LoadInProgress != CFE_TBL_NO_LOAD_IN_PROGRESS)
        -:  754:            {
        1:  755:                Status = CFE_TBL_ERR_LOAD_IN_PROGRESS;
        -:  756:
        1:  757:                CFE_ES_WriteToSysLog("CFE_TBL:Load-Tbl Load already in progress for '%s'\n", RegRecPtr->Name);
        -:  758:            }
        -:  759:            else
        -:  760:            {
        -:  761:                /* Obtain a working buffer (either the table's dedicated buffer or one of the shared buffers) */
       20:  762:                Status = CFE_TBL_GetWorkingBuffer(&WorkingBufferPtr, RegRecPtr, TRUE);
        -:  763:
       20:  764:                if (Status == CFE_SUCCESS)
        -:  765:                {
        -:  766:                    /* Perform appropriate update to working buffer */
        -:  767:                    /* Determine whether the load is to occur from a file or from a block of memory */
       19:  768:                    if (SrcType == CFE_TBL_SRC_FILE)
        -:  769:                    {
        -:  770:                        /* Load the data from the file into the specified buffer */
       14:  771:                        Status = CFE_TBL_LoadFromFile(WorkingBufferPtr, RegRecPtr, (const char *)SrcDataPtr);
        -:  772:
       14:  773:                        if (Status < 0)
        -:  774:                        {
        1:  775:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) Fail to load Tbl '%s' from '%s' (Stat=0x%08X)\n",
        -:  776:                                                 ThisAppId, RegRecPtr->Name, (const char *)SrcDataPtr, Status);
        -:  777:                        }
       13:  778:                        else if ((Status == CFE_TBL_WARN_PARTIAL_LOAD) && (!RegRecPtr->TableLoadedOnce))
        -:  779:                        {
        -:  780:                            /* Uninitialized tables cannot be loaded with partial table loads */
        -:  781:                            /* Partial loads can only occur on previously loaded tables.      */
        1:  782:                            Status = CFE_TBL_ERR_PARTIAL_LOAD;
        -:  783:                        }
        -:  784:                    }
        5:  785:                    else if (SrcType == CFE_TBL_SRC_ADDRESS)
        -:  786:                    {
        -:  787:                        /* When the source is a block of memory, it is assumed to be a complete load */
        4:  788:                        OS_MemCpy(WorkingBufferPtr->BufferPtr,
        -:  789:                                  (uint8 *)SrcDataPtr,
        -:  790:                                  RegRecPtr->Size);
        -:  791:
        4:  792:                        sprintf(WorkingBufferPtr->DataSource, "Addr 0x%08X", (int)SrcDataPtr);
        4:  793:                        WorkingBufferPtr->FileCreateTimeSecs = 0;
        4:  794:                        WorkingBufferPtr->FileCreateTimeSubSecs = 0;
        -:  795:                    }
        -:  796:                    else
        -:  797:                    {
        1:  798:                        Status = CFE_TBL_ERR_ILLEGAL_SRC_TYPE;
        1:  799:                        CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) attempt to load from illegal source type=%d\n",
        -:  800:                                             ThisAppId, SrcType);
        -:  801:                    }
        -:  802:
        -:  803:                    /* If the data was successfully loaded, then validate its contents */
       19:  804:                    if ((Status >= CFE_SUCCESS) && (RegRecPtr->ValidationFuncPtr != NULL))
        -:  805:                    {
       11:  806:                        Status = (RegRecPtr->ValidationFuncPtr)(WorkingBufferPtr->BufferPtr);
        -:  807:
       11:  808:                        if (Status > CFE_SUCCESS)
        -:  809:                        {
        1:  810:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) Validation func return code invalid (Stat=0x%08X) for '%s'\n",
        -:  811:                                                 ThisAppId, Status, RegRecPtr->Name);
        1:  812:                            Status = -1;
        -:  813:                        }
        -:  814:                        
       11:  815:                        if (Status < 0)
        -:  816:                        {
        2:  817:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) reports load invalid (Stat=0x%08X) for '%s'\n",
        -:  818:                                                 ThisAppId, Status, RegRecPtr->Name);
        -:  819:                                            
        -:  820:                            /* Zero out the buffer to remove any bad data */
        2:  821:                            OS_MemSet(WorkingBufferPtr->BufferPtr, 0, RegRecPtr->Size);     
        -:  822:                        }
        -:  823:                    }
        -:  824:
        -:  825:                    /* Perform the table update to complete the load */
       19:  826:                    if (Status >= CFE_SUCCESS)
        -:  827:                    {
       14:  828:                        FirstTime = !RegRecPtr->TableLoadedOnce;
        -:  829:                        
        -:  830:                        /* If this is not the first load, then the data must be moved from the inactive buffer      */
        -:  831:                        /* to the active buffer to complete the load.  First loads are done directly to the active. */
       14:  832:                        if (!FirstTime)
        -:  833:                        {
        -:  834:                            /* Force the table update */
        6:  835:                            RegRecPtr->LoadPending = TRUE;
        -:  836:
        6:  837:                            Status = CFE_TBL_UpdateInternal(TblHandle, RegRecPtr, AccessDescPtr);
        -:  838:                        }
        -:  839:                        else
        -:  840:                        {
        -:  841:                            /* On initial loads, make sure registry is given file/address of data source */
        8:  842:                            strncpy(RegRecPtr->LastFileLoaded,
        -:  843:                                    WorkingBufferPtr->DataSource,
        -:  844:                                    OS_MAX_PATH_LEN);
        -:  845:                                    
        -:  846:                            /* If the table is a critical table, update the appropriate CDS with the new data */
        8:  847:                            if (RegRecPtr->CriticalTable == TRUE)
        -:  848:                            {
        4:  849:                                CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -:  850:                            }
        -:  851:            
        8:  852:                            CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        8:  853:                            Status = CFE_SUCCESS;
        -:  854:                        }
        -:  855:
       14:  856:                        if (Status != CFE_SUCCESS)
        -:  857:                        {
        1:  858:                            CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) fail to update '%s' (Stat=0x%08X)\n",
        -:  859:                                                 ThisAppId, RegRecPtr->Name, Status);
        -:  860:                        }
        -:  861:                        else
        -:  862:                        {
        -:  863:                            /* The first time a table is loaded, the event message is DEBUG */
        -:  864:                            /* to help eliminate a flood of events during a startup         */
       13:  865:                            if (FirstTime)
        -:  866:                            {
        8:  867:                                EventMsgType = CFE_EVS_DEBUG;
        -:  868:                            }
        -:  869:
       13:  870:                            CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_SUCCESS_INF_EID,
        -:  871:                                                       EventMsgType,
        -:  872:                                                       CFE_TBL_TaskData.TableTaskAppId,
        -:  873:                                                       "Successfully loaded '%s' from '%s'",
        -:  874:                                                       RegRecPtr->Name,
        -:  875:                                                       RegRecPtr->LastFileLoaded);
        -:  876:                            
        -:  877:                            /* Save the index of the table for housekeeping telemetry */
       13:  878:                            CFE_TBL_TaskData.LastTblUpdated = AccessDescPtr->RegIndex;       
        -:  879:                        }
        -:  880:                    }
        -:  881:                    else
        -:  882:                    {
        -:  883:                        /* The load has had a problem, free the working buffer for another attempt */
        5:  884:                        if ((!RegRecPtr->DblBuffered) && (RegRecPtr->TableLoadedOnce == TRUE))
        -:  885:                        {
        -:  886:                            /* For single buffered tables, freeing entails resetting flag */
        3:  887:                            CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Taken = FALSE;
        -:  888:                        }
        -:  889:
        -:  890:                        /* For double buffered tables, freeing buffer is simple */
        5:  891:                        RegRecPtr->LoadInProgress = CFE_TBL_NO_LOAD_IN_PROGRESS;
        -:  892:                    }
        -:  893:                }
        -:  894:                else
        -:  895:                {
        1:  896:                    CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) Failed to get Working Buffer (Stat=0x%08X)\n",
        -:  897:                                         ThisAppId, Status);
        -:  898:                }
        -:  899:            }
        -:  900:        }
        -:  901:    }
        -:  902:    else
        -:  903:    {
        2:  904:        CFE_ES_WriteToSysLog("CFE_TBL:Load-App(%d) does not have access to Tbl Handle=%d\n",
        -:  905:                             ThisAppId, TblHandle);
        -:  906:    }
        -:  907:
        -:  908:    /* On Error conditions, notify ground of screw up */
       25:  909:    if (Status < 0)
        -:  910:    {
        -:  911:        /* Translate AppID of caller into App Name */
       10:  912:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  913:
       10:  914:        if (RegRecPtr == NULL)
        -:  915:        {
        2:  916:            CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_ERR_EID,
        -:  917:                                       CFE_EVS_ERROR,
        -:  918:                                       CFE_TBL_TaskData.TableTaskAppId,
        -:  919:                                       "%s Failed to Load '?', Status=0x%08X",
        -:  920:                                       AppName, Status);
        -:  921:        }
        -:  922:        else
        -:  923:        {
        8:  924:            if (SrcType == CFE_TBL_SRC_ADDRESS)
        -:  925:            {
        4:  926:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_ERR_EID,
        -:  927:                                           CFE_EVS_ERROR,
        -:  928:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  929:                                           "%s Failed to Load '%s' from Addr 0x%08X, Status=0x%08X",
        -:  930:                                           AppName, RegRecPtr->Name, SrcDataPtr, Status);
        -:  931:            }
        4:  932:            else if (SrcType == CFE_TBL_SRC_FILE)
        -:  933:            {
        3:  934:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_ERR_EID,
        -:  935:                                           CFE_EVS_ERROR,
        -:  936:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  937:                                           "%s Failed to Load '%s' from '%s', Status=0x%08X",
        -:  938:                                           AppName, RegRecPtr->Name, (const char *)SrcDataPtr, Status);
        -:  939:            }
        -:  940:            else
        -:  941:            {
        1:  942:                CFE_EVS_SendEventWithAppID(CFE_TBL_LOAD_TYPE_ERR_EID,
        -:  943:                                           CFE_EVS_ERROR,
        -:  944:                                           CFE_TBL_TaskData.TableTaskAppId,
        -:  945:                                           "%s Failed to Load '%s' (Invalid Source Type)",
        -:  946:                                           AppName, RegRecPtr->Name);
        -:  947:            }
        -:  948:        }
        -:  949:    }
        -:  950:
       25:  951:    return Status;
        -:  952:}   /* End of CFE_TBL_Load() */
        -:  953:
        -:  954:
        -:  955:/*******************************************************************
        -:  956:**
        -:  957:** CFE_TBL_Update() -- Update contents of table if an update
        -:  958:**                     is pending
        -:  959:**
        -:  960:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -:  961:********************************************************************/
        -:  962:
        -:  963:int32 CFE_TBL_Update( CFE_TBL_Handle_t TblHandle )
        4:  964:{
        -:  965:    int32                       Status;
        -:  966:    uint32                      ThisAppId;
        4:  967:    CFE_TBL_RegistryRec_t      *RegRecPtr=NULL;
        4:  968:    CFE_TBL_AccessDescriptor_t *AccessDescPtr=NULL;
        4:  969:    char                        AppName[OS_MAX_API_NAME]={"UNKNOWN"};
        -:  970:
        -:  971:    /* Verify access rights and get a valid Application ID for calling App */
        4:  972:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -:  973:
        4:  974:    if (Status == CFE_SUCCESS)
        -:  975:    {
        -:  976:        /* Get pointers to pertinent records in registry and handles */
        3:  977:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        3:  978:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -:  979:
        3:  980:        Status = CFE_TBL_UpdateInternal(TblHandle, RegRecPtr, AccessDescPtr);
        -:  981:
        3:  982:        if (Status != CFE_SUCCESS)
        -:  983:        {
        2:  984:            CFE_ES_WriteToSysLog("CFE_TBL:Update-App(%d) fail to update Tbl '%s' (Stat=0x%08X)\n",
        -:  985:                                 ThisAppId, RegRecPtr->Name, Status);
        -:  986:        }
        -:  987:    }
        -:  988:    else
        -:  989:    {
        1:  990:        CFE_ES_WriteToSysLog("CFE_TBL:Update-App(%d) does not have access to Tbl Handle=%d\n", ThisAppId, TblHandle);
        -:  991:    }
        -:  992:
        4:  993:    if (Status != CFE_TBL_ERR_BAD_APP_ID)
        -:  994:    {
        -:  995:        /* Translate AppID of caller into App Name */
        4:  996:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  997:    }
        -:  998:    
        -:  999:    /* On Error conditions, notify ground of screw up */
        4: 1000:    if (Status < 0)
        -: 1001:    {
        1: 1002:        if (RegRecPtr != NULL)
        -: 1003:        {
    #####: 1004:            CFE_EVS_SendEventWithAppID(CFE_TBL_UPDATE_ERR_EID,
        -: 1005:                                       CFE_EVS_ERROR,
        -: 1006:                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1007:                                       "%s Failed to Update '%s', Status=0x%08X",
        -: 1008:                                       AppName, RegRecPtr->Name, Status);
        -: 1009:        }
        -: 1010:        else
        -: 1011:        {
        1: 1012:            CFE_EVS_SendEventWithAppID(CFE_TBL_UPDATE_ERR_EID,
        -: 1013:                                       CFE_EVS_ERROR,
        -: 1014:                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1015:                                       "%s Failed to Update '?', Status=0x%08X",
        -: 1016:                                       AppName, Status);
        -: 1017:        }
        -: 1018:    }
        -: 1019:    else
        -: 1020:    {
        -: 1021:        /* If there was a warning (ie - Table is currently locked), then do not issue a message */
        3: 1022:        if (Status == CFE_SUCCESS)
        -: 1023:        {
        1: 1024:            CFE_EVS_SendEventWithAppID(CFE_TBL_UPDATE_SUCCESS_INF_EID,
        -: 1025:                                       CFE_EVS_INFORMATION,
        -: 1026:                                       CFE_TBL_TaskData.TableTaskAppId,
        -: 1027:                                       "%s Successfully Updated '%s'",
        -: 1028:                                       AppName, RegRecPtr->Name);
        -: 1029:                            
        -: 1030:            /* Save the index of the table for housekeeping telemetry */
        1: 1031:            CFE_TBL_TaskData.LastTblUpdated = AccessDescPtr->RegIndex;
        -: 1032:        }       
        -: 1033:    }
        -: 1034:
        4: 1035:    return Status;
        -: 1036:}   /* End of CFE_TBL_Update() */
        -: 1037:
        -: 1038:
        -: 1039:/*******************************************************************
        -: 1040:**
        -: 1041:** CFE_TBL_GetAddress() -- Obtain the current address of the
        -: 1042:**                         contents of the specified table
        -: 1043:**
        -: 1044:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1045:********************************************************************/
        -: 1046:
        -: 1047:int32 CFE_TBL_GetAddress( void **TblPtr,
        -: 1048:                          CFE_TBL_Handle_t TblHandle )
       10: 1049:{
       10: 1050:    int32   Status = CFE_SUCCESS;
        -: 1051:    uint32  ThisAppId;
        -: 1052:
        -: 1053:    /* Assume failure at returning the table address */
       10: 1054:    *TblPtr = NULL;
        -: 1055:
        -: 1056:    /* Validate the calling application's AppID */
       10: 1057:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -: 1058:
       10: 1059:    if (Status == CFE_SUCCESS)
        -: 1060:    {
        9: 1061:        Status = CFE_TBL_GetAddressInternal(TblPtr, TblHandle, ThisAppId);
        -: 1062:
        -: 1063:        /* NOTE: GetAddressInternal calls GetNextNotification which may not */
        -: 1064:        /*       be equal to CFE_SUCCESS and still not be an error.         */
        -: 1065:        /*       Therefore, a write to the SysLog is unnecessary.           */
        -: 1066:    }
        -: 1067:    else
        -: 1068:    {
        1: 1069:        CFE_ES_WriteToSysLog("CFE_TBL:GetAddress-Bad AppId=%d\n", ThisAppId);
        -: 1070:    }
        -: 1071:
       10: 1072:    return Status;
        -: 1073:}   /* End of CFE_TBL_GetAddress() */
        -: 1074:
        -: 1075:/*******************************************************************
        -: 1076:**
        -: 1077:** CFE_TBL_ReleaseAddress() -- Release previously obtained pointer
        -: 1078:**                          to the contents of the specified table
        -: 1079:**
        -: 1080:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1081:********************************************************************/
        -: 1082:
        -: 1083:int32 CFE_TBL_ReleaseAddress( CFE_TBL_Handle_t TblHandle )
        8: 1084:{
        -: 1085:    int32   Status;
        -: 1086:    uint32  ThisAppId;
        -: 1087:
        -: 1088:    /* Verify that this application has the right to perform operation */
        8: 1089:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1090:
        8: 1091:    if (Status == CFE_SUCCESS)
        -: 1092:    {
        -: 1093:        /* Clear the lock flag */
        7: 1094:        CFE_TBL_TaskData.Handles[TblHandle].LockFlag = FALSE;
        -: 1095:
        -: 1096:        /* Return any pending warning or info status indicators */
        7: 1097:        Status = CFE_TBL_GetNextNotification(TblHandle);
        -: 1098:
        -: 1099:        /* NOTE: GetNextNotification may not return CFE_SUCCESS  */
        -: 1100:        /*       and still not be an error.                      */
        -: 1101:        /*       Therefore, a write to the SysLog is unnecessary.*/
        -: 1102:    }
        -: 1103:    else
        -: 1104:    {
        1: 1105:        CFE_ES_WriteToSysLog("CFE_TBL:ReleaseAddress-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1106:                             ThisAppId, TblHandle);
        -: 1107:    }
        -: 1108:
        8: 1109:    return Status;
        -: 1110:}   /* End of CFE_TBL_ReleaseAddress() */
        -: 1111:
        -: 1112:/*******************************************************************
        -: 1113:**
        -: 1114:** CFE_TBL_GetAddresses() -- Obtain the current addresses of the contents of a collection of tables.
        -: 1115:**                           If an addsses.  Failure return codes
        -: 1116:**                           only apply to the first table that was unsuccessful.
        -: 1117:**
        -: 1118:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1119:********************************************************************/
        -: 1120:
        -: 1121:int32 CFE_TBL_GetAddresses( void **TblPtrs[],
        -: 1122:                            uint16 NumTables,
        -: 1123:                            const CFE_TBL_Handle_t TblHandles[] )
        2: 1124:{
        -: 1125:    uint16  i;
        2: 1126:    int32   Status = CFE_SUCCESS;
        -: 1127:    uint32  ThisAppId;
        -: 1128:
        -: 1129:    /* Assume failure at returning the table addresses */
        6: 1130:    for (i=0; i<NumTables; i++)
        -: 1131:    {
        4: 1132:        *TblPtrs[i] = NULL;
        -: 1133:    }
        -: 1134:
        -: 1135:    /* Validate the calling application's AppID */
        2: 1136:    Status = CFE_TBL_ValidateAppID(&ThisAppId);
        -: 1137:
        2: 1138:    if (Status == CFE_SUCCESS)
        -: 1139:    {
        3: 1140:        for (i=0; i<NumTables; i++)
        -: 1141:        {
        -: 1142:            /* Continue to get the return status until one returns something other than CFE_SUCCESS */
        2: 1143:            if (Status == CFE_SUCCESS)
        -: 1144:            {
        1: 1145:                Status = CFE_TBL_GetAddressInternal(TblPtrs[i], TblHandles[i], ThisAppId);
        -: 1146:            }
        -: 1147:            else
        -: 1148:            {
        -: 1149:                /* Don't bother getting the status of other tables once one has returned */
        -: 1150:                /* a non CFE_SUCCESS value.                                              */
        1: 1151:                CFE_TBL_GetAddressInternal(TblPtrs[i], TblHandles[i], ThisAppId);
        -: 1152:            }
        -: 1153:        }
        -: 1154:    }
        -: 1155:    else
        -: 1156:    {
        1: 1157:        CFE_ES_WriteToSysLog("CFE_TBL:GetAddresses-Bad AppId=%d\n", ThisAppId);
        -: 1158:    }
        -: 1159:
        2: 1160:    return Status;
        -: 1161:}   /* End of CFE_TBL_GetAddresses() */
        -: 1162:
        -: 1163:/*******************************************************************
        -: 1164:**
        -: 1165:** CFE_TBL_ReleaseAddresses() -- Release previously obtained
        -: 1166:**             pointers to the contents of the specified tables
        -: 1167:**
        -: 1168:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1169:********************************************************************/
        -: 1170:
        -: 1171:int32 CFE_TBL_ReleaseAddresses( uint16 NumTables,
        -: 1172:                                const CFE_TBL_Handle_t TblHandles[] )
        1: 1173:{
        1: 1174:    int32   Status = CFE_SUCCESS;
        -: 1175:    uint16  i;
        -: 1176:
        3: 1177:    for (i=0; i<NumTables; i++)
        -: 1178:    {
        -: 1179:        /* Continue to get the return status until one returns something other than CFE_SUCCESS */
        2: 1180:        if (Status == CFE_SUCCESS)
        -: 1181:        {
        1: 1182:            Status = CFE_TBL_ReleaseAddress(TblHandles[i]);
        -: 1183:        }
        -: 1184:        else
        -: 1185:        {
        -: 1186:            /* Don't bother getting the status of other tables once one has returned */
        -: 1187:            /* a non CFE_SUCCESS value.                                              */
        1: 1188:            CFE_TBL_ReleaseAddress(TblHandles[i]);
        -: 1189:        }
        -: 1190:    }
        -: 1191:
        1: 1192:    return Status;
        -: 1193:}   /* End of CFE_TBL_ReleaseAddresses() */
        -: 1194:
        -: 1195:
        -: 1196:/*******************************************************************
        -: 1197:**
        -: 1198:** CFE_TBL_Validate() -- Validate a table image for the specified table
        -: 1199:**
        -: 1200:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1201:********************************************************************/
        -: 1202:
        -: 1203:int32 CFE_TBL_Validate( CFE_TBL_Handle_t TblHandle )
       12: 1204:{
       12: 1205:    int32                       Status = CFE_SUCCESS;
        -: 1206:    uint32                      ThisAppId;
        -: 1207:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -: 1208:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
       12: 1209:    char                        AppName[OS_MAX_API_NAME]={"UNKNWON"};
        -: 1210:
        -: 1211:    /* Verify that this application has the right to perform operation */
       12: 1212:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1213:
       12: 1214:    if (Status == CFE_SUCCESS)
        -: 1215:    {
        -: 1216:        /* Get pointers to pertinent records in registry and handles */
       11: 1217:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       11: 1218:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1219:
       11: 1220:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -: 1221:
        -: 1222:        /* Identify the image to be validated, starting with the Inactive Buffer */
       11: 1223:        if (RegRecPtr->ValidateInactiveIndex != CFE_TBL_NO_VALIDATION_PENDING)
        -: 1224:        {
        -: 1225:            /* Identify whether the Inactive Buffer is a shared buffer or a dedicated one */
        5: 1226:            if (RegRecPtr->DblBuffered)
        -: 1227:            {
        -: 1228:                /* Call the Application's Validation function for the Inactive Buffer */
        2: 1229:                Status = (RegRecPtr->ValidationFuncPtr)(RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].BufferPtr);
        -: 1230:                
        -: 1231:                /* Allow buffer to be activated after passing validation */
        2: 1232:                if (Status == CFE_SUCCESS)
        -: 1233:                {
        1: 1234:                    RegRecPtr->Buffers[(1U-RegRecPtr->ActiveBufferIndex)].Validated = TRUE;       
        -: 1235:                }
        -: 1236:            }
        -: 1237:            else
        -: 1238:            {
        -: 1239:                /* Call the Application's Validation function for the appropriate shared buffer */
        3: 1240:                Status = (RegRecPtr->ValidationFuncPtr)
        -: 1241:                          (CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].BufferPtr);
        -: 1242:                
        -: 1243:                /* Allow buffer to be activated after passing validation */
        3: 1244:                if (Status == CFE_SUCCESS)
        -: 1245:                {
        1: 1246:                    CFE_TBL_TaskData.LoadBuffs[RegRecPtr->LoadInProgress].Validated = TRUE;       
        -: 1247:                }
        -: 1248:            }
        -: 1249:
        5: 1250:            if (Status == CFE_SUCCESS)
        -: 1251:            {
        2: 1252:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_INF_EID,
        -: 1253:                                           CFE_EVS_INFORMATION,
        -: 1254:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1255:                                           "%s validation successful for Inactive '%s'",
        -: 1256:                                           AppName, RegRecPtr->Name);
        -: 1257:            }
        -: 1258:            else
        -: 1259:            {
        3: 1260:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_ERR_EID,
        -: 1261:                                           CFE_EVS_ERROR,
        -: 1262:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1263:                                           "%s validation failed for Inactive '%s', Status=0x%08X",
        -: 1264:                                           AppName, RegRecPtr->Name, Status);
        -: 1265:                
        3: 1266:                if (Status > CFE_SUCCESS)
        -: 1267:                {
        1: 1268:                    CFE_ES_WriteToSysLog("CFE_TBL:Validate-App(%d) Validation func return code invalid (Stat=0x%08X) for '%s'\n",
        -: 1269:                                         CFE_TBL_TaskData.TableTaskAppId, Status, RegRecPtr->Name);
        -: 1270:                }
        -: 1271:            }
        -: 1272:
        -: 1273:            /* Save the result of the Validation function for the Table Services Task */
        5: 1274:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateInactiveIndex].Result = Status;
        -: 1275:
        -: 1276:            /* Once validation is complete, set flags to indicate response is ready */
        5: 1277:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateInactiveIndex].State = CFE_TBL_VALIDATION_PERFORMED;
        5: 1278:            RegRecPtr->ValidateInactiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
        -: 1279:
        -: 1280:            /* Since the validation was successfully performed (although maybe not a successful result) */
        -: 1281:            /* return a success status */
        5: 1282:            Status = CFE_SUCCESS;
        -: 1283:        }
        6: 1284:        else if (RegRecPtr->ValidateActiveIndex != CFE_TBL_NO_VALIDATION_PENDING)
        -: 1285:        {
        -: 1286:            /* Perform validation on the currently active table buffer */
        -: 1287:            /* Identify whether the Active Buffer is a shared buffer or a dedicated one */
        5: 1288:            if (RegRecPtr->DblBuffered)
        -: 1289:            {
        -: 1290:                /* Call the Application's Validation function for the Dedicated Active Buffer */
        2: 1291:                Status = (RegRecPtr->ValidationFuncPtr)(RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].BufferPtr);
        -: 1292:            }
        -: 1293:            else
        -: 1294:            {
        -: 1295:                /* Call the Application's Validation function for the static buffer */
        3: 1296:                Status = (RegRecPtr->ValidationFuncPtr)(RegRecPtr->Buffers[0].BufferPtr);
        -: 1297:            }
        -: 1298:
        5: 1299:            if (Status == CFE_SUCCESS)
        -: 1300:            {
        2: 1301:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_INF_EID,
        -: 1302:                                           CFE_EVS_INFORMATION,
        -: 1303:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1304:                                           "%s validation successful for Active '%s'",
        -: 1305:                                           AppName, RegRecPtr->Name);
        -: 1306:            }
        -: 1307:            else
        -: 1308:            {
        3: 1309:                CFE_EVS_SendEventWithAppID(CFE_TBL_VALIDATION_ERR_EID,
        -: 1310:                                           CFE_EVS_ERROR,
        -: 1311:                                           CFE_TBL_TaskData.TableTaskAppId,
        -: 1312:                                           "%s validation failed for Active '%s', Status=0x%08X",
        -: 1313:                                           AppName, RegRecPtr->Name, Status);
        -: 1314:                
        3: 1315:                if (Status > CFE_SUCCESS)
        -: 1316:                {
        1: 1317:                    CFE_ES_WriteToSysLog("CFE_TBL:Validate-App(%d) Validation func return code invalid (Stat=0x%08X) for '%s'\n",
        -: 1318:                                         CFE_TBL_TaskData.TableTaskAppId, Status, RegRecPtr->Name);
        -: 1319:                }
        -: 1320:            }
        -: 1321:
        -: 1322:            /* Save the result of the Validation function for the Table Services Task */
        5: 1323:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateActiveIndex].Result = Status;
        -: 1324:
        -: 1325:            /* Once validation is complete, reset the flags */
        5: 1326:            CFE_TBL_TaskData.ValidationResults[RegRecPtr->ValidateActiveIndex].State = CFE_TBL_VALIDATION_PERFORMED;
        5: 1327:            RegRecPtr->ValidateActiveIndex = CFE_TBL_NO_VALIDATION_PENDING;
        -: 1328:
        -: 1329:            /* Since the validation was successfully performed (although maybe not a successful result) */
        -: 1330:            /* return a success status */
        5: 1331:            Status = CFE_SUCCESS;
        -: 1332:        }
        -: 1333:        else
        -: 1334:        {
        1: 1335:            Status = CFE_TBL_INFO_NO_VALIDATION_PENDING;
        -: 1336:        }
        -: 1337:    }
        -: 1338:    else
        -: 1339:    {
        1: 1340:        CFE_ES_WriteToSysLog("CFE_TBL:Validate-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1341:                             ThisAppId, TblHandle);
        -: 1342:    }
        -: 1343:
       12: 1344:    return Status;
        -: 1345:}   /* End of CFE_TBL_Validate() */
        -: 1346:
        -: 1347:
        -: 1348:/*******************************************************************
        -: 1349:**
        -: 1350:** CFE_TBL_Manage() -- Perform standard table maintenance on the
        -: 1351:**                     specified table
        -: 1352:**
        -: 1353:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1354:********************************************************************/
        -: 1355:
        -: 1356:int32 CFE_TBL_Manage( CFE_TBL_Handle_t TblHandle )
       14: 1357:{
       14: 1358:    int32   Status = CFE_SUCCESS;
       14: 1359:    boolean FinishedManaging = FALSE;
        -: 1360:
       52: 1361:    while (!FinishedManaging)
        -: 1362:    {
        -: 1363:        /* Determine if the table has a validation or update that needs to be performed */
       24: 1364:        Status = CFE_TBL_GetStatus(TblHandle);
        -: 1365:
       24: 1366:        if (Status == CFE_TBL_INFO_VALIDATION_PENDING)
        -: 1367:        {
        -: 1368:            /* Validate the specified Table */
       10: 1369:            Status = CFE_TBL_Validate(TblHandle);
        -: 1370:
       10: 1371:            if (Status != CFE_SUCCESS)
        -: 1372:            {
        -: 1373:                /* If an error occurred during Validate, then do not perform any more managing */
    #####: 1374:                FinishedManaging = TRUE;
        -: 1375:            }
        -: 1376:        }
       14: 1377:        else if (Status == CFE_TBL_INFO_DUMP_PENDING)
        -: 1378:        {
        -: 1379:            /* Dump the specified Table */
        1: 1380:            Status = CFE_TBL_DumpToBuffer(TblHandle);
        -: 1381:            
        -: 1382:            /* After a Dump, always assume we are done (Dumps are on DumpOnly tables and cannot be "Updated") */
        1: 1383:            FinishedManaging = TRUE;
        -: 1384:        }
       13: 1385:        else if (Status == CFE_TBL_INFO_UPDATE_PENDING)
        -: 1386:        {
        -: 1387:            /* Update the specified Table */
        2: 1388:            Status = CFE_TBL_Update(TblHandle);
        -: 1389:
        -: 1390:            /* If the update performed nominally, let the caller know the table has changed */
        2: 1391:            if (Status == CFE_SUCCESS)
        -: 1392:            {
        1: 1393:                Status = CFE_TBL_INFO_UPDATED;
        -: 1394:            }
        -: 1395:            
        -: 1396:            /* After an Update, always assume we are done and return Update Status */
        2: 1397:            FinishedManaging = TRUE;
        -: 1398:        }
        -: 1399:        else
        -: 1400:        {
       11: 1401:            FinishedManaging = TRUE;
        -: 1402:        }
        -: 1403:    }
        -: 1404:
       14: 1405:    return Status;
        -: 1406:}   /* End of CFE_TBL_Manage() */
        -: 1407:
        -: 1408:
        -: 1409:/*******************************************************************
        -: 1410:**
        -: 1411:** CFE_TBL_GetStatus() -- Obtain pending action status for specified table
        -: 1412:**
        -: 1413:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1414:********************************************************************/
        -: 1415:
        -: 1416:int32 CFE_TBL_GetStatus( CFE_TBL_Handle_t TblHandle )
       26: 1417:{
       26: 1418:    int32                       Status = CFE_SUCCESS;
        -: 1419:    uint32                      ThisAppId;
        -: 1420:    CFE_TBL_RegistryRec_t      *RegRecPtr;
        -: 1421:    CFE_TBL_AccessDescriptor_t *AccessDescPtr;
        -: 1422:
        -: 1423:    /* Verify that this application has the right to perform operation */
       26: 1424:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1425:
       26: 1426:    if (Status == CFE_SUCCESS)
        -: 1427:    {
        -: 1428:        /* Get pointers to pertinent records in registry and handles */
       25: 1429:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
       25: 1430:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1431:
        -: 1432:        /* Perform validations prior to performing any updates */
       25: 1433:        if (RegRecPtr->LoadPending)
        -: 1434:        {
        2: 1435:            Status = CFE_TBL_INFO_UPDATE_PENDING;
        -: 1436:        }
       33: 1437:        else if ((RegRecPtr->ValidateActiveIndex != CFE_TBL_NO_VALIDATION_PENDING) ||
        -: 1438:                 (RegRecPtr->ValidateInactiveIndex != CFE_TBL_NO_VALIDATION_PENDING))
        -: 1439:        {
       10: 1440:            Status = CFE_TBL_INFO_VALIDATION_PENDING;
        -: 1441:        }
       13: 1442:        else if (RegRecPtr->DumpControlIndex != CFE_TBL_NO_DUMP_PENDING)
        -: 1443:        {
        2: 1444:            Status = CFE_TBL_INFO_DUMP_PENDING;
        -: 1445:        }
        -: 1446:    }
        -: 1447:    else
        -: 1448:    {
        1: 1449:        CFE_ES_WriteToSysLog("CFE_TBL:GetStatus-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1450:                             ThisAppId, TblHandle);
        -: 1451:    }
        -: 1452:
       26: 1453:    return Status;
        -: 1454:}   /* End of CFE_TBL_GetStatus() */
        -: 1455:
        -: 1456:
        -: 1457:/*******************************************************************
        -: 1458:**
        -: 1459:** CFE_TBL_GetInfo() -- Obtain characteristics/information for specified table
        -: 1460:**
        -: 1461:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1462:********************************************************************/
        -: 1463:
        -: 1464:int32 CFE_TBL_GetInfo( CFE_TBL_Info_t *TblInfoPtr, const char *TblName )
        7: 1465:{
        7: 1466:    int32                    Status = CFE_SUCCESS;
        7: 1467:    int16                    RegIndx = CFE_TBL_NOT_FOUND;
        7: 1468:    int32                    NumAccessDescriptors = 0;
        -: 1469:    CFE_TBL_RegistryRec_t   *RegRecPtr;
        -: 1470:    CFE_TBL_Handle_t         HandleIterator;
        -: 1471:
        7: 1472:    RegIndx = CFE_TBL_FindTableInRegistry(TblName);
        -: 1473:
        -: 1474:    /* If we found the table, then extract the information from the Registry */
        7: 1475:    if (RegIndx != CFE_TBL_NOT_FOUND)
        -: 1476:    {
        -: 1477:        /* Get pointer to Registry Record Entry to speed up processing */
        6: 1478:        RegRecPtr = &CFE_TBL_TaskData.Registry[RegIndx];
        -: 1479:
        -: 1480:        /* Return table characteristics */        
        6: 1481:        TblInfoPtr->Size        = RegRecPtr->Size;
        6: 1482:        TblInfoPtr->DblBuffered = RegRecPtr->DblBuffered;
        6: 1483:        TblInfoPtr->DumpOnly    = RegRecPtr->DumpOnly;
        6: 1484:        TblInfoPtr->UserDefAddr = RegRecPtr->UserDefAddr;
        6: 1485:        TblInfoPtr->TableLoadedOnce = RegRecPtr->TableLoadedOnce;
        -: 1486:        
        -: 1487:        /* Return information on last load and update */
        6: 1488:        TblInfoPtr->TimeOfLastUpdate = RegRecPtr->TimeOfLastUpdate;
        6: 1489:        TblInfoPtr->FileCreateTimeSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSecs;
        6: 1490:        TblInfoPtr->FileCreateTimeSubSecs = RegRecPtr->Buffers[RegRecPtr->ActiveBufferIndex].FileCreateTimeSubSecs;
        6: 1491:        strncpy(TblInfoPtr->LastFileLoaded, RegRecPtr->LastFileLoaded, OS_MAX_PATH_LEN);
        -: 1492:        
        -: 1493:        /* Count the number of Access Descriptors to determine the number of users */
        6: 1494:        HandleIterator = RegRecPtr->HeadOfAccessList;
       19: 1495:        while (HandleIterator != CFE_TBL_END_OF_LIST)
        -: 1496:        {
        7: 1497:            NumAccessDescriptors++;
        7: 1498:            HandleIterator = CFE_TBL_TaskData.Handles[HandleIterator].NextLink;
        -: 1499:        }
        -: 1500:
        6: 1501:        TblInfoPtr->NumUsers = NumAccessDescriptors;
        -: 1502:        
        6: 1503:        TblInfoPtr->Critical = RegRecPtr->CriticalTable;  
        -: 1504:    }
        -: 1505:    else
        -: 1506:    {
        1: 1507:        Status = CFE_TBL_ERR_INVALID_NAME;
        -: 1508:    }
        -: 1509:
        7: 1510:    return Status;
        -: 1511:}   /* End of CFE_TBL_GetInfo() */
        -: 1512:
        -: 1513:/*******************************************************************
        -: 1514:**
        -: 1515:** CFE_TBL_DumpToBuffer - Copy Dump Only table to buffer for later dump to file by table services
        -: 1516:**
        -: 1517:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1518:********************************************************************/
        -: 1519:
        -: 1520:int32 CFE_TBL_DumpToBuffer( CFE_TBL_Handle_t TblHandle )
        1: 1521:{
        1: 1522:    int32                       Status = CFE_SUCCESS;
        1: 1523:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
        1: 1524:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        1: 1525:    CFE_TBL_DumpControl_t      *DumpCtrlPtr = NULL;
        -: 1526:    CFE_TIME_SysTime_t          DumpTime;
        -: 1527:    
        -: 1528:    /* Make sure the table has been requested to be dumped */
        1: 1529:    Status = CFE_TBL_GetStatus(TblHandle);
        1: 1530:    if (Status == CFE_TBL_INFO_DUMP_PENDING)
        -: 1531:    {
        1: 1532:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        1: 1533:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        1: 1534:        DumpCtrlPtr = &CFE_TBL_TaskData.DumpControlBlocks[RegRecPtr->DumpControlIndex];
        -: 1535:        
        -: 1536:        /* Copy the contents of the active buffer to the assigned dump buffer */
        1: 1537:        OS_MemCpy(DumpCtrlPtr->DumpBufferPtr->BufferPtr, RegRecPtr->Buffers[0].BufferPtr, DumpCtrlPtr->Size);
        -: 1538:        
        -: 1539:        /* Save the current time so that the header in the dump file can have the correct time */
        1: 1540:        DumpTime = CFE_TIME_GetTime();
        1: 1541:        DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSecs = DumpTime.Seconds;
        1: 1542:        DumpCtrlPtr->DumpBufferPtr->FileCreateTimeSubSecs = DumpTime.Subseconds;
        -: 1543:        
        -: 1544:        /* Disassociate the dump request from the table */
        1: 1545:        RegRecPtr->DumpControlIndex = CFE_TBL_NO_DUMP_PENDING;
        -: 1546:        
        -: 1547:        /* Notify the Table Services Application that the dump buffer is ready to be written to a file */
        1: 1548:        DumpCtrlPtr->State = CFE_TBL_DUMP_PERFORMED;
        -: 1549:        
        1: 1550:        Status = CFE_SUCCESS;
        -: 1551:    }
        -: 1552:    
        1: 1553:    return Status;
        -: 1554:}   /* End of CFE_TBL_DumpToBuffer() */
        -: 1555:
        -: 1556:
        -: 1557:/*******************************************************************
        -: 1558:**
        -: 1559:** CFE_TBL_Modified - Notify TBL Services that the contents of the table has been modified by the application
        -: 1560:**
        -: 1561:** NOTE: For complete prolog information, see 'cfe_tbl.h'
        -: 1562:********************************************************************/
        -: 1563:
        -: 1564:int32 CFE_TBL_Modified( CFE_TBL_Handle_t TblHandle )
        3: 1565:{
        3: 1566:    int32                       Status = CFE_SUCCESS;
        3: 1567:    CFE_TBL_AccessDescriptor_t *AccessDescPtr = NULL;
        3: 1568:    CFE_TBL_RegistryRec_t      *RegRecPtr = NULL;
        -: 1569:    CFE_TBL_Handle_t            AccessIterator;
        -: 1570:    uint32                      ThisAppId;
        3: 1571:    uint32                      FilenameLen = 0;
        -: 1572:
        -: 1573:    /* Verify that this application has the right to perform operation */
        3: 1574:    Status = CFE_TBL_ValidateAccess(TblHandle, &ThisAppId);
        -: 1575:
        3: 1576:    if (Status == CFE_SUCCESS)
        -: 1577:    {
        -: 1578:        /* Get pointers to pertinent records in registry and handles */
        2: 1579:        AccessDescPtr = &CFE_TBL_TaskData.Handles[TblHandle];
        2: 1580:        RegRecPtr = &CFE_TBL_TaskData.Registry[AccessDescPtr->RegIndex];
        -: 1581:
        2: 1582:        AccessIterator = RegRecPtr->HeadOfAccessList;
        6: 1583:        while (AccessIterator != CFE_TBL_END_OF_LIST)
        -: 1584:        {
        2: 1585:            CFE_TBL_TaskData.Handles[AccessIterator].Updated = TRUE;
        -: 1586:
        2: 1587:            AccessIterator = CFE_TBL_TaskData.Handles[AccessIterator].NextLink;
        -: 1588:        }
        -: 1589:        
        -: 1590:        /* If the table is a critical table, update the appropriate CDS with the new data */
        2: 1591:        if (RegRecPtr->CriticalTable == TRUE)
        -: 1592:        {
        1: 1593:            CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        -: 1594:        }
        -: 1595:        
        -: 1596:        /* Keep a record of change for the ground operators reference */
        2: 1597:        RegRecPtr->TimeOfLastUpdate = CFE_TIME_GetTime();
        2: 1598:        RegRecPtr->LastFileLoaded[OS_MAX_PATH_LEN-1] = '\0';
        2: 1599:        FilenameLen = strlen(RegRecPtr->LastFileLoaded);
        2: 1600:        if (FilenameLen < (OS_MAX_PATH_LEN-4))
        -: 1601:        {
        1: 1602:            strncpy(&RegRecPtr->LastFileLoaded[FilenameLen], "(*)", 4);
        -: 1603:        }
        -: 1604:        else
        -: 1605:        {
        1: 1606:            strncpy(&RegRecPtr->LastFileLoaded[(OS_MAX_PATH_LEN-4)], "(*)", 4);
        -: 1607:        }
        -: 1608:    }
        -: 1609:    else
        -: 1610:    {
        1: 1611:        CFE_ES_WriteToSysLog("CFE_TBL:Modified-App(%d) does not have access to Tbl Handle=%d\n",
        -: 1612:                             ThisAppId, TblHandle);
        -: 1613:    }
        -: 1614:
        -: 1615:    
        3: 1616:    return Status;
        -: 1617:}
        -: 1618:
        -: 1619:
        -: 1620:/************************/
        -: 1621:/*  End of File Comment */
        -: 1622:/************************/
        -: 1623:
