        -:    0:Source:/home/acudmore/Projects/cFE-6.4-development/cfe/fsw/cfe-core/src/es/cfe_es_api.c
        -:    0:Programs:10
        -:    1:/*
        -:    2:**  File:  
        -:    3:**    cfe_es_api.c
        -:    4:**
        -:    5:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    6:**      administrator of the National Aeronautics Space Administration.  
        -:    7:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:    8:**      Space Flight Center pursuant to government contracts.
        -:    9:**
        -:   10:**      This is governed by the NASA Open Source Agreement and may be used,
        -:   11:**      distributed and modified only pursuant to the terms of that agreement.
        -:   12:**
        -:   13:**
        -:   14:**  Purpose:  
        -:   15:**    This file implements the cFE Executive Services API functions.
        -:   16:**
        -:   17:**  References:
        -:   18:**     Flight Software Branch C Coding Standard Version 1.0a
        -:   19:**     cFE Flight Software Application Developers Guide
        -:   20:**
        -:   21:**  Notes:
        -:   22:** 
        -:   23:**  Modification History:
        -:   24:**
        -:   25:** $Log: cfe_es_api.c.gcov  $
        -:   25:** Revision 1.5 2014/09/23 15:04:37GMT-05:00 acudmore 
        -:   25:** Updated ES unit test results for cFE build 6.4.0
        -:   26:** Revision 1.21 2014/09/05 11:37:51GMT-05:00 acudmore 
        -:   27:** Updated Syslog and ERlog text in CFE_ES_ResetCFE
        -:   28:** Revision 1.20 2014/08/22 15:50:05GMT-05:00 lwalling 
        -:   29:** Changed signed loop counters to unsigned
        -:   30:** Revision 1.19 2014/07/23 15:35:46EDT acudmore 
        -:   31:** Updated where the Processor Reset counter is incremented.
        -:   32:** Made the ER log entry text clearer.
        -:   33:** Revision 1.18 2014/05/05 14:44:53GMT-05:00 acudmore 
        -:   34:** fixed potential unititialized variable
        -:   35:** Revision 1.17 2014/05/05 14:03:39GMT-05:00 acudmore 
        -:   36:** Fixed syslog logic to check for invalid syslog mode and index due to corrupted global memory
        -:   37:** Revision 1.16 2012/04/20 15:21:32GMT-05:00 acudmore 
        -:   38:** Fixed reset subtype in CFE_ES_ResetCFE function.
        -:   39:** Revision 1.15 2012/01/13 11:49:59EST acudmore 
        -:   40:** Changed license text to reflect open source
        -:   41:** Revision 1.14 2012/01/11 18:51:33EST aschoeni 
        -:   42:** Removed child task exit message from system log
        -:   43:** Revision 1.13 2011/09/02 11:02:56EDT jmdagost 
        -:   44:** Added new-line charactesr to the end of sys log messages that were missing them.
        -:   45:** Revision 1.12 2011/07/15 14:28:52EDT lwalling 
        -:   46:** Removed const qualifier from CounterName argument to CFE_ES_RegisterGenCounter()
        -:   47:** Revision 1.11 2010/11/05 15:54:33EDT aschoeni 
        -:   48:** Added Generic Counter API to ES
        -:   49:** Revision 1.10 2010/11/05 15:05:23EDT acudmore 
        -:   50:** Updated CRC function to read memory through PSP interface.
        -:   51:** Revision 1.9 2010/10/25 15:45:28EDT jmdagost 
        -:   52:** Added Task Name and/or TaskID in syslog messsages in CFE_ES_CreateChildTask().
        -:   53:** Revision 1.8 2009/07/28 16:30:29EDT jmdagost 
        -:   54:** Replaced 34 references to filename with references to function name.
        -:   55:** Revision 1.7 2009/06/10 09:08:50EDT acudmore 
        -:   56:** Converted OS_Mem* and OS_BSP* API to CFE_PSP_* API
        -:   57:** Revision 1.6 2008/08/27 15:56:19EDT apcudmore 
        -:   58:** removed startup sync debug OS_printfs
        -:   59:** Revision 1.5 2008/08/01 15:54:54EDT apcudmore 
        -:   60:** Updated Startup sync logic after vxWorks tests.
        -:   61:** Revision 1.4 2008/07/31 15:41:32EDT apcudmore 
        -:   62:** Added execution counter API:
        -:   63:**   -- Added execution counter to ES internal task data
        -:   64:**   -- Added code to increment counter in RunLoop
        -:   65:**   -- Added code to report counter in GetInfo APIs
        -:   66:**   -- Added API to increment counter for child tasks
        -:   67:**   -- Added code to cFE Core apps to increment counters.
        -:   68:** Revision 1.3 2008/07/30 14:52:31EDT apcudmore 
        -:   69:** Added startup sync support and API
        -:   70:** Revision 1.2 2008/06/26 15:41:53EDT apcudmore 
        -:   71:** Added public CFE_ES_GetAppInfo API.
        -:   72:** Moved the old API to CFE_ES_GetAppInfoInternal
        -:   73:** -- May merge these two in the near future.
        -:   74:** Revision 1.1 2008/04/17 08:05:02EDT ruperera 
        -:   75:** Initial revision
        -:   76:** Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/src/es/project.pj
        -:   77:** Revision 1.72 2007/09/25 10:44:33EDT apcudmore 
        -:   78:** Removed unused variable.
        -:   79:** Revision 1.71 2007/09/25 10:24:06EDT apcudmore 
        -:   80:** Implement Application Restart on Exception:
        -:   81:** - Added logic to Exception Handler
        -:   82:** - Changed Exception Hook to pass host task ID
        -:   83:** - Added App Reset ER Log entry type
        -:   84:** Revision 1.70 2007/09/21 15:40:20EDT David Kobe (dlkobe) 
        -:   85:** Modified pointer type definitions to eliminate Linux gcc compile warnings
        -:   86:** Revision 1.69 2007/09/20 10:53:00EDT apcudmore 
        -:   87:** Added Query All Tasks command, file definition, events, error codes etc.
        -:   88:** Revision 1.68 2007/05/31 10:11:34EDT apcudmore 
        -:   89:** Removed CFE_ES_CPU_CONTEXT_SIZE from verify.h
        -:   90:** Removed unused variable.
        -:   91:** Revision 1.67 2007/05/30 10:16:50EDT apcudmore 
        -:   92:** Fixed RunLoop Crash 
        -:   93:** Revision 1.66 2007/05/25 11:55:43EDT apcudmore 
        -:   94:** Error Handling updates
        -:   95:**    - CFE_ES_GetAppInfo returns void
        -:   96:**    - added app ID range check in RestartApp
        -:   97:**  
        -:   98:** Revision 1.65 2007/05/15 16:08:51EDT apcudmore 
        -:   99:** Updated CFE_ES_ExitApp to:
        -:  100:**    -- Do a Processor Reset on Core app init failure
        -:  101:**    -- Exit the task on a Core App Runtime failure
        -:  102:** Revision 1.64 2007/05/14 15:43:46EDT apcudmore 
        -:  103:** Cleaned up events and disabled debug code for application restart.
        -:  104:** Revision 1.63 2007/05/04 16:02:50EDT apcudmore 
        -:  105:** Removed debug printf.
        -:  106:** Revision 1.62 2007/05/04 15:58:35EDT apcudmore 
        -:  107:** Implemented ES shared data protection. Eliminates Startup syncronization problem.
        -:  108:** Revision 1.61 2007/05/02 11:59:11EDT apcudmore 
        -:  109:** Initialized "ThisAppId" variable to zero from Static Analysis advice.
        -:  110:** Revision 1.60 2007/04/28 15:42:40EDT dlkobe 
        -:  111:** Added missing semicolon
        -:  112:** Revision 1.59 2007/04/28 15:40:53EDT dlkobe 
        -:  113:** Fix corrupted file
        -:  114:** Revision 1.58 2007/04/28 15:35:19EDT dlkobe 
        -:  115:** Corrected Typos from restructuring
        -:  116:** Revision 1.57 2007/04/28 15:32:38EDT dlkobe 
        -:  117:** Restructured CFE_ES_RegisterCDS call to avoid Application Unknown Error
        -:  118:** Revision 1.56 2007/04/28 14:49:00EDT dlkobe 
        -:  119:** Baseline Implementation of Critical Tables
        -:  120:** Revision 1.55 2007/04/25 11:57:08EDT apcudmore 
        -:  121:** Implemented "Back End" of Application Restart and Delete.
        -:  122:** Changes include all ES Cleanup code to delete App and Task Resources.
        -:  123:** Revision 1.54 2007/04/13 16:24:52EDT apcudmore 
        -:  124:** Fixed "==" bug in If/then/else clause in CFE_ES_ExitApp
        -:  125:** Revision 1.53 2007/04/12 10:37:19EDT apcudmore 
        -:  126:** Added support for ES task to call CFE_ES_ExitApp on initialization and runtime failure.
        -:  127:** Revision 1.52 2007/04/09 15:12:04EDT dlkobe 
        -:  128:** Modified 'Name' parameter to be a const pointer
        -:  129:** Revision 1.51 2007/04/06 12:23:58EDT apcudmore 
        -:  130:** Added Paramter verification and a check to make sure that CFE_ES_CreateChildTask is not 
        -:  131:** called from another Child Task.
        -:  132:** Revision 1.49 2007/04/05 16:16:03EDT apcudmore 
        -:  133:** Added CFE_ES_DeleteChildTask and CFE_ES_ExitChildTask along with headers,
        -:  134:** and associated Error codes.
        -:  135:** Revision 1.48 2007/03/23 15:06:26EST apcudmore 
        -:  136:** Fixes for DCR 470: Improved error handling for CFE_ES_RegisterApp and CFE_ES_RegisterChildTask.
        -:  137:**                             Removed circular include.
        -:  138:** Revision 1.47 2007/03/23 10:47:23EST apcudmore 
        -:  139:** Added CFE_ES_GetTaskInfo call and corresponding CFE_ES_TaskInfo_t data structure.
        -:  140:** Revision 1.46 2007/03/22 10:26:23EST apcudmore 
        -:  141:** Implemented all code walkthrough items related to ES Application logic, commands, and telemetry.
        -:  142:** Revision 1.45 2007/03/16 10:07:13EST apcudmore 
        -:  143:** Fixed Compile error in CreateChildTask
        -:  144:** Revision 1.44 2007/03/16 09:37:48EST apcudmore 
        -:  145:** Removed code that does not allow a Child task's priority to be greater than it's parent.
        -:  146:** Revision 1.43 2007/03/13 16:10:54EST apcudmore 
        -:  147:** Implemented all ERLog and ES API code walkthrough items.
        -:  148:** Revision 1.42 2007/02/28 10:09:30EST apcudmore 
        -:  149:** Command/control logic for ES Application Restart
        -:  150:**
        -:  151:*/
        -:  152:
        -:  153:/*
        -:  154:** Required header files.
        -:  155:*/
        -:  156:#include "cfe.h"
        -:  157:#include "cfe_es.h"
        -:  158:#include "cfe_es_apps.h"
        -:  159:#include "cfe_es_global.h"
        -:  160:#include "cfe_es_events.h"
        -:  161:#include "cfe_es_cds.h"
        -:  162:#include "cfe_es_cds_mempool.h"
        -:  163:#include "cfe_psp.h"
        -:  164:#include "cfe_es_log.h"
        -:  165:
        -:  166:
        -:  167:#include <string.h>
        -:  168:#include <stdio.h>
        -:  169:#include <stdarg.h>
        -:  170:
        -:  171:
        -:  172:/*
        -:  173:** Function: CFE_ES_GetResetType
        -:  174:**
        -:  175:** Purpose:  Return The Type of reset the cFE had.
        -:  176:**           The function will return the start type 
        -:  177:**           which is CFE_ES_POWERON_RESET or CFE_ES_PROCESSOR_RESET.
        -:  178:**           The sub-type is optional and will be returned if a non-NULL pointer
        -:  179:**           is passed in to the function.
        -:  180:*/
        1:  181:int32 CFE_ES_GetResetType(uint32 *ResetSubtypePtr)
        -:  182:{
        1:  183:    if ( ResetSubtypePtr != NULL )
        -:  184:    {
        1:  185:       *ResetSubtypePtr = CFE_ES_ResetDataPtr->ResetVars.ResetSubtype;
        -:  186:    }
        -:  187:
        1:  188:    return(CFE_ES_ResetDataPtr->ResetVars.ResetType);
        -:  189:
        -:  190:} /* End of CFE_ES_GetResetType() */
        -:  191:
        -:  192:
        -:  193:/*
        -:  194:** Function: CFE_ES_ResetCFE
        -:  195:**
        -:  196:** Purpose:  Reset the cFE core and all apps.
        -:  197:**
        -:  198:*/
        6:  199:int32 CFE_ES_ResetCFE(uint32 ResetType)
        -:  200:{
        -:  201:    int32 ReturnCode;
        -:  202:    int32 status;
        -:  203:    
        6:  204:    if ( ResetType == CFE_ES_PROCESSOR_RESET )
        -:  205:    {
        -:  206:       /*
        -:  207:       ** Increment the processor reset count
        -:  208:       */
        4:  209:       CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount++;
        -:  210:
        -:  211:       /*
        -:  212:       ** Before doing a Processor reset, check to see 
        -:  213:       ** if the maximum number has been exceeded
        -:  214:       */
        8:  215:       if ( CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount > 
        4:  216:            CFE_ES_ResetDataPtr->ResetVars.MaxProcessorResetCount )
        -:  217:       {
        2:  218:           CFE_ES_WriteToSysLog("POWER ON RESET due to max proc resets (Commanded).\n");
        -:  219:
        -:  220:           /*
        -:  221:           ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -:  222:           ** the entry just in case something fails.
        -:  223:           */
        2:  224:           status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_POWERON_RESET, 
        -:  225:                                         CFE_ES_RESET_COMMAND,
        -:  226:                                         "POWER ON RESET due to max proc resets (Commanded).", NULL,0 );
        -:  227:           /*
        -:  228:           ** Call the BSP reset routine 
        -:  229:           */
        2:  230:           CFE_PSP_Restart(CFE_ES_POWERON_RESET);
        -:  231:       }
        -:  232:       else
        -:  233:       {
        2:  234:           CFE_ES_WriteToSysLog("PROCESSOR RESET called from CFE_ES_ResetCFE (Commanded).\n");
        -:  235:
        -:  236:           /*
        -:  237:           ** Update the reset variables
        -:  238:           */
        2:  239:           CFE_ES_ResetDataPtr->ResetVars.ES_CausedReset = TRUE;
        -:  240:
        -:  241:           /*
        -:  242:           ** Log the reset in the ER Log
        -:  243:           */
        2:  244:           status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_PROCESSOR_RESET,
        -:  245:                                       CFE_ES_RESET_COMMAND,
        -:  246:                                       "PROCESSOR RESET called from CFE_ES_ResetCFE (Commanded).", NULL,0 );
        -:  247:           /*
        -:  248:           ** Call the BSP reset routine
        -:  249:           */
        2:  250:           CFE_PSP_Restart(ResetType);
        -:  251:       
        -:  252:       } /* end if */
        -:  253:       
        -:  254:       /* 
        -:  255:       ** If the BSP routine is not implemented, 
        -:  256:       ** it will return. 
        -:  257:       */
        4:  258:       ReturnCode = CFE_ES_NOT_IMPLEMENTED;
        -:  259:    }
        2:  260:    else if ( ResetType == CFE_ES_POWERON_RESET )
        -:  261:    {
        1:  262:       CFE_ES_WriteToSysLog("POWERON RESET called from CFE_ES_ResetCFE (Commanded).\n");
        -:  263:
        -:  264:       /*
        -:  265:       ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -:  266:       ** the entry just in case something fails.
        -:  267:       */
        1:  268:       status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_POWERON_RESET, 
        -:  269:                                       CFE_ES_RESET_COMMAND,
        -:  270:                                       "POWERON RESET called from CFE_ES_ResetCFE (Commanded).", NULL,0 );
        -:  271:
        -:  272:       /*
        -:  273:       ** Call the BSP reset routine
        -:  274:       */
        1:  275:       CFE_PSP_Restart(ResetType);
        -:  276:       
        -:  277:       /* 
        -:  278:       ** If the BSP routine is not implemented, 
        -:  279:       ** it will return. 
        -:  280:       */
        1:  281:       ReturnCode = CFE_ES_NOT_IMPLEMENTED;
        -:  282:    }
        -:  283:    else
        -:  284:    {
        1:  285:       CFE_ES_WriteToSysLog("ES ResetCFE: Invalid Reset Type: %d.\n",ResetType);
        1:  286:       ReturnCode = CFE_ES_BAD_ARGUMENT;
        -:  287:    }
        -:  288:
        6:  289:    return(ReturnCode);
        -:  290:    
        -:  291:} /* End of CFE_ES_ResetCFE() */
        -:  292:
        -:  293:/*
        -:  294:** Function: CFE_ES_RestartApp
        -:  295:**
        -:  296:** Purpose:  Restart a single cFE App.
        -:  297:**
        -:  298:*/
        5:  299:int32 CFE_ES_RestartApp(uint32 AppID)
        -:  300:{
        5:  301:    int32 ReturnCode = CFE_SUCCESS;
        -:  302:
        5:  303:    if ( AppID < CFE_ES_MAX_APPLICATIONS )
        -:  304:    {
        -:  305:
        4:  306:       CFE_ES_LockSharedData(__func__,__LINE__);
        -:  307:    
        -:  308:       /*
        -:  309:       ** Check to see if the App is an external cFE App.
        -:  310:       */
        4:  311:       if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_APP_TYPE_CORE )
        -:  312:       {
        1:  313:          CFE_ES_WriteToSysLog ("CFE_ES_DeleteApp: Cannot Restart a CORE Application: %s.\n",
        -:  314:                             CFE_ES_Global.AppTable[AppID].StartParams.Name );
        1:  315:          ReturnCode = CFE_ES_ERR_APPID; 
        -:  316:       }
        3:  317:       else if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState != CFE_ES_APP_STATE_RUNNING )
        -:  318:       {
        2:  319:          CFE_ES_WriteToSysLog ("CFE_ES_RestartApp: Cannot Restart Application %s, It is not running.\n",
        -:  320:                              CFE_ES_Global.AppTable[AppID].StartParams.Name);
        2:  321:          ReturnCode = CFE_ES_ERR_APPID; 
        -:  322:       }
        -:  323:       else
        -:  324:       {
        1:  325:          CFE_ES_WriteToSysLog("CFE_ES_RestartApp: Restart Application %s Initiated\n",
        -:  326:                             CFE_ES_Global.AppTable[AppID].StartParams.Name);
        1:  327:          CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_SYS_RESTART;
        1:  328:          CFE_ES_Global.AppTable[AppID].StateRecord.AppState = CFE_ES_APP_STATE_WAITING;
        1:  329:          CFE_ES_Global.AppTable[AppID].StateRecord.AppTimer = CFE_ES_APP_KILL_TIMEOUT;
        -:  330:       }
        -:  331:    
        4:  332:       CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  333:    }
        -:  334:    else /* App ID is not valid */
        -:  335:    {
        1:  336:       ReturnCode = CFE_ES_ERR_APPID;
        -:  337:
        -:  338:    } /* end if */
        -:  339:
        5:  340:    return(ReturnCode);
        -:  341:
        -:  342:} /* End of CFE_ES_RestartApp() */
        -:  343:
        -:  344:/*
        -:  345:** Function: CFE_ES_ReloadApp
        -:  346:**
        -:  347:** Purpose:  Reload a single cFE App.
        -:  348:**
        -:  349:*/
        3:  350:int32 CFE_ES_ReloadApp(uint32 AppID, const char *AppFileName)
        -:  351:{
        3:  352:    int32 ReturnCode = CFE_SUCCESS;
        -:  353:
        3:  354:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  355:    
        -:  356:    /*
        -:  357:    ** Check to see if the App is an external cFE App.
        -:  358:    */
        3:  359:    if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_APP_TYPE_CORE )
        -:  360:    {
        1:  361:       CFE_ES_WriteToSysLog ("CFE_ES_DeleteApp: Cannot Reload a CORE Application: %s.\n", 
        -:  362:       CFE_ES_Global.AppTable[AppID].StartParams.Name );
        1:  363:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  364:    }
        2:  365:    else if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState != CFE_ES_APP_STATE_RUNNING )
        -:  366:    {
        1:  367:       CFE_ES_WriteToSysLog ("CFE_ES_ReloadApp: Cannot Reload Application %s, It is not running.\n",
        -:  368:                              CFE_ES_Global.AppTable[AppID].StartParams.Name);
        1:  369:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  370:    }    
        -:  371:    else
        -:  372:    {    
        1:  373:       CFE_ES_WriteToSysLog("CFE_ES_ReloadApp: Reload Application %s Initiated. New filename = %s\n", 
        -:  374:                             CFE_ES_Global.AppTable[AppID].StartParams.Name, AppFileName);
        1:  375:       strncpy((char *)CFE_ES_Global.AppTable[AppID].StartParams.FileName, AppFileName, OS_MAX_PATH_LEN);
        1:  376:       CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_SYS_RELOAD;
        1:  377:       CFE_ES_Global.AppTable[AppID].StateRecord.AppState = CFE_ES_APP_STATE_WAITING;
        1:  378:       CFE_ES_Global.AppTable[AppID].StateRecord.AppTimer = CFE_ES_APP_KILL_TIMEOUT;
        -:  379:    }
        -:  380:    
        3:  381:    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  382:        
        3:  383:    return(ReturnCode);
        -:  384:
        -:  385:} /* End of CFE_ES_ReloadApp() */
        -:  386:
        -:  387:/*
        -:  388:** Function: CFE_ES_DeleteApp
        -:  389:**
        -:  390:** Purpose:  Delete a cFE App.
        -:  391:**
        -:  392:*/
        3:  393:int32 CFE_ES_DeleteApp(uint32 AppID)
        -:  394:{
        3:  395:    int32 ReturnCode = CFE_SUCCESS;
        -:  396:
        3:  397:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  398:    
        -:  399:    /*
        -:  400:    ** Check to see if the App is an external cFE App.
        -:  401:    */
        3:  402:    if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_APP_TYPE_CORE )
        -:  403:    {
        1:  404:       CFE_ES_WriteToSysLog ("CFE_ES_DeleteApp: Cannot Delete a CORE Application: %s.\n", 
        -:  405:       CFE_ES_Global.AppTable[AppID].StartParams.Name );
        1:  406:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  407:    }
        2:  408:    else if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState != CFE_ES_APP_STATE_RUNNING )
        -:  409:    {
        1:  410:       CFE_ES_WriteToSysLog ("CFE_ES_DeleteApp: Cannot Delete Application %s, It is not running.\n",
        -:  411:                              CFE_ES_Global.AppTable[AppID].StartParams.Name);
        1:  412:       ReturnCode = CFE_ES_ERR_APPID; 
        -:  413:    }
        -:  414:    else
        -:  415:    {
        1:  416:       CFE_ES_WriteToSysLog("CFE_ES_DeleteApp: Delete Application %s Initiated\n",
        -:  417:                             CFE_ES_Global.AppTable[AppID].StartParams.Name);    
        1:  418:       CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_SYS_DELETE;
        1:  419:       CFE_ES_Global.AppTable[AppID].StateRecord.AppState = CFE_ES_APP_STATE_WAITING;
        1:  420:       CFE_ES_Global.AppTable[AppID].StateRecord.AppTimer = CFE_ES_APP_KILL_TIMEOUT;
        -:  421:    }
        -:  422:    
        3:  423:    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  424:        
        3:  425:    return(ReturnCode);
        -:  426:
        -:  427:} /* End of CFE_ES_DeleteApp() */
        -:  428:
        -:  429:/*
        -:  430:** Function: CFE_ES_ExitApp
        -:  431:**
        -:  432:** Purpose:  Exit a cFE App.
        -:  433:**
        -:  434:*/
        5:  435:void CFE_ES_ExitApp(uint32 ExitStatus)
        -:  436:{
        -:  437:    int32   ReturnCode;
        -:  438:    uint32  AppID;
        -:  439:
        5:  440:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  441:
        -:  442:    /*
        -:  443:    ** Get App ID - Be careful not to lock the shared data before calling GetAppID
        -:  444:    */
        5:  445:    ReturnCode = CFE_ES_GetAppIDInternal(&AppID);
        5:  446:    if ( ReturnCode == CFE_SUCCESS )
        -:  447:    {
        -:  448:       /*
        -:  449:       ** Check to see if the App is an external cFE App.
        -:  450:       */
        3:  451:       if ( CFE_ES_Global.AppTable[AppID].Type == CFE_ES_APP_TYPE_CORE )
        -:  452:       {
        -:  453:          /*
        -:  454:          ** A core app should only call this function with one of two ExitStatus codes.
        -:  455:          */
        3:  456:          if ( ExitStatus == CFE_ES_CORE_APP_INIT_ERROR )
        -:  457:          {
        1:  458:              CFE_ES_WriteToSysLog ("CFE_ES_ExitApp: CORE Application %s Had an Init Error.\n",
        -:  459:                                     CFE_ES_Global.AppTable[AppID].StartParams.Name );
        -:  460:                                     
        -:  461:              /*
        -:  462:              ** Unlock the ES Shared data before calling ResetCFE 
        -:  463:              */
        1:  464:              CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  465:              
        -:  466:              
        -:  467:              /*
        -:  468:              ** Do a Processor Reset the cFE
        -:  469:              */                                                                                                          
        1:  470:              ReturnCode = CFE_ES_ResetCFE(CFE_ES_PROCESSOR_RESET);
        -:  471:              
        -:  472:              /*
        -:  473:              ** Code will not return
        -:  474:              */
        -:  475:              
        -:  476:          }
        2:  477:          else if ( ExitStatus == CFE_ES_CORE_APP_RUNTIME_ERROR )
        -:  478:          {
        1:  479:              CFE_ES_WriteToSysLog ("CFE_ES_ExitApp: CORE Application %s Had a Runtime Error.\n",
        -:  480:                                     CFE_ES_Global.AppTable[AppID].StartParams.Name );  
        -:  481:                                                                                             
        -:  482:              /*
        -:  483:              ** Unlock the ES Shared data before killing the main task
        -:  484:              */
        1:  485:              CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  486:                             
        -:  487:              /*
        -:  488:              ** Exit this task
        -:  489:              */
        1:  490:              OS_TaskExit();   
        -:  491:              
        -:  492:              /*
        -:  493:              ** Code will not return
        -:  494:              */
        -:  495:                                                                                       
        -:  496:          }
        -:  497:          else 
        -:  498:          {
        1:  499:              CFE_ES_WriteToSysLog ("CFE_ES_ExitApp, Cannot Exit CORE Application %s\n",
        -:  500:                                    CFE_ES_Global.AppTable[AppID].StartParams.Name );         
        -:  501:          }
        -:  502:                    
        -:  503:       }
        -:  504:       else /* It is an external App */
        -:  505:       {
        -:  506:          
    #####:  507:          CFE_ES_WriteToSysLog ("Application %s called CFE_ES_ExitApp\n",
        -:  508:                                 CFE_ES_Global.AppTable[AppID].StartParams.Name);
    #####:  509:          CFE_ES_Global.AppTable[AppID].StateRecord.AppState = CFE_ES_APP_STATE_STOPPED;
        -:  510:
        -:  511:
        -:  512:          /*
        -:  513:          ** Unlock the ES Shared data before suspending the app 
        -:  514:          */
    #####:  515:          CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  516:
        -:  517:          /*
        -:  518:          ** Suspend the Application until ES kills it.
        -:  519:          ** It might be better to have a way of suspending the app in the OS
        -:  520:          */
        -:  521:          while(1)
        -:  522:          {
    #####:  523:             OS_TaskDelay(500);
    #####:  524:          }
        -:  525:
        -:  526:       } /* end if */
        -:  527:   
        -:  528:   } /* end if ReturnCode == CFE_SUCCESS */
        -:  529:
        5:  530:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  531:   
        5:  532:} /* End of CFE_ES_ExitApp() */
        -:  533:
        -:  534:/*
        -:  535:** Function: CFE_ES_RunLoop
        -:  536:**
        -:  537:** Purpose:  Check the Run Status of an Application.
        -:  538:**
        -:  539:*/
        6:  540:int32 CFE_ES_RunLoop(uint32 *RunStatus)
        -:  541:{
        6:  542:    int32  ReturnCode = TRUE;
        -:  543:    uint32 AppID;
        -:  544:    uint32 TaskID;
        -:  545:    
        6:  546:    CFE_ES_LockSharedData(__func__,__LINE__);
        -:  547:
        -:  548:    /*
        -:  549:    ** Get App ID
        -:  550:    */
        6:  551:    ReturnCode = CFE_ES_GetAppIDInternal(&AppID);
        -:  552:
        6:  553:    if ( ReturnCode == CFE_SUCCESS )
        -:  554:    {
        -:  555:    
        -:  556:       /*
        -:  557:       ** Get the Task ID for the main task
        -:  558:       */
        5:  559:       TaskID = CFE_ES_Global.AppTable[AppID].TaskInfo.MainTaskId;
        -:  560:       
        -:  561:       /*
        -:  562:       ** Increment the execution counter for the main task
        -:  563:       */
        5:  564:       CFE_ES_Global.TaskTable[TaskID].ExecutionCounter++;
        -:  565:    
        -:  566:       /*
        -:  567:       ** Validate RunStatus
        -:  568:       */
        9:  569:       if ( *RunStatus == CFE_ES_APP_RUN || *RunStatus == CFE_ES_APP_EXIT || *RunStatus == CFE_ES_APP_ERROR )
        -:  570:       {  
        -:  571:          /*
        -:  572:          ** Look up the system control request
        -:  573:          */
        4:  574:          if ( *RunStatus == CFE_ES_APP_RUN )
        -:  575:          {            
        -:  576:             /* 
        -:  577:             ** The first time an App calls this function, change the state from 
        -:  578:             ** INITIALIZING to RUNNING. This is for the startup syncronization code below
        -:  579:             */
        3:  580:             if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState == CFE_ES_APP_STATE_INITIALIZING)
        -:  581:             {
        -:  582:                /* 
        -:  583:                ** Change the state to RUNNING
        -:  584:                */
        1:  585:                CFE_ES_Global.AppTable[AppID].StateRecord.AppState = CFE_ES_APP_STATE_RUNNING;
        -:  586:                
        -:  587:                /*
        -:  588:                ** Once the Startup Sync point has been passed, it will not apply to new apps.
        -:  589:                ** These new Apps will be started individually by a command to ES.
        -:  590:                */
        1:  591:                if ( CFE_ES_Global.StartupSemaphoreReleased == FALSE)
        -:  592:                {
        1:  593:                   CFE_ES_Global.AppStartupCounter--;
        -:  594:                   
        -:  595:                   /*
        -:  596:                   ** Do not actually release the semaphore until the startup file is finished.
        -:  597:                   ** This avoids the problem of the counter going being decremented with each new app
        -:  598:                   ** as opposed to waiting until all of the apps are started
        -:  599:                   */
        1:  600:                   if (( CFE_ES_Global.StartupFileComplete == TRUE ) && ( CFE_ES_Global.AppStartupCounter <= 0 ))
        -:  601:                   {
        1:  602:                      CFE_ES_Global.AppStartupCounter = 0;
        1:  603:                      CFE_ES_Global.StartupSemaphoreReleased = TRUE;
        -:  604:                      
        -:  605:                      /* 
        -:  606:                      ** Release semaphore 
        -:  607:                      */
        1:  608:                      OS_BinSemFlush(CFE_ES_Global.StartupSyncSemaphore); 
        -:  609:
        -:  610:                   }
        -:  611:                   
        -:  612:                } /* End if StartupSemaphoreReleased == FALSE */
        -:  613:                
        -:  614:             } /* End if AppState == CFE_ES_APP_STATE_INITIALIZING */
        -:  615:             
        3:  616:             if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest != CFE_ES_APP_RUN )
        -:  617:             { 
        -:  618:                 /*
        -:  619:                 ** We have an external request to stop
        -:  620:                 */
        1:  621:                 ReturnCode = FALSE;
        -:  622:                 
        -:  623:             }
        -:  624:             else
        -:  625:             {
        -:  626:                /*
        -:  627:                ** Everything is OK
        -:  628:                */
        2:  629:                ReturnCode = TRUE;
        -:  630:             }
        -:  631:          }
        -:  632:          else
        -:  633:          {
        -:  634:             /*
        -:  635:             ** Application wants to exit, so let it
        -:  636:             */
        1:  637:             CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = *RunStatus; 
        1:  638:             ReturnCode = FALSE;
        -:  639:          }
        -:  640:       }
        -:  641:       else 
        -:  642:       {
        -:  643:          /*
        -:  644:          ** Not a supported RunStatus code, the app will abort
        -:  645:          */
        1:  646:          CFE_ES_WriteToSysLog("CFE_ES_RunLoop Error: Invalid RunStatus:%d!\n",*RunStatus);
        1:  647:          CFE_ES_Global.AppTable[AppID].StateRecord.AppControlRequest = CFE_ES_APP_ERROR; 
        1:  648:          ReturnCode = FALSE;
        -:  649:       
        -:  650:       } /* End if *RunStatus == CFE_ES_APP_RUN .. */
        -:  651:   
        -:  652:    }
        -:  653:    else
        -:  654:    {
        -:  655:       /*
        -:  656:       ** Cannot do anything without the AppID
        -:  657:       */
        1:  658:       CFE_ES_WriteToSysLog("CFE_ES_RunLoop Error: Cannot get AppID for the caller: RC = %08X\n",ReturnCode);
        1:  659:       ReturnCode = FALSE;
        -:  660:         
        -:  661:    } /* end if ReturnCode == CFE_SUCCESS */
        -:  662:
        6:  663:    CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  664:
        6:  665:    return(ReturnCode);
        -:  666:
        -:  667:} /* End of CFE_ES_RunLoop() */
        -:  668:
        -:  669:/*
        -:  670:** Function: CFE_ES_WaitForStartupSync
        -:  671:**
        -:  672:** Purpose:  Waits for all of the applications in the CFE startup table to initialize before
        -:  673:**           continuing.
        -:  674:**
        -:  675:*/
        3:  676:void CFE_ES_WaitForStartupSync(uint32 TimeOutMilliseconds)
        -:  677:{
        -:  678:   int32  ReturnCode;
        -:  679:   uint32 AppID;
        -:  680:   
        -:  681:   /*
        -:  682:   ** In order to prevent problems with underlying OS calls, the wait will be a minimum of 1 second.
        -:  683:   ** The wait should never be indefinite, in case an app does not start correctly.
        -:  684:   */
        3:  685:   if ( TimeOutMilliseconds < 1000 )
        -:  686:   {
        3:  687:      TimeOutMilliseconds = 1000;
        -:  688:   }
        -:  689: 
        3:  690:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  691:
        -:  692:   /*
        -:  693:   ** Dont bother waiting if the startup semaphore has been released already
        -:  694:   */
        3:  695:   if ( CFE_ES_Global.StartupSemaphoreReleased == FALSE)
        -:  696:   {
        -:  697:      /*
        -:  698:      ** Get App ID
        -:  699:      */
        2:  700:      ReturnCode = CFE_ES_GetAppIDInternal(&AppID);
        2:  701:      if ( ReturnCode == CFE_SUCCESS )
        -:  702:      {
        2:  703:         if ( CFE_ES_Global.AppTable[AppID].StateRecord.AppState == CFE_ES_APP_STATE_INITIALIZING)
        -:  704:         {
        -:  705:             /* 
        -:  706:             ** Change the state to RUNNING
        -:  707:             ** This will prevent the AppStartupCounter from being decremented again if the wait on the 
        -:  708:             ** semaphore times out. So this code will run in one of two places: This function or the 
        -:  709:             ** first time that the CFE_ES_RunLoop function is called, but it should not run in both for 
        -:  710:             ** an app. If the init code gets more complicated, it should be put in a common function. 
        -:  711:             */
        1:  712:             CFE_ES_Global.AppTable[AppID].StateRecord.AppState = CFE_ES_APP_STATE_RUNNING;
        -:  713:
        -:  714:         }    
        -:  715:
        -:  716:         /*
        -:  717:         ** The counter must be decremented here to properly count the calling app as finishing 
        -:  718:         ** it's initialization.
        -:  719:         */
        2:  720:         CFE_ES_Global.AppStartupCounter--;
        -:  721:
        -:  722:         /*
        -:  723:         ** If the waiting app ends up being the last one, then release the semaphore and dont wait
        -:  724:         */
        3:  725:         if (( CFE_ES_Global.StartupFileComplete == TRUE ) && ( CFE_ES_Global.AppStartupCounter <= 0 ))
        -:  726:         {
        1:  727:             CFE_ES_Global.AppStartupCounter = 0;
        1:  728:             CFE_ES_Global.StartupSemaphoreReleased = TRUE;
        1:  729:             CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  730:
        -:  731:             /* 
        -:  732:             ** Release semaphore 
        -:  733:             */
        1:  734:             OS_BinSemFlush(CFE_ES_Global.StartupSyncSemaphore);  
        -:  735:
        -:  736:         }
        -:  737:         else
        -:  738:         {
        -:  739:             /* 
        -:  740:             ** Wait on the semaphore
        -:  741:             */ 
        1:  742:             CFE_ES_UnlockSharedData(__func__,__LINE__);
        1:  743:             ReturnCode = OS_BinSemTimedWait(CFE_ES_Global.StartupSyncSemaphore, TimeOutMilliseconds);
        -:  744:         }
        -:  745:      }
        -:  746:      else /* GetAppIdInternal fails */
        -:  747:      {
    #####:  748:         CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  749:      }
        -:  750:   }
        -:  751:   else /* Semaphore is already released */
        -:  752:   {
        1:  753:      CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  754:   }
        -:  755:
        3:  756:} /* End of CFE_ES_WaitForStartupSync() */
        -:  757:
        -:  758:
        -:  759:/*
        -:  760:** Function: CFE_ES_RegisterApp
        -:  761:**
        -:  762:** Purpose:  Register a new Application with the cFE. This
        -:  763:**           function must be called in a cFE app before
        -:  764:**           any other cFE function.
        -:  765:**
        -:  766:*/
       12:  767:int32 CFE_ES_RegisterApp(void)
        -:  768:{
       12:  769:   int32 Result = CFE_SUCCESS;
        -:  770:
       12:  771:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  772:
        -:  773:   /*
        -:  774:   ** Register the task 
        -:  775:   */
       12:  776:   Result = OS_TaskRegister();
        -:  777:
       12:  778:   if (Result == OS_SUCCESS)
        -:  779:   {
       10:  780:       Result = CFE_SUCCESS;
        -:  781:   }
        -:  782:   else
        -:  783:   {
        -:  784:       /* 
        -:  785:       ** Cannot create a syslog entry here because it requires the task to 
        -:  786:       ** be registered
        -:  787:       */
        2:  788:       Result = CFE_ES_ERR_APP_REGISTER;
        -:  789:   }
        -:  790:
        -:  791:   /*
        -:  792:   ** Set the default exception environment
        -:  793:   */
       12:  794:   CFE_PSP_SetDefaultExceptionEnvironment();
        -:  795:   
       12:  796:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  797:
       12:  798:   return(Result);
        -:  799:  
        -:  800:
        -:  801:} /* End of CFE_ES_RegisterApp() */
        -:  802:
        -:  803:/*
        -:  804:** Function: CFE_ES_GetAppIDByName
        -:  805:**
        -:  806:** Purpose:  Given a valid App Name, return the 
        -:  807:**           Application ID.
        -:  808:**
        -:  809:*/
       17:  810:int32 CFE_ES_GetAppIDByName(uint32 *AppIdPtr, char *AppName)
        -:  811:{
       17:  812:   int32 Result = CFE_ES_ERR_APPNAME;
        -:  813:   uint32 i;
        -:  814:
       17:  815:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  816:
        -:  817:   /*
        -:  818:   ** Search the ES Application table for an app with a matching name.
        -:  819:   */
      241:  820:   for ( i = 0; i < CFE_ES_MAX_APPLICATIONS; i++ )
        -:  821:   {
      234:  822:      if ( CFE_ES_Global.AppTable[i].RecordUsed == TRUE )
        -:  823:      {
       28:  824:         if ( strncmp(AppName, (char *)CFE_ES_Global.AppTable[i].StartParams.Name, OS_MAX_API_NAME) == 0 )
        -:  825:         {
       10:  826:            *AppIdPtr = (int) i;
       10:  827:            Result = CFE_SUCCESS;
       10:  828:            break;
        -:  829:         }
        -:  830:      }
        -:  831:   } /* end for */
        -:  832:   
       17:  833:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  834:      
       17:  835:   return(Result);
        -:  836:
        -:  837:} /* End of CFE_ES_GetAppIDByName() */
        -:  838:
        -:  839:
        -:  840:/*
        -:  841:** Function: CFE_ES_GetAppID
        -:  842:**
        -:  843:** Purpose:  Return the Caller's cFE Application ID.
        -:  844:**
        -:  845:*/
       15:  846:int32 CFE_ES_GetAppID(uint32 *AppIdPtr)
        -:  847:{
       15:  848:   int32  Result = CFE_ES_ERR_APPID;
        -:  849:   uint32 TaskId;
        -:  850:
       15:  851:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  852:
        -:  853:   /*
        -:  854:   ** Step 1: Get the OS task ID
        -:  855:   */
       15:  856:   TaskId = OS_TaskGetId();
        -:  857:
        -:  858:   /*
        -:  859:   ** Step 2: get the Application ID for the current task
        -:  860:   */
       15:  861:   if ( CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -:  862:   {
       14:  863:      *AppIdPtr = CFE_ES_Global.TaskTable[TaskId].AppId;
       14:  864:      Result = CFE_SUCCESS;
        -:  865:   } /* end if */
        -:  866:   
       15:  867:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  868:      
       15:  869:   return(Result);
        -:  870:
        -:  871:} /* End of CFE_ES_GetAppID() */
        -:  872:
        -:  873:/*
        -:  874:** Function: CFE_ES_GetAppName
        -:  875:**
        -:  876:** Purpose:  Given a valid AppID, return the 
        -:  877:**           Application name string.
        -:  878:**
        -:  879:*/
       16:  880:int32 CFE_ES_GetAppName(char *AppName, uint32 AppId, uint32 BufferLength)
        -:  881:{
        -:  882:   int32 Result;
        -:  883:
       16:  884:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  885:
       16:  886:   if ( AppId < CFE_ES_MAX_APPLICATIONS )
        -:  887:   {
       15:  888:      if ( CFE_ES_Global.AppTable[AppId].RecordUsed == TRUE )
        -:  889:      {
       13:  890:         strncpy(AppName, (char *)CFE_ES_Global.AppTable[AppId].StartParams.Name, BufferLength);
       13:  891:         AppName[BufferLength - 1] = '\0';
       13:  892:         Result = CFE_SUCCESS;
        -:  893:      }
        -:  894:      else
        -:  895:      {
        2:  896:         Result = CFE_ES_ERR_APPID;
        -:  897:      }
        -:  898:   }
        -:  899:   else
        -:  900:   {
        1:  901:      Result = CFE_ES_ERR_APPID;
        -:  902:   }
        -:  903:   
       16:  904:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  905:      
       16:  906:   return(Result);
        -:  907:
        -:  908:} /* End of CFE_ES_GetAppName() */
        -:  909:
        -:  910:
        -:  911:/*
        -:  912:** Function: CFE_ES_GetAppInfo
        -:  913:**
        -:  914:** Purpose:  Get Application Information given a specified App ID
        -:  915:**
        -:  916:*/
        5:  917:int32 CFE_ES_GetAppInfo(CFE_ES_AppInfo_t *AppInfo, uint32 AppId)
        -:  918:{
        5:  919:   int32  ReturnCode = CFE_SUCCESS;
        -:  920:
        5:  921:   if ( AppInfo != 0 )
        -:  922:   {
        4:  923:      if ( AppId < CFE_ES_MAX_APPLICATIONS )
        -:  924:      {
        3:  925:         if ( CFE_ES_Global.AppTable[AppId].RecordUsed == TRUE )
        -:  926:         {
        2:  927:            CFE_ES_GetAppInfoInternal(AppId, AppInfo);
        2:  928:            ReturnCode = CFE_SUCCESS;
        -:  929:         }
        -:  930:         else
        -:  931:         {
        1:  932:            CFE_ES_WriteToSysLog("CFE_ES_GetAppInfo: App ID Not Active: %d\n",AppId);
        1:  933:            ReturnCode = CFE_ES_ERR_APPID;
        -:  934:         }
        -:  935:      }
        -:  936:      else
        -:  937:      {
        1:  938:         CFE_ES_WriteToSysLog("CFE_ES_GetAppInfo: App ID Exceeds CFE_ES_APPLICATION_MAX: %d\n",AppId);
        1:  939:         ReturnCode = CFE_ES_ERR_APPID;
        -:  940:      }
        -:  941:   }
        -:  942:   else
        -:  943:   {
        1:  944:      CFE_ES_WriteToSysLog("CFE_ES_GetAppInfo: Invalid Parameter ( Null Pointer )\n");
        1:  945:      ReturnCode = CFE_ES_ERR_BUFFER;
        -:  946:   }
        5:  947:   return(ReturnCode);
        -:  948:
        -:  949:} /* End of CFE_ES_GetAppInfo() */
        -:  950:
        -:  951:/*
        -:  952:** Function: CFE_ES_GetTaskInfo
        -:  953:**
        -:  954:** Purpose:  Get Task Information given a specified Task ID
        -:  955:**
        -:  956:*/
       10:  957:int32 CFE_ES_GetTaskInfo(CFE_ES_TaskInfo_t *TaskInfo, uint32 TaskId)
        -:  958:{
       10:  959:   int32  ReturnCode = CFE_SUCCESS;
        -:  960:
       10:  961:   CFE_ES_LockSharedData(__func__,__LINE__);
        -:  962:
       10:  963:   if ( TaskId < OS_MAX_TASKS )
        -:  964:   {
        9:  965:      if (  CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -:  966:      {
        -:  967:    
        -:  968:         /*
        -:  969:         ** Get the Application ID and Task Name
        -:  970:         */  
        8:  971:         TaskInfo->AppId = CFE_ES_Global.TaskTable[TaskId].AppId;
        8:  972:         strncpy((char *)TaskInfo->TaskName, 
        -:  973:                 (char *)CFE_ES_Global.TaskTable[TaskId].TaskName,OS_MAX_API_NAME);
        8:  974:         TaskInfo->TaskName[OS_MAX_API_NAME - 1] = '\0';         
        -:  975:         /*
        -:  976:         ** Get the Application Name
        -:  977:         */
        8:  978:         if ( CFE_ES_Global.AppTable[TaskInfo->AppId].RecordUsed == TRUE )
        -:  979:         {
        -:  980:         
        5:  981:            strncpy((char *)TaskInfo->AppName, 
        5:  982:                    (char *)CFE_ES_Global.AppTable[TaskInfo->AppId].StartParams.Name, 
        -:  983:                    OS_MAX_API_NAME);
        5:  984:            TaskInfo->AppName[OS_MAX_API_NAME - 1] = '\0';
        -:  985:            
        -:  986:            /*
        -:  987:            ** Store away the Task ID ( for the QueryAllTasks Cmd )
        -:  988:            */
        5:  989:            TaskInfo->TaskId = TaskId;
        -:  990: 
        -:  991:            
        -:  992:            /*
        -:  993:            ** Get the Execution counter for the task
        -:  994:            */
        5:  995:            TaskInfo->ExecutionCounter =  CFE_ES_Global.TaskTable[TaskId].ExecutionCounter;
        -:  996:                                             
        5:  997:            ReturnCode = CFE_SUCCESS;
        -:  998:         
        -:  999:         }
        -: 1000:         else
        -: 1001:         {
        3: 1002:            CFE_ES_WriteToSysLog("CFE_ES_GetTaskInfo: Task ID:%d Parent App ID:%d not Active.\n",
        -: 1003:               TaskId,TaskInfo->AppId);
        3: 1004:            ReturnCode = CFE_ES_ERR_TASKID;
        -: 1005:         }
        -: 1006:      }
        -: 1007:      else
        -: 1008:      {
        1: 1009:         CFE_ES_WriteToSysLog("CFE_ES_GetTaskInfo: Task ID Not Active: %d\n",TaskId);
        1: 1010:         ReturnCode = CFE_ES_ERR_TASKID;
        -: 1011:      }
        -: 1012:   }
        -: 1013:   else
        -: 1014:   {
        1: 1015:         CFE_ES_WriteToSysLog("CFE_ES_GetTaskInfo: Task ID Exceeds OS MAX: %d\n",TaskId);
        1: 1016:         ReturnCode = CFE_ES_ERR_TASKID;
        -: 1017:   }
        -: 1018:   
       10: 1019:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1020:      
       10: 1021:   return(ReturnCode);
        -: 1022:
        -: 1023:} /* End of CFE_ES_GetAppName() */
        -: 1024:
        -: 1025:
        -: 1026:/*
        -: 1027:** Function: CFE_ES_CreateChildTask
        -: 1028:**
        -: 1029:** Purpose:  Create a Child task for the Application.
        -: 1030:**
        -: 1031:*/
       11: 1032:int32 CFE_ES_CreateChildTask(uint32 *TaskIdPtr,
        -: 1033:                        const char   *TaskName,
        -: 1034:                        CFE_ES_ChildTaskMainFuncPtr_t   FunctionPtr,
        -: 1035:                        const uint32 *StackPtr,
        -: 1036:                        uint32  StackSize,
        -: 1037:                        uint32  Priority,
        -: 1038:                        uint32  Flags)
        -: 1039:{
        -: 1040:
        -: 1041:   int32          Result;
       11: 1042:   uint32         AppId= 0xFFFFFFFF;
        -: 1043:   int32          ReturnCode;
        -: 1044:   int32          TaskId;
        -: 1045:   uint32         ParentTaskId;
        -: 1046:
        -: 1047:   /*
        -: 1048:   ** Validate some of the arguments
        -: 1049:   */
       11: 1050:   if ( TaskIdPtr == NULL )
        -: 1051:   {
        2: 1052:      if (TaskName == NULL)
        -: 1053:      {
        1: 1054:          CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Task Id and Name Pointer Parameters are NULL.\n");
        1: 1055:          ReturnCode = CFE_ES_BAD_ARGUMENT;
        -: 1056:      }
        -: 1057:      else
        -: 1058:      {
        1: 1059:          CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Task Id Pointer Parameter is NULL for Task '%s'.\n",TaskName);
        1: 1060:          ReturnCode = CFE_ES_BAD_ARGUMENT;
        -: 1061:      }
        -: 1062:   }
        9: 1063:   else if ( TaskName == NULL )
        -: 1064:   {
        1: 1065:      CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: TaskName Parameter is NULL for Task ID %d.\n",*TaskIdPtr);
        1: 1066:      ReturnCode = CFE_ES_BAD_ARGUMENT;
        -: 1067:   }
        8: 1068:   else if ( FunctionPtr == NULL )
        -: 1069:   {
        1: 1070:      CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Function Pointer Parameter is NULL for Task '%s' (ID %d).\n",TaskName,*TaskIdPtr);
        1: 1071:      ReturnCode = CFE_ES_BAD_ARGUMENT;
        -: 1072:   }
        -: 1073:   else 
        -: 1074:   {
        -: 1075:   
        7: 1076:      CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1077:   
        -: 1078:      /*
        -: 1079:      ** Get the AppID of the calling Application
        -: 1080:      */
        7: 1081:      Result = CFE_ES_GetAppIDInternal(&AppId);
        7: 1082:      if (Result != CFE_SUCCESS)
        -: 1083:      {
        1: 1084:          CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Error calling CFE_ES_GetAppID for Task '%s'. RC = 0x%08X\n",TaskName,Result);
        1: 1085:          ReturnCode = Result;
        -: 1086:      }
        -: 1087:      else  /* else AppId is valid */
        -: 1088:      {
        -: 1089:         /*
        -: 1090:         ** First, Make sure the Calling Task is a cFE Main task.
        -: 1091:         ** TaskID must be the same as the Parent Task ID.
        -: 1092:         */
        6: 1093:         TaskId = OS_TaskGetId();
        6: 1094:         ParentTaskId = CFE_ES_Global.AppTable[AppId].TaskInfo.MainTaskId;
        6: 1095:         if ( TaskId == ParentTaskId )
        -: 1096:         {
        -: 1097:            /*
        -: 1098:            ** Truncate the priority if needed
        -: 1099:            */                          
        5: 1100:            if ( Priority >  255  )
        -: 1101:            {
        2: 1102:                Priority = 255;
        -: 1103:            }
        -: 1104:
        -: 1105:            /*
        -: 1106:            ** Step 2: Create the new task using the OS API call
        -: 1107:            */
        5: 1108:            Result = OS_TaskCreate(TaskIdPtr, TaskName, FunctionPtr, StackPtr,
        -: 1109:                                StackSize, Priority, OS_FP_ENABLED );
        -: 1110:
        -: 1111:            /*
        -: 1112:            ** Step 3: Record the task information in the task table
        -: 1113:            */
        5: 1114:            if ( Result == OS_SUCCESS )
        -: 1115:            {
        3: 1116:               CFE_ES_Global.TaskTable[*TaskIdPtr].RecordUsed = TRUE;
        3: 1117:               CFE_ES_Global.TaskTable[*TaskIdPtr].AppId = AppId;
        3: 1118:               CFE_ES_Global.TaskTable[*TaskIdPtr].TaskId = *TaskIdPtr;
        3: 1119:               strncpy((char *)CFE_ES_Global.TaskTable[*TaskIdPtr].TaskName,TaskName,OS_MAX_API_NAME);
        3: 1120:               CFE_ES_Global.TaskTable[*TaskIdPtr].TaskName[OS_MAX_API_NAME - 1] = '\0';
        3: 1121:               CFE_ES_Global.RegisteredTasks++;
        -: 1122:
        -: 1123:               /*
        -: 1124:               ** Increment the "Registered" child task count for the App
        -: 1125:               */
        3: 1126:               CFE_ES_Global.AppTable[AppId].TaskInfo.NumOfChildTasks ++;
        -: 1127:
        3: 1128:               ReturnCode = CFE_SUCCESS;
        -: 1129:            }
        -: 1130:            else
        -: 1131:            {
        2: 1132:               CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Error calling OS_TaskCreate for Task '%s' RC = 0x%08X\n",TaskName,Result);
        2: 1133:               ReturnCode = CFE_ES_ERR_CHILD_TASK_CREATE;
        -: 1134:            }
        -: 1135:         } 
        -: 1136:         else
        -: 1137:         {
        1: 1138:            CFE_ES_WriteToSysLog("CFE_ES_CreateChildTask: Error: Cannot call from a Child Task (for Task '%s').\n",TaskName);
        1: 1139:            ReturnCode = CFE_ES_ERR_CHILD_TASK_CREATE;
        -: 1140:         
        -: 1141:         } /* end if Calling task is a main task */
        -: 1142:         
        -: 1143:      }/* end If AppID is valid */
        -: 1144:      
        7: 1145:      CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1146:
        -: 1147:   } /* end if parameter checking */
        -: 1148:   
       11: 1149:   return(ReturnCode);
        -: 1150:
        -: 1151:} /* End of CFE_ES_CreateChildTask() */
        -: 1152:
        -: 1153:
        -: 1154:/*
        -: 1155:** Function: CFE_ES_RegisterChildTask
        -: 1156:**
        -: 1157:** Purpose:  Register a child task. This must be called by a Child Task before any
        -: 1158:**           other cFE calls.
        -: 1159:**
        -: 1160:*/
        4: 1161:int32 CFE_ES_RegisterChildTask(void)
        -: 1162:{
        -: 1163:   int32 Result;
        -: 1164:   int32 ReturnCode;
        -: 1165:
        4: 1166:   CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1167:
        -: 1168:   /*
        -: 1169:   ** Register the task with the OS 
        -: 1170:   */
        4: 1171:   Result = OS_TaskRegister();
        -: 1172:
        4: 1173:   if (Result != OS_SUCCESS)
        -: 1174:   {
        -: 1175:       /* 
        -: 1176:       ** Cannot create a syslog entry here because it requires the task to 
        -: 1177:       ** be registered
        -: 1178:       */
        1: 1179:       ReturnCode = CFE_ES_ERR_CHILD_TASK_REGISTER;
        -: 1180:   }
        -: 1181:   else
        -: 1182:   { 
        3: 1183:       ReturnCode = CFE_SUCCESS;
        -: 1184:   }
        -: 1185:   
        -: 1186:   /*
        -: 1187:   ** Set the default exception environment
        -: 1188:   */
        4: 1189:   CFE_PSP_SetDefaultExceptionEnvironment();
        -: 1190:
        4: 1191:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1192:
        4: 1193:   return(ReturnCode);
        -: 1194:
        -: 1195:} /* End of CFE_ES_RegisterChildTask() */
        -: 1196:
        -: 1197:/*
        -: 1198:** Function: CFE_ES_IncrementTaskCounter
        -: 1199:**
        -: 1200:** Purpose:  Increment the Child Task Execution Counter.
        -: 1201:**
        -: 1202:*/
        3: 1203:void CFE_ES_IncrementTaskCounter(void)
        -: 1204:{
        -: 1205:   int32 TaskId;
        -: 1206:
        3: 1207:   TaskId = OS_TaskGetId();
        -: 1208:   
        3: 1209:   CFE_ES_Global.TaskTable[TaskId].ExecutionCounter++;
        -: 1210:   
        3: 1211:} /* End of CFE_ES_ExitChildTask() */
        -: 1212:
        -: 1213:
        -: 1214:
        -: 1215:/*
        -: 1216:** Function: CFE_ES_DeleteChildTask
        -: 1217:**
        -: 1218:** Purpose:  Remove a Child Task from the cFE system.
        -: 1219:**
        -: 1220:*/
        5: 1221:int32 CFE_ES_DeleteChildTask(uint32 TaskId)
        -: 1222:{
        -: 1223:    uint32  i;
        5: 1224:    uint32  TaskIsMain = FALSE;
        5: 1225:    int32   ReturnCode = CFE_SUCCESS;
        -: 1226:    int32   OSReturnCode;
        -: 1227:
        -: 1228:
        -: 1229:    /*
        -: 1230:    ** Make sure the task ID is within range
        -: 1231:    */
        5: 1232:    if ( TaskId < OS_MAX_TASKS )
        -: 1233:    {
        -: 1234:    
        4: 1235:       CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1236:    
        -: 1237:       /*
        -: 1238:       ** Make sure the task is active/valid
        -: 1239:       */
        4: 1240:       if ( CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -: 1241:       {
        -: 1242:          /*
        -: 1243:          ** Search for this task ID in the ES App Table to make sure
        -: 1244:          ** it is not a cFE App Main Task
        -: 1245:          */
        3: 1246:          TaskIsMain = FALSE;
       68: 1247:          for ( i = 0; i < CFE_ES_MAX_APPLICATIONS; i++ )
        -: 1248:          {
       66: 1249:             if ( CFE_ES_Global.AppTable[i].RecordUsed == TRUE )
        -: 1250:             {
        7: 1251:                if ( CFE_ES_Global.AppTable[i].TaskInfo.MainTaskId == TaskId )
        -: 1252:                {
        -: 1253:                   /*
        -: 1254:                   ** Error, the task Id is an App Main Task ID
        -: 1255:                   */
        1: 1256:                   TaskIsMain = TRUE;
        1: 1257:                   break; 
        -: 1258:                } /* end if */
        -: 1259:             } /* end if */
        -: 1260:          } /* end for */
        -: 1261:          
        3: 1262:          if ( TaskIsMain == FALSE )
        -: 1263:          {
        -: 1264:             /*
        -: 1265:             ** Can delete the Task
        -: 1266:             */
        2: 1267:             OSReturnCode = OS_TaskDelete(TaskId);
        2: 1268:             if ( OSReturnCode == OS_SUCCESS )
        -: 1269:             {
        -: 1270:                /*
        -: 1271:                ** Invalidate the task table entry
        -: 1272:                */
        1: 1273:                CFE_ES_Global.TaskTable[TaskId].RecordUsed = FALSE;
        1: 1274:                CFE_ES_Global.RegisteredTasks--;
        -: 1275:
        -: 1276:                /*
        -: 1277:                ** Report the task delete
        -: 1278:                */
        1: 1279:                CFE_ES_WriteToSysLog("CFE_ES_DeleteChildTask Task %d Deleted\n",TaskId );
        1: 1280:                ReturnCode = CFE_SUCCESS;
        -: 1281:             }
        -: 1282:             else
        -: 1283:             {
        1: 1284:                CFE_ES_WriteToSysLog("CFE_ES_DeleteChildTask Error: Error Calling OS_TaskDelete: Task %d, RC = 0x%08X\n",
        -: 1285:                                     TaskId, OSReturnCode);
        1: 1286:                ReturnCode = CFE_ES_ERR_CHILD_TASK_DELETE;
        -: 1287:             }
        -: 1288:          }
        -: 1289:          else
        -: 1290:          {
        -: 1291:             /*
        -: 1292:             ** Error: The task is a cFE Application Main task
        -: 1293:             */
        1: 1294:             CFE_ES_WriteToSysLog("CFE_ES_DeleteChildTask Error: Task %d is a cFE Main Task.\n",TaskId );
        1: 1295:             ReturnCode = CFE_ES_ERR_CHILD_TASK_DELETE_MAIN_TASK;
        -: 1296:          } /* end if TaskMain == FALSE */
        -: 1297:       }
        -: 1298:       else
        -: 1299:       {
        -: 1300:          /*
        -: 1301:          ** Task ID is not in use, so it is invalid
        -: 1302:          */
        1: 1303:          CFE_ES_WriteToSysLog("CFE_ES_DeleteChildTask Error: Task ID is not active: %d\n",TaskId );
        1: 1304:          ReturnCode = CFE_ES_ERR_TASKID;
        -: 1305:   
        -: 1306:       } /* end if */
        -: 1307:       
        4: 1308:       CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1309:   
        -: 1310:    }
        -: 1311:    else
        -: 1312:    {
        -: 1313:       /*
        -: 1314:       ** Task ID is invalid ( too large )
        -: 1315:       */
        1: 1316:       CFE_ES_WriteToSysLog("CFE_ES_DeleteChildTask Error: Invalid Task ID: %d\n",TaskId );
        1: 1317:       ReturnCode = CFE_ES_ERR_TASKID;
        -: 1318:       
        -: 1319:    }
        5: 1320:    return(ReturnCode);
        -: 1321:
        -: 1322:} /* End of CFE_ES_DeleteTask() */
        -: 1323:
        -: 1324:/*
        -: 1325:** Function: CFE_ES_ExitChildTask
        -: 1326:**
        -: 1327:** Purpose:  Stop execution of a child task.
        -: 1328:**
        -: 1329:*/
       14: 1330:void CFE_ES_ExitChildTask(void)
        -: 1331:{
        -: 1332:   int32 TaskId;
        -: 1333:   uint32 ParentTaskId;
        -: 1334:   uint32 AppId; 
        -: 1335:   uint32 ReturnCode;
        -: 1336:
       14: 1337:   CFE_ES_LockSharedData(__func__,__LINE__);
        -: 1338:
        -: 1339:   /*
        -: 1340:   ** Check to see if this is being called from a cFE Application's 
        -: 1341:   ** main task.
        -: 1342:   */
       14: 1343:   TaskId = OS_TaskGetId();
        -: 1344:   
       14: 1345:   ReturnCode = CFE_ES_GetAppIDInternal(&AppId);
       14: 1346:   if ( ReturnCode == CFE_SUCCESS )
        -: 1347:   {
       13: 1348:      ParentTaskId = CFE_ES_Global.AppTable[AppId].TaskInfo.MainTaskId;
       13: 1349:      if ( TaskId != ParentTaskId )
        -: 1350:      {
        -: 1351:         /*
        -: 1352:         ** Invalidate the task table entry
        -: 1353:         */
        1: 1354:         CFE_ES_Global.TaskTable[TaskId].RecordUsed = FALSE;
        1: 1355:         CFE_ES_Global.RegisteredTasks--;
        -: 1356:
        -: 1357:
        1: 1358:         CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1359:
        -: 1360:         
        -: 1361:         /*
        -: 1362:         ** Call the OS AL routine
        -: 1363:         */
        1: 1364:         OS_TaskExit(); 
        -: 1365:         
        -: 1366:         /* 
        -: 1367:         ** Does not return from OS_TaskExit 
        -: 1368:         */
        -: 1369:      }
        -: 1370:      else
        -: 1371:      {
       12: 1372:         CFE_ES_WriteToSysLog("CFE_ES_ExitChildTask Error: Cannot Call from a cFE App Main Task. ID = %d\n",TaskId );
        -: 1373:      }
        -: 1374:   }
        -: 1375:   else
        -: 1376:   {   
        1: 1377:      CFE_ES_WriteToSysLog("CFE_ES_ExitChildTask Error Calling CFE_ES_GetAppID. Task ID = %d, RC = 0x%08X\n",
        -: 1378:                           TaskId, ReturnCode );
        -: 1379:   } /* end if GetAppId */
        -: 1380:
       14: 1381:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -: 1382:   
       14: 1383:} /* End of CFE_ES_ExitChildTask() */
        -: 1384:
        -: 1385:
        -: 1386:/*
        -: 1387:** Function: CFE_ES_WriteToSysLog
        -: 1388:**
        -: 1389:** Purpose:  Add a time stamped message to the cFE ES System Log.
        -: 1390:**
        -: 1391:*/
      592: 1392:int32 CFE_ES_WriteToSysLog(const char *SpecStringPtr, ...)
        -: 1393:{
        -: 1394:    va_list       ArgPtr;
        -: 1395:    char          TmpString[CFE_ES_MAX_SYSLOG_MSG_SIZE];
        -: 1396:    char          MsgWithoutTime[CFE_EVS_MAX_MESSAGE_LENGTH];
        -: 1397:    int32         TmpStringLen;
        -: 1398:    int32         LogOverflow;
        -: 1399:    int32         TruncTmpStringLen;
        -: 1400:    uint32        ReturnCode;
        -: 1401:    int32         i;
        -: 1402:
        -: 1403:    /* write the current time into the TmpString buffer */
      592: 1404:    CFE_TIME_Print(TmpString, CFE_TIME_GetTime());
        -: 1405:
      592: 1406:    va_start(ArgPtr, SpecStringPtr);
      592: 1407:    (void) vsnprintf(MsgWithoutTime,(size_t) CFE_EVS_MAX_MESSAGE_LENGTH, SpecStringPtr, ArgPtr);
      592: 1408:    va_end(ArgPtr);
        -: 1409:
        -: 1410:    /* insert space between the time and the start of the message */
      592: 1411:    strcat(TmpString," ");
        -: 1412:
        -: 1413:    /* Add the message to the time string in the TmpString buffer */
      592: 1414:    strncat(TmpString,MsgWithoutTime,CFE_EVS_MAX_MESSAGE_LENGTH);
        -: 1415:   
        -: 1416:    /* Output the entry to the console. */
      592: 1417:    OS_printf("%s",TmpString);
      592: 1418:    TmpStringLen = strlen(TmpString);
        -: 1419:
        -: 1420:    /* process the log entry depending on the log type */
      592: 1421:    if ( CFE_ES_ResetDataPtr->SystemLogMode == CFE_ES_LOG_DISCARD )
        -: 1422:    {
        -: 1423:        /* if the index is already out of bounds, the log is full */
      100: 1424:        if ( CFE_ES_ResetDataPtr->SystemLogIndex >= CFE_ES_SYSTEM_LOG_SIZE )  
        -: 1425:        {
       77: 1426:            OS_printf("Warning: System Log full, log entry discarded.\n");
       77: 1427:            ReturnCode = CFE_ES_ERR_SYS_LOG_FULL;
        -: 1428:        }   
        -: 1429:        /* if the message will not fit in the remaining space, truncate it */  
       23: 1430:        else if ((CFE_ES_ResetDataPtr->SystemLogIndex + TmpStringLen) >= CFE_ES_SYSTEM_LOG_SIZE )
        -: 1431:        {
        2: 1432:            LogOverflow = CFE_ES_ResetDataPtr->SystemLogIndex + TmpStringLen - CFE_ES_SYSTEM_LOG_SIZE;
        -: 1433:
        -: 1434:            /* Add one for adding '/0' to the end because the message will be truncated */
        2: 1435:            LogOverflow++;
        -: 1436:
        2: 1437:            TruncTmpStringLen = TmpStringLen - LogOverflow;
        -: 1438:
        2: 1439:            strncpy((char *)&(CFE_ES_ResetDataPtr->SystemLog[CFE_ES_ResetDataPtr->SystemLogIndex]), TmpString, TruncTmpStringLen);
        2: 1440:            strncpy((char *)&(CFE_ES_ResetDataPtr->SystemLog[CFE_ES_ResetDataPtr->SystemLogIndex + TruncTmpStringLen]), "\0", 1 );
        -: 1441:
        2: 1442:            CFE_ES_ResetDataPtr->SystemLogIndex = CFE_ES_ResetDataPtr->SystemLogIndex + TruncTmpStringLen + 1;
        2: 1443:            CFE_ES_ResetDataPtr->SystemLogEntryNum = CFE_ES_ResetDataPtr->SystemLogEntryNum + 1;
        2: 1444:            OS_printf("Warning: Last System Log Message Truncated.\n");
        2: 1445:            ReturnCode = CFE_SUCCESS;
        -: 1446:        } 
        -: 1447:        else /* the message fits */
        -: 1448:        {
       21: 1449:            TmpStringLen = strlen(TmpString);
       21: 1450:            strncpy((char *)&(CFE_ES_ResetDataPtr->SystemLog[CFE_ES_ResetDataPtr->SystemLogIndex]), TmpString, TmpStringLen);
       21: 1451:            CFE_ES_ResetDataPtr->SystemLogIndex = CFE_ES_ResetDataPtr->SystemLogIndex + TmpStringLen;
       21: 1452:            CFE_ES_ResetDataPtr->SystemLogEntryNum = CFE_ES_ResetDataPtr->SystemLogEntryNum + 1;
       21: 1453:            ReturnCode = CFE_SUCCESS;
        -: 1454:        }
        -: 1455:    }
      492: 1456:    else if ( CFE_ES_ResetDataPtr->SystemLogMode == CFE_ES_LOG_OVERWRITE )
        -: 1457:    {
        -: 1458:        /* if the index is already out of bounds, reset it to zero */
      492: 1459:        if ( CFE_ES_ResetDataPtr->SystemLogIndex >= CFE_ES_SYSTEM_LOG_SIZE )  
        -: 1460:        {
    #####: 1461:           CFE_ES_ResetDataPtr->SystemLogIndex = 0;
        -: 1462:        }
        -: 1463:        /* the message will not fit in the remaining space */
      492: 1464:        else if ((CFE_ES_ResetDataPtr->SystemLogIndex + TmpStringLen) >= CFE_ES_SYSTEM_LOG_SIZE)  
        -: 1465:        {
        -: 1466:            /* pad the space at the end of the log to remove any partial old messages */
     1261: 1467:            for (i = CFE_ES_ResetDataPtr->SystemLogIndex; i < CFE_ES_SYSTEM_LOG_SIZE; i++)
        -: 1468:            {
     1238: 1469:                CFE_ES_ResetDataPtr->SystemLog[i] = ' ';
        -: 1470:            }
       23: 1471:            CFE_ES_ResetDataPtr->SystemLogIndex = 0;
        -: 1472:        }
        -: 1473:
      492: 1474:        TmpStringLen = strlen(TmpString);
      492: 1475:        strncpy((char *)&(CFE_ES_ResetDataPtr->SystemLog[CFE_ES_ResetDataPtr->SystemLogIndex]), TmpString, TmpStringLen);
      492: 1476:        CFE_ES_ResetDataPtr->SystemLogIndex = CFE_ES_ResetDataPtr->SystemLogIndex + TmpStringLen;
      492: 1477:        CFE_ES_ResetDataPtr->SystemLogEntryNum = CFE_ES_ResetDataPtr->SystemLogEntryNum + 1;
      492: 1478:        ReturnCode = CFE_SUCCESS;
        -: 1479:    }
        -: 1480:    else
        -: 1481:    {
    #####: 1482:        OS_printf("Warning: Invalid System Log mode, log entry discarded.\n");
    #####: 1483:        ReturnCode = CFE_ES_ERR_SYS_LOG_FULL;
        -: 1484:    }    
        -: 1485:
      592: 1486:    return(ReturnCode);
        -: 1487:
        -: 1488:} /* End of CFE_ES_WriteToSysLog() */
        -: 1489:
        -: 1490:/*
        -: 1491:** Function: CFE_ES_RegisterDriver
        -: 1492:**
        -: 1493:** Purpose:  Initialize a cFE device driver.
        -: 1494:**
        -: 1495:*/
        1: 1496:int32 CFE_ES_RegisterDriver(uint32 *DriverIdPtr, CFE_ES_DeviceDriver_t *DriverPtr)
        -: 1497:{
        1: 1498:   CFE_ES_WriteToSysLog("CFE ES Register Driver not Implemented\n");
        1: 1499:   return(CFE_ES_NOT_IMPLEMENTED);
        -: 1500:
        -: 1501:} /* End of CFE_ES_RegisterDriver() */
        -: 1502:
        -: 1503:
        -: 1504:/*
        -: 1505:** Function: CFE_ES_UnloadDriver
        -: 1506:**
        -: 1507:** Purpose:  Unload a cFE device driver.
        -: 1508:**
        -: 1509:*/
        1: 1510:int32 CFE_ES_UnloadDriver(uint32 DriverId)
        -: 1511:{
        1: 1512:    CFE_ES_WriteToSysLog("CFE ES Unload Driver not Implemented\n");
        1: 1513:    return(CFE_ES_NOT_IMPLEMENTED);
        -: 1514:
        -: 1515:} /* End of CFE_ES_UnloadDriver() */
        -: 1516:
        -: 1517:
        -: 1518:/*
        -: 1519:** Function: CFE_ES_CalculateCRC
        -: 1520:**
        -: 1521:** Purpose:  Perform a CRC calculation on a range of memory.
        -: 1522:**
        -: 1523:*/
       12: 1524:uint32 CFE_ES_CalculateCRC(void *DataPtr, uint32 DataLength, uint32 InputCRC, uint32 TypeCRC)
        -: 1525:{
        -: 1526:    uint32  i;
        -: 1527:    int16  Index;
       12: 1528:    int16  Crc = 0;
        -: 1529:    uint8 *BufPtr;
        -: 1530:    uint8  ByteValue;
        -: 1531:    int32  Status;
        -: 1532:
        -: 1533:    static const uint16 CrcTable[256]=
        -: 1534:    {
        -: 1535:
        -: 1536:		    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
        -: 1537:		    0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
        -: 1538:		    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
        -: 1539:		    0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
        -: 1540:		    0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
        -: 1541:		    0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
        -: 1542:		    0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
        -: 1543:		    0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
        -: 1544:		    0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
        -: 1545:		    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
        -: 1546:		    0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
        -: 1547:		    0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
        -: 1548:		    0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
        -: 1549:		    0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
        -: 1550:		    0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
        -: 1551:		    0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
        -: 1552:		    0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
        -: 1553:		    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
        -: 1554:		    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
        -: 1555:		    0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
        -: 1556:		    0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
        -: 1557:		    0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
        -: 1558:		    0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
        -: 1559:		    0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
        -: 1560:		    0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
        -: 1561:		    0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
        -: 1562:		    0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
        -: 1563:		    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
        -: 1564:		    0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
        -: 1565:		    0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
        -: 1566:		    0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
        -: 1567:		    0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
        -: 1568:
        -: 1569:    };
        -: 1570:
       12: 1571:    switch(TypeCRC)
        -: 1572:    {
        -: 1573:      case CFE_ES_CRC_32:
        1: 1574:           CFE_ES_WriteToSysLog("CFE ES Calculate CRC32 not Implemented\n");
        1: 1575:           break;
        -: 1576:
        -: 1577:      case CFE_ES_CRC_16:
       10: 1578:           Crc    =  (int16 )( 0xFFFF & InputCRC );
       10: 1579:           BufPtr = (uint8 *)DataPtr;
        -: 1580:
     2446: 1581:           for ( i = 0 ; i < DataLength ; i++,  BufPtr++)
        -: 1582:	        {
     2436: 1583:                  Status = CFE_PSP_MemRead8((uint32)BufPtr, &ByteValue);
     2436: 1584:	          Index = ( ( Crc ^ ByteValue) & 0x00FF);
     2436: 1585:	          Crc = ( (Crc >> 8 ) & 0x00FF) ^ CrcTable[Index];
        -: 1586:	        }
       10: 1587:           break;
        -: 1588:
        -: 1589:      case CFE_ES_CRC_8:
        1: 1590:           CFE_ES_WriteToSysLog("CFE ES Calculate CRC8 not Implemented\n");
        -: 1591:           break;
        -: 1592:
        -: 1593:      default:
        -: 1594:           break;
        -: 1595:    }
       12: 1596:    return(Crc);
        -: 1597:
        -: 1598:} /* End of CFE_ES_CalculateCRC() */
        -: 1599:
        -: 1600:
        -: 1601:/*
        -: 1602:** Function: CFE_ES_RegisterCDS
        -: 1603:**
        -: 1604:** Purpose:  Allocate a data block for a Critical Data Store.
        -: 1605:**
        -: 1606:*/
       10: 1607:int32 CFE_ES_RegisterCDS(CFE_ES_CDSHandle_t *CDSHandlePtr, int32 BlockSize, const char *Name)
        -: 1608:{
       10: 1609:    int32   Status = CFE_SUCCESS;
       10: 1610:    int32   NameLen = 0;
       10: 1611:    uint32  ThisAppId = 0;
        -: 1612:    
       10: 1613:    char    AppName[OS_MAX_API_NAME] = {"UNKNOWN"};
        -: 1614:    char    LogMsg[128];
       10: 1615:    char    CDSName[CFE_ES_CDS_MAX_FULL_NAME_LEN] = {""};
        -: 1616:
        -: 1617:    /* Check to make sure calling application is legit */
       10: 1618:    Status = CFE_ES_CDS_ValidateAppID(&ThisAppId);
        -: 1619:    
       10: 1620:    if ( Status != CFE_SUCCESS )  /* Application ID was invalid */
        -: 1621:    {
        1: 1622:         CFE_ES_WriteToSysLog("CFE_CDS:Register-Bad AppId(%d)\n", ThisAppId);
        -: 1623:    }
        9: 1624:    else if (CFE_ES_Global.CDSVars.MemPoolSize == 0)
        -: 1625:    {
        1: 1626:        CFE_ES_WriteToSysLog("CFE_CDS:Register-CDS not available\n");
        1: 1627:        Status = CFE_ES_NOT_IMPLEMENTED;
        -: 1628:    }
        -: 1629:    else
        -: 1630:    {
        -: 1631:        /* Assume we can't make a CDS and return a bad handle for now */
        8: 1632:        *CDSHandlePtr = CFE_ES_CDS_BAD_HANDLE;
        -: 1633:
        -: 1634:        /* Make sure specified CDS name is not too long or too short */
        8: 1635:        NameLen = strlen(Name);
        9: 1636:        if ((NameLen > CFE_ES_CDS_MAX_NAME_LENGTH) || (NameLen == 0))
        -: 1637:        {
        1: 1638:           Status = CFE_ES_CDS_INVALID_NAME;
        -: 1639:
        -: 1640:           /* Perform a buffer overrun safe copy of name for debug log message */
        1: 1641:           strncpy(LogMsg, "CFE_CDS:Register-CDS Name (", 27);
        1: 1642:           strncpy(&LogMsg[27], Name, 72);
        1: 1643:           strcat(LogMsg, ") is too long\n");
        1: 1644:           CFE_ES_WriteToSysLog(LogMsg);
        -: 1645:
        1: 1646:           strncpy(CDSName, Name, CFE_ES_CDS_MAX_NAME_LENGTH);
        1: 1647:           CDSName[CFE_ES_CDS_MAX_NAME_LENGTH-1] = '\0';
        -: 1648:        }
        -: 1649:        else
        -: 1650:        {
        -: 1651:           /* Modify specified name to be processor specific name */
        -: 1652:           /* of the form "AppName.Name"                          */
        7: 1653:           CFE_ES_FormCDSName(CDSName, Name, ThisAppId);
        -: 1654:
        -: 1655:           /* Make sure the specified size is acceptable */
        7: 1656:           if (BlockSize == 0)
        -: 1657:           {
        1: 1658:              Status = CFE_ES_CDS_INVALID_SIZE;
        1: 1659:              CFE_ES_WriteToSysLog("CFE_CDS:Register-CDS %s has size of zero\n", Name);
        -: 1660:           }
        -: 1661:           else
        -: 1662:           {
        -: 1663:              /* Create CDS and designate it as NOT being a Critical Table */
        6: 1664:              Status = CFE_ES_RegisterCDSEx(CDSHandlePtr, BlockSize, CDSName, FALSE);
        -: 1665:           }
        -: 1666:        }
        -: 1667:    }
        -: 1668:
        -: 1669:    /* On Error conditions, notify ground of screw up */
       10: 1670:    if (Status < 0)
        -: 1671:    {
        -: 1672:        /* Translate AppID of caller into App Name */
        6: 1673:        CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -: 1674:
        6: 1675:        CFE_EVS_SendEventWithAppID(CFE_ES_CDS_REGISTER_ERR_EID,
        -: 1676:                                   CFE_EVS_ERROR,
        -: 1677:                                   ThisAppId,
        -: 1678:                                   "%s Failed to Register CDS '%s', Status=0x%08X",
        -: 1679:                                   AppName, Name, Status);
        -: 1680:    }
        -: 1681:    
       10: 1682:    return Status;
        -: 1683:} /* End of CFE_ES_RegisterCDS */
        -: 1684:
        -: 1685:/*
        -: 1686:** Function: CFE_ES_CopyToCDS
        -: 1687:**
        -: 1688:** Purpose:  Copies a data block to a Critical Data Store.
        -: 1689:**
        -: 1690:*/
        1: 1691:int32 CFE_ES_CopyToCDS(CFE_ES_CDSHandle_t Handle, void *DataToCopy)
        -: 1692:{
        1: 1693:    int32 Status = CFE_SUCCESS;
        -: 1694:    
        1: 1695:    Status = CFE_ES_CDSBlockWrite(CFE_ES_Global.CDSVars.Registry[Handle].MemHandle, DataToCopy);
        -: 1696:    
        1: 1697:    return Status;
        -: 1698:} /* End of CFE_ES_CopyToCDS() */
        -: 1699:
        -: 1700:/*
        -: 1701:** Function: CFE_ES_RestoreFromCDS
        -: 1702:**
        -: 1703:** Purpose:  Restores a data block from a Critical Data Store.
        -: 1704:**
        -: 1705:*/
        1: 1706:int32 CFE_ES_RestoreFromCDS(void *RestoreToMemory, CFE_ES_CDSHandle_t Handle)
        -: 1707:{
        1: 1708:    int32 Status = CFE_SUCCESS;
        -: 1709:    
        1: 1710:    Status = CFE_ES_CDSBlockRead(RestoreToMemory, CFE_ES_Global.CDSVars.Registry[Handle].MemHandle);
        -: 1711:    
        1: 1712:    return Status;
        -: 1713:} /* End of CFE_ES_RestoreFromCDS() */
        -: 1714:
        -: 1715:/* end of file */
        -: 1716:
        -: 1717:
       11: 1718:int32 CFE_ES_RegisterGenCounter(uint32 *CounterIdPtr, char *CounterName)
        -: 1719:{
       11: 1720:   int32 ReturnCode = CFE_ES_BAD_ARGUMENT;
        -: 1721:   uint32 CheckPtr;
        -: 1722:   int32 Status;
        -: 1723:   uint32 i;
        -: 1724:
       11: 1725:   Status = CFE_ES_GetGenCounterIDByName(&CheckPtr, CounterName);
        -: 1726:
       11: 1727:   if ((CounterIdPtr != NULL) && (CounterName != NULL) && (Status != CFE_SUCCESS))
        -: 1728:   {
       50: 1729:      for ( i = 0; i < CFE_ES_MAX_GEN_COUNTERS; i++ )
        -: 1730:      {
       49: 1731:         if ( CFE_ES_Global.CounterTable[i].RecordUsed == FALSE )
        -: 1732:         {
        9: 1733:            strncpy((char *)CFE_ES_Global.CounterTable[i].CounterName,CounterName,OS_MAX_API_NAME);
        -: 1734:
        9: 1735:            CFE_ES_Global.CounterTable[i].RecordUsed = TRUE;
        9: 1736:            CFE_ES_Global.CounterTable[i].Counter = 0;
        9: 1737:            *CounterIdPtr = i;
        9: 1738:            break;
        -: 1739:         }
        -: 1740:      }
       10: 1741:      if (i < CFE_ES_MAX_GEN_COUNTERS)
        -: 1742:      {
        9: 1743:         ReturnCode = CFE_SUCCESS;
        -: 1744:      }
        -: 1745:   }
        -: 1746:
       11: 1747:   return ReturnCode;
        -: 1748:
        -: 1749:}
        -: 1750:
        -: 1751:/*
        -: 1752:** Function: CFE_ES_DeleteGenCounter
        -: 1753:**
        -: 1754:** Purpose:  Delete a Generic Counter.
        -: 1755:**
        -: 1756:*/
        2: 1757:int32 CFE_ES_DeleteGenCounter(uint32 CounterId)
        -: 1758:{
        -: 1759:
        2: 1760:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1761:
        2: 1762:   if(CounterId < CFE_ES_MAX_GEN_COUNTERS) 
        -: 1763:   {
        1: 1764:      CFE_ES_Global.CounterTable[CounterId].RecordUsed = FALSE;
        1: 1765:      CFE_ES_Global.CounterTable[CounterId].Counter = 0;
        1: 1766:      Status = CFE_SUCCESS;
        -: 1767:   }
        -: 1768:
        2: 1769:   return Status;
        -: 1770:
        -: 1771:} /* End of CFE_ES_DeleteGenCounter() */
        -: 1772:
        -: 1773:/*
        -: 1774:** Function: CFE_ES_IncrementGenCounter
        -: 1775:**
        -: 1776:** Purpose:  Increment a Generic Counter.
        -: 1777:**
        -: 1778:*/
        2: 1779:int32 CFE_ES_IncrementGenCounter(uint32 CounterId)
        -: 1780:{
        2: 1781:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1782:
        3: 1783:   if((CounterId < CFE_ES_MAX_GEN_COUNTERS) &&
        1: 1784:      (CFE_ES_Global.CounterTable[CounterId].RecordUsed == TRUE))
        -: 1785:   {
        1: 1786:      CFE_ES_Global.CounterTable[CounterId].Counter++;
        1: 1787:      Status = CFE_SUCCESS;
        -: 1788:   }
        2: 1789:   return Status;
        -: 1790:   
        -: 1791:} /* End of CFE_ES_IncrementGenCounter() */
        -: 1792:
        -: 1793:/*
        -: 1794:** Function: CFE_ES_SetGenCount
        -: 1795:**
        -: 1796:** Purpose:  Sets a Generic Counter's count.
        -: 1797:**
        -: 1798:*/
        2: 1799:int32 CFE_ES_SetGenCount(uint32 CounterId, uint32 Count)
        -: 1800:{
        2: 1801:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1802:
        3: 1803:   if((CounterId < CFE_ES_MAX_GEN_COUNTERS) &&
        1: 1804:      (CFE_ES_Global.CounterTable[CounterId].RecordUsed == TRUE))
        -: 1805:   {
        1: 1806:      CFE_ES_Global.CounterTable[CounterId].Counter = Count;
        1: 1807:      Status = CFE_SUCCESS;
        -: 1808:   }
        2: 1809:   return Status;
        -: 1810:} /* End of CFE_ES_SetGenCount() */
        -: 1811:
        -: 1812:/*
        -: 1813:** Function: CFE_ES_GetGenCount
        -: 1814:**
        -: 1815:** Purpose:  Gets the value of a Generic Counter.
        -: 1816:**
        -: 1817:*/
        3: 1818:int32 CFE_ES_GetGenCount(uint32 CounterId, uint32 *Count)
        -: 1819:{
        3: 1820:   int32 Status = CFE_ES_BAD_ARGUMENT;
        -: 1821:
        5: 1822:   if((CounterId < CFE_ES_MAX_GEN_COUNTERS) &&
        2: 1823:      (CFE_ES_Global.CounterTable[CounterId].RecordUsed == TRUE) &&
        -: 1824:      (Count != NULL ))
        -: 1825:   {
        2: 1826:      *Count = CFE_ES_Global.CounterTable[CounterId].Counter;
        2: 1827:      Status = CFE_SUCCESS;
        -: 1828:   }
        3: 1829:   return Status;
        -: 1830:} /* End of CFE_ES_GetGenCount() */
        -: 1831:
       13: 1832:int32 CFE_ES_GetGenCounterIDByName(uint32 *CounterIdPtr, char *CounterName)
        -: 1833:{
        -: 1834:
       13: 1835:   int32 Result = CFE_ES_BAD_ARGUMENT;
        -: 1836:   uint32   i;
        -: 1837:
        -: 1838:   /*
        -: 1839:   ** Search the ES Generic Counter table for a counter with a matching name.
        -: 1840:   */
      105: 1841:   for ( i = 0; i < CFE_ES_MAX_GEN_COUNTERS; i++ )
        -: 1842:   {
       94: 1843:      if ( CFE_ES_Global.CounterTable[i].RecordUsed == TRUE )
        -: 1844:      {
       57: 1845:         if ( strncmp(CounterName, (char *)CFE_ES_Global.CounterTable[i].CounterName, OS_MAX_API_NAME) == 0 )
        -: 1846:         {
        2: 1847:            if(CounterIdPtr != NULL)
        -: 1848:            {
        2: 1849:               *CounterIdPtr = (int) i;
        2: 1850:               Result = CFE_SUCCESS;
        -: 1851:            }
        2: 1852:            break;
        -: 1853:         }
        -: 1854:      }
        -: 1855:   } /* end for */
        -: 1856:   
       13: 1857:   return(Result);
        -: 1858:
        -: 1859:} /* End of CFE_ES_GetGenCounterIDByName() */
        -: 1860:
        -: 1861:
        -: 1862:/***************************************************************************************
        -: 1863:** Private API functions
        -: 1864:*/
        -: 1865:
        -: 1866:/*
        -: 1867:** Function: CFE_ES_GetAppIDInternal
        -: 1868:**
        -: 1869:** Purpose:  Return the Caller's cFE Application ID. This internal version is needed
        -: 1870:**            so there are not nested calls to the ES Shared Data mutex lock.
        -: 1871:**
        -: 1872:*/
       36: 1873:int32 CFE_ES_GetAppIDInternal(uint32 *AppIdPtr)
        -: 1874:{
       36: 1875:   int32  Result = CFE_ES_ERR_APPID;
        -: 1876:   uint32 TaskId;
        -: 1877:
        -: 1878:   /*
        -: 1879:   ** Step 1: Get the OS task ID
        -: 1880:   */
       36: 1881:   TaskId = OS_TaskGetId();
        -: 1882:
        -: 1883:   /*
        -: 1884:   ** Step 2: get the Application ID for the current task
        -: 1885:   */
       36: 1886:   if ( CFE_ES_Global.TaskTable[TaskId].RecordUsed == TRUE )
        -: 1887:   {
       31: 1888:      *AppIdPtr = CFE_ES_Global.TaskTable[TaskId].AppId;
       31: 1889:      Result = CFE_SUCCESS;
        -: 1890:   } /* end if */
       36: 1891:   return(Result);
        -: 1892:
        -: 1893:} /* End of CFE_ES_GetAppIDInternal() */
        -: 1894:
        -: 1895:
        -: 1896:/******************************************************************************
        -: 1897:**  Function:  CFE_ES_LockSharedData()
        -: 1898:**
        -: 1899:**  Purpose:
        -: 1900:**    ES internal function to take the Shared Data Mutex and handle
        -: 1901:**    error conditions.
        -: 1902:**
        -: 1903:**  Arguments:
        -: 1904:**    FunctionName   - the name of the function containing the code that generated the error.
        -: 1905:**    LineNumber     - the file line number of the code that generated the error.
        -: 1906:**
        -: 1907:**  Return:
        -: 1908:**    None
        -: 1909:*/
      315: 1910:void CFE_ES_LockSharedData(const char *FunctionName, int32 LineNumber)
        -: 1911:{
        -: 1912:
        -: 1913:    int32   Status;
        -: 1914:    uint32  AppId;
        -: 1915:
      315: 1916:    Status = OS_MutSemTake(CFE_ES_Global.SharedDataMutex);
      315: 1917:    if (Status != OS_SUCCESS) 
        -: 1918:    {
        1: 1919:        CFE_ES_GetAppIDInternal(&AppId);
        -: 1920:
        1: 1921:        CFE_ES_WriteToSysLog("ES SharedData Mutex Take Err Stat=0x%x,App=%d,Func=%s,Line=%d\n",
        -: 1922:                 Status,AppId,FunctionName,LineNumber);
        -: 1923:
        -: 1924:    }/* end if */
        -: 1925:
      315: 1926:    return;
        -: 1927:
        -: 1928:}/* end CFE_ES_LockSharedData */
        -: 1929:
        -: 1930:/******************************************************************************
        -: 1931:**  Function:  CFE_ES_UnlockSharedData()
        -: 1932:**
        -: 1933:**  Purpose:
        -: 1934:**    ES internal function to Release the shared data mutex and handle error
        -: 1935:**    conditions.
        -: 1936:**
        -: 1937:**  Arguments:
        -: 1938:**    FunctionName   - the name of the function containing the code that generated the error.
        -: 1939:**    LineNumber     - the file line number of the code that generated the error.
        -: 1940:**
        -: 1941:**  Return:
        -: 1942:**    None
        -: 1943:*/
      318: 1944:void CFE_ES_UnlockSharedData(const char *FunctionName, int32 LineNumber)
        -: 1945:{
        -: 1946:    int32   Status;
        -: 1947:    uint32  AppId;
        -: 1948:
      318: 1949:    Status = OS_MutSemGive(CFE_ES_Global.SharedDataMutex);
      318: 1950:    if (Status != OS_SUCCESS) 
        -: 1951:    {
        -: 1952:
        1: 1953:        CFE_ES_GetAppIDInternal(&AppId);
        -: 1954:
        1: 1955:        CFE_ES_WriteToSysLog("ES SharedData Mutex Give Err Stat=0x%x,App=%d,Func=%s,Line=%d\n",
        -: 1956:                                Status,AppId,FunctionName,LineNumber);
        -: 1957:
        -: 1958:    }/* end if */
        -: 1959:
      318: 1960:    return;
        -: 1961:
        -: 1962:}/* end CFE_ES_UnlockSharedData */
        -: 1963:
        -: 1964:/******************************************************************************
        -: 1965:**  Function:  CFE_ES_ProcessCoreException()
        -: 1966:**
        -: 1967:**  Purpose:
        -: 1968:**    ES internal function to handle the logging and reset from a system or
        -: 1969:**    cFE core exception
        -: 1970:**
        -: 1971:**  Arguments:
        -: 1972:**    Reason String
        -: 1973:**    Context
        -: 1974:**    Context Size
        -: 1975:** 
        -: 1976:**  Return:
        -: 1977:**    None
        -: 1978:*/
        3: 1979:void CFE_ES_ProcessCoreException(uint32  HostTaskId,     uint8 *ReasonString, 
        -: 1980:                                 uint32 *ContextPointer, uint32 ContextSize)
        -: 1981:{
        -: 1982:    uint32                 i;
        -: 1983:    int32                  Status;
        -: 1984:    OS_task_prop_t         TaskProp;
        -: 1985:    CFE_ES_TaskInfo_t      EsTaskInfo;
        3: 1986:    int                    FoundExceptionTask = 0;
        3: 1987:    int                    ExceptionTaskID = 0;
        -: 1988:    
        -: 1989:    /*
        -: 1990:    ** If a loadable cFE Application caused the reset and it's
        -: 1991:    ** exception action is set to Restart the App rather than cause a
        -: 1992:    ** processor reset, then just reset the App.
        -: 1993:    */
        -: 1994:
        -: 1995:    /*
        -: 1996:    ** We have the Host Task Id ( vxWorks, RTEMS, etc ). Search
        -: 1997:    ** the OSAPI to see if a match can be found.
        -: 1998:    */ 
      195: 1999:    for ( i = 0; i < OS_MAX_TASKS; i++ )
        -: 2000:    {
      192: 2001:       Status = OS_TaskGetInfo (i, &TaskProp);
        -: 2002:                                                                                                                                   
      192: 2003:       if ( Status == OS_SUCCESS )
        -: 2004:       {
      192: 2005:          if ( TaskProp.OStask_id == HostTaskId )
        -: 2006:          {
      192: 2007:             FoundExceptionTask = 1;
      192: 2008:             ExceptionTaskID = (int) i;
        -: 2009:          }
        -: 2010:       }
        -: 2011:    }
        -: 2012:
        -: 2013:    /*
        -: 2014:    ** If the Task is found in the OS, see if the cFE App ID associated with it can be found.
        -: 2015:    */
        3: 2016:    if ( FoundExceptionTask == 1 )
        -: 2017:    {
        3: 2018:       Status = CFE_ES_GetTaskInfo( &EsTaskInfo, ExceptionTaskID );
        -: 2019:       /*
        -: 2020:       ** The App ID was found, now see if the ExceptionAction is set for a reset
        -: 2021:       */                                                                                                                         
        3: 2022:       if ( Status == CFE_SUCCESS )
        -: 2023:       {
        3: 2024:          if ( CFE_ES_Global.AppTable[EsTaskInfo.AppId].StartParams.ExceptionAction == CFE_ES_APP_EXCEPTION_RESTART_APP )
        -: 2025:          {
        -: 2026:
        -: 2027:             /*
        -: 2028:             ** Log the Application reset 
        -: 2029:             */
        1: 2030:             CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_APP_RESTART, 
        -: 2031:                            CFE_ES_EXCEPTION, (char *)ReasonString,
        -: 2032:                            ContextPointer, ContextSize );
        -: 2033:
        -: 2034:             /*
        -: 2035:             ** Finally restart the App! This call is just a request
        -: 2036:             ** to ES.
        -: 2037:             */ 
        1: 2038:             Status = CFE_ES_RestartApp(EsTaskInfo.AppId );
        -: 2039:             
        -: 2040:             /*
        -: 2041:             ** Return to avoid the Processor Restart Logic
        -: 2042:             */
        1: 2043:             return;
        -: 2044:
        -: 2045:          } /* end if ExceptionAction */
        -: 2046:                                                                                                                                     
        -: 2047:       } /* end if */
        -: 2048:                                                                                                                                   
        -: 2049:    } /* End if FoundExceptionTask */
        -: 2050:                                                                                                                                     
        -: 2051:    /*
        -: 2052:    ** If we made it here, which means that we need to do a processor reset
        -: 2053:    */
        -: 2054:
        -: 2055:    /*
        -: 2056:    ** Before doing a Processor reset, check to see 
        -: 2057:    ** if the maximum number has been exceeded
        -: 2058:    */
        4: 2059:    if ( CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount >= 
        2: 2060:         CFE_ES_ResetDataPtr->ResetVars.MaxProcessorResetCount )
        -: 2061:    {
        -: 2062:        /*
        -: 2063:        ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -: 2064:        ** the entry just in case something fails.
        -: 2065:        */
        1: 2066:        CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY,  CFE_ES_POWERON_RESET, 
        -: 2067:                            CFE_ES_EXCEPTION, (char *)ReasonString,
        -: 2068:                            ContextPointer, ContextSize );
        -: 2069:
        -: 2070:        /*
        -: 2071:        ** Call the BSP reset routine to do a Poweron Reset 
        -: 2072:        */
        1: 2073:        CFE_PSP_Restart(CFE_ES_POWERON_RESET); 
        -: 2074:
        -: 2075:    }
        -: 2076:    else /* Do a processor reset */
        -: 2077:    {
        -: 2078:        /*
        -: 2079:        ** Update the reset variables
        -: 2080:        */
        1: 2081:        CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount++;
        1: 2082:        CFE_ES_ResetDataPtr->ResetVars.ES_CausedReset = TRUE;
        -: 2083:
        -: 2084:        /*
        -: 2085:        ** Log the reset in the ER Log
        -: 2086:        */
        1: 2087:        CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_PROCESSOR_RESET, 
        -: 2088:                            CFE_ES_EXCEPTION, (char *)ReasonString,
        -: 2089:                            ContextPointer, ContextSize );
        -: 2090:
        -: 2091:        /*
        -: 2092:        ** Need to do a processor reset
        -: 2093:        */   
        1: 2094:        CFE_PSP_Restart(CFE_ES_PROCESSOR_RESET);  
        -: 2095:
        -: 2096:    } /* end if */
        -: 2097:           
        -: 2098:} /* End of CFE_ES_ProcessCoreException */
