        -:    0:Source:/home/jdagostino/CProj/CFS/MKS/cfs-mission/cfe/fsw/cfe-core/src/es/cfe_es_cds.c
        -:    0:Graph:cfe_es_cds.gcno
        -:    0:Data:cfe_es_cds.gcda
        -:    0:Runs:1
        -:    0:Programs:3
        -:    1:/*
        -:    2:**  File:  
        -:    3:**    cfe_es_cds.c
        -:    4:**
        -:    5:**
        -:    6:**
        -:    7:**      Copyright (c) 2004-2006, United States government as represented by the 
        -:    8:**      administrator of the National Aeronautics Space Administration.  
        -:    9:**      All rights reserved. This software(cFE) was created at NASA Goddard 
        -:   10:**      Space Flight Center pursuant to government contracts.
        -:   11:**
        -:   12:**      This software may be used only pursuant to a United States government 
        -:   13:**      sponsored project and the United States government may not be charged
        -:   14:**      for use thereof. 
        -:   15:**
        -:   16:**
        -:   17:**  Purpose:  
        -:   18:**    This file implements the cFE Executive Services Critical Data Store functions.
        -:   19:**
        -:   20:**  References:
        -:   21:**     Flight Software Branch C Coding Standard Version 1.0a
        -:   22:**     cFE Flight Software Application Developers Guide
        -:   23:**
        -:   24:**  Notes:
        -:   25:** 
        -:   26:**  Modification History:
        -:   27:**
        -:   28:** $Log: cfe_es_cds.c.gcov  $
        -:   28:** Revision 1.3 2010/11/04 17:46:35EDT jmdagost 
        -:   28:** Updated unit test results.
        -:   29:** Revision 1.2 2009/06/10 09:08:53EDT acudmore 
        -:   30:** Converted OS_Mem* and OS_BSP* API to CFE_PSP_* API
        -:   31:** Revision 1.1 2008/04/17 08:05:03EDT ruperera 
        -:   32:** Initial revision
        -:   33:** Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/src/es/project.pj
        -:   34:** Revision 1.2.1.16 2007/07/11 11:42:30EDT David Kobe (dlkobe) 
        -:   35:** Only allocates CDS Registry Record after successful registration
        -:   36:** Revision 1.2.1.15 2007/06/07 09:35:33EDT dlkobe 
        -:   37:** Corrected Error in Delete CDS function
        -:   38:** Revision 1.2.1.14 2007/05/04 15:51:31EDT dlkobe 
        -:   39:** Added CFE_ES_DeleteCDS function to allow TBL and ES to use common code
        -:   40:** Revision 1.2.1.13 2007/04/28 16:08:07EDT dlkobe 
        -:   41:** Corrected yet another file corruption
        -:   42:** Revision 1.2.1.12 2007/04/28 15:57:01EDT dlkobe 
        -:   43:** Added "cfe_es_cds.h" includes to resolve sudden errors.
        -:   44:** Revision 1.2.1.11 2007/04/28 15:50:26EDT dlkobe 
        -:   45:** Fixed typos leftover from restructuring
        -:   46:** Revision 1.2.1.10 2007/04/28 15:48:45EDT dlkobe 
        -:   47:** Correcting Corrupted File
        -:   48:** Revision 1.2.1.9 2007/04/28 15:35:20EDT dlkobe 
        -:   49:** Corrected Typos from restructuring
        -:   50:** Revision 1.2.1.8 2007/04/28 15:32:38EDT dlkobe 
        -:   51:** Restructured CFE_ES_RegisterCDS call to avoid Application Unknown Error
        -:   52:** Revision 1.2.1.7 2007/04/28 15:04:43EDT dlkobe 
        -:   53:** Corrected Variable Name Typo
        -:   54:** Revision 1.2.1.6 2007/04/28 14:49:02EDT dlkobe 
        -:   55:** Baseline Implementation of Critical Tables
        -:   56:** Revision 1.2.1.5 2007/04/26 15:39:35EDT rjmcgraw 
        -:   57:** Added error returns in CFE_ES_CDS_EarlyInit
        -:   58:** Revision 1.2.1.4 2007/04/13 16:24:02EDT apcudmore 
        -:   59:** Changed EarlyInit function to return int32 status
        -:   60:** Revision 1.2.1.3 2007/04/04 16:06:41EDT dlkobe 
        -:   61:** Made numerous changes to correct issues identified during ES code walkthrough
        -:   62:** Revision 1.2.1.2 2006/10/30 15:28:29GMT-05:00 dlkobe 
        -:   63:** Removed extra "PoolSize" variable
        -:   64:** Revision 1.2.1.1 2006/10/30 11:05:04GMT-05:00 dlkobe 
        -:   65:** Initial revision
        -:   66:** Member added to project d:/mksdata/MKS-CFE-PROJECT/fsw/cfe-core/src/es/project.pj
        -:   67:**
        -:   68:*/
        -:   69:
        -:   70:/*
        -:   71:** Required header files.
        -:   72:*/
        -:   73:#include "cfe.h"
        -:   74:#include "cfe_es_apps.h"
        -:   75:#include "cfe_es_cds.h"
        -:   76:#include "cfe_es_global.h"
        -:   77:#include "cfe_psp.h"
        -:   78:#include "cfe_es_cds_mempool.h"
        -:   79:
        -:   80:#include <string.h>
        -:   81:#include <stdio.h>
        -:   82:#include <stdarg.h>
        -:   83:
        -:   84:/* Define offset addresses for CDS data segments */
        -:   85:/* Each segment is guaranteed to start at a 4-byte offset boundary */
        -:   86:#define CDS_REG_SIZE_OFFSET ((sizeof(CFE_ES_Global.CDSVars.ValidityField)+3) & 0xfffffffc)
        -:   87:#define CDS_REG_OFFSET      (((CDS_REG_SIZE_OFFSET + sizeof(CFE_ES_Global.CDSVars.MaxNumRegEntries)) + 3) & 0xfffffffc)
        -:   88:#define CDS_POOL_OFFSET     (((CDS_REG_OFFSET + (CFE_ES_CDS_MAX_NUM_ENTRIES * sizeof(CFE_ES_CDS_RegRec_t))) + 3) & 0xfffffffc)
        -:   89:
        -:   90:/*****************************************************************************/
        -:   91:/**
        -:   92:** \brief Determines whether a CDS currently exists
        -:   93:**
        -:   94:** \par Description
        -:   95:**        Reads a set of bytes from the beginning and end of the CDS memory
        -:   96:**        area and determines if a fixed pattern is present, thus determining
        -:   97:**        whether the CDS still likely contains valid data or not.
        -:   98:**
        -:   99:** \par Assumptions, External Events, and Notes:
        -:  100:**          None
        -:  101:**
        -:  102:** \return #CFE_SUCCESS         \copydoc CFE_SUCCESS
        -:  103:** \return #CFE_ES_CDS_INVALID  \copydoc CFE_ES_CDS_INVALID
        -:  104:** \return Any of the return values from #CFE_PSP_ReadFromCDS
        -:  105:**                     
        -:  106:******************************************************************************/
        -:  107:int32 CFE_ES_ValidateCDS(void);
        -:  108:
        -:  109:/*****************************************************************************/
        -:  110:/**
        -:  111:** \brief Initializes the contents of the CDS
        -:  112:**
        -:  113:** \par Description
        -:  114:**        Stores a fixed pattern at the beginning and end of the CDS memory
        -:  115:**        to tag it for future verification following a reset.
        -:  116:**
        -:  117:** \par Assumptions, External Events, and Notes:
        -:  118:**          None
        -:  119:**
        -:  120:** \param[in]  CDSSize Total size of CDS memory area (in bytes)
        -:  121:**
        -:  122:** \return #OS_SUCCESS          \copydoc OS_SUCCESS
        -:  123:** \return Any of the return values from #CFE_PSP_WriteToCDS
        -:  124:** \return Any of the return values from #CFE_ES_CreateCDSPool
        -:  125:**                     
        -:  126:******************************************************************************/
        -:  127:int32 CFE_ES_InitializeCDS(uint32 CDSSize);
        -:  128:
        -:  129:/*****************************************************************************/
        -:  130:/**
        -:  131:** \brief Initializes the CDS Registry
        -:  132:**
        -:  133:** \par Description
        -:  134:**        Initializes the data structure used to keep track of CDS blocks and
        -:  135:**        who they belong to.
        -:  136:**
        -:  137:** \par Assumptions, External Events, and Notes:
        -:  138:**          None
        -:  139:**
        -:  140:** \retval #CFE_SUCCESS         \copydoc CFE_SUCCESS
        -:  141:**                     
        -:  142:******************************************************************************/
        -:  143:int32 CFE_ES_InitCDSRegistry(void);
        -:  144:
        -:  145:
        -:  146:/*****************************************************************************/
        -:  147:/**
        -:  148:** \brief Rebuilds memory pool for CDS and recovers existing registry
        -:  149:**
        -:  150:** \par Description
        -:  151:**        Scans memory for existing CDS and initializes memory pool and registry
        -:  152:**        settings accordingly
        -:  153:**
        -:  154:** \par Assumptions, External Events, and Notes:
        -:  155:**        -# Assumes the validity of the CDS has already been determined
        -:  156:**
        -:  157:** \return #CFE_SUCCESS         \copydoc CFE_SUCCESS
        -:  158:** \return Any of the return values from #CFE_PSP_ReadFromCDS
        -:  159:**                     
        -:  160:******************************************************************************/
        -:  161:int32 CFE_ES_RebuildCDS(void);
        -:  162:
        -:  163:/*****************************************************************************/
        -:  164:/**
        -:  165:** \brief Initializes CDS data constructs
        -:  166:**
        -:  167:** \par Description
        -:  168:**        Locates and validates any pre-existing CDS memory or initializes the
        -:  169:**        memory as a fresh CDS.
        -:  170:**
        -:  171:** \par Assumptions, External Events, and Notes:
        -:  172:**          None
        -:  173:**
        -:  174:** \par SysLog Messages
        -:  175:**
        -:  176:**
        -:  177:** \return None
        -:  178:**
        -:  179:******************************************************************************/
        -:  180:int32 CFE_ES_CDS_EarlyInit(void)
       14:  181:{
       14:  182:    uint32  MinRequiredSize = 0;
       14:  183:    int32   Status = CFE_SUCCESS;
        -:  184:    
        -:  185:    /* Compute the minimum size required for the CDS with the current configuration of the cFE */
       14:  186:    MinRequiredSize = (sizeof(CFE_ES_Global.CDSVars.ValidityField) * 2) +            /* Minimum size for validity fields */
        -:  187:                      (CFE_ES_CDS_MAX_NUM_ENTRIES * sizeof(CFE_ES_CDS_RegRec_t)) +   /* Minimum size for CDS Registry contents */
        -:  188:                      CFE_ES_CDSReqdMinSize(CFE_ES_CDS_MAX_NUM_ENTRIES);             /* Max # of Min Sized Blocks */
        -:  189:    
        -:  190:    /* Get CDS size from OS BSP */
       14:  191:    Status = CFE_PSP_GetCDSSize(&CFE_ES_Global.CDSVars.CDSSize);
        -:  192:    
        -:  193:    /* If the size was obtained successfully and meets the minimum requirements, then check its contents */
       14:  194:    if (Status == OS_SUCCESS)
        -:  195:    {
        -:  196:        /* Always truncate the size to the nearest 4 byte boundary */
       13:  197:        CFE_ES_Global.CDSVars.CDSSize &= 0xfffffffc;
        -:  198:        
       13:  199:        if (CFE_ES_Global.CDSVars.CDSSize >= MinRequiredSize)
        -:  200:        {
       12:  201:            Status = CFE_ES_ValidateCDS();
        -:  202:            
        -:  203:            /* If the CDS is accessible but invalid, then create a new one */
       12:  204:            if (Status == CFE_ES_CDS_INVALID)
        -:  205:            {
       11:  206:                Status = CFE_ES_InitializeCDS(CFE_ES_Global.CDSVars.CDSSize);
        -:  207:            }
        1:  208:            else if (Status == CFE_SUCCESS)
        -:  209:            {
        -:  210:                /* If a valid CDS was found, rebuild the memory pool */
        1:  211:                Status = CFE_ES_RebuildCDS();
        -:  212:                
        -:  213:                /* If rebuilding is not possible, then create a new one from scratch */
        1:  214:                if (Status == CFE_ES_CDS_INVALID)
        -:  215:                {
        1:  216:                    Status = CFE_ES_InitializeCDS(CFE_ES_Global.CDSVars.CDSSize);
        -:  217:                }
        -:  218:            }
        -:  219:            else /* Unrecoverable error while reading the CDS */
        -:  220:            {
    #####:  221:                CFE_ES_WriteToSysLog("CFE_CDS:EarlyInit-Read error validating CDS (Err=0x%08X)\n", Status);
    #####:  222:                CFE_ES_Global.CDSVars.MemPoolSize = 0;
    #####:  223:                return Status;
        -:  224:            }
        -:  225:
       12:  226:            if (Status == CFE_SUCCESS)
        -:  227:            {
        -:  228:                /* Create CDS registry access mutex */
       12:  229:                OS_MutSemCreate(&CFE_ES_Global.CDSVars.RegistryMutex,
        -:  230:                                 CFE_ES_CDS_MUT_REG_NAME,
        -:  231:                                 CFE_ES_CDS_MUT_REG_VALUE);
        -:  232:            }     
        -:  233:        }
        -:  234:        else /* Size < MinRequiredSize */
        -:  235:        {
        1:  236:            CFE_ES_WriteToSysLog("CFE_CDS:EarlyInit-CDS Size (%d) less than required (%d)\n", 
        -:  237:	                         CFE_ES_Global.CDSVars.CDSSize, MinRequiredSize);
        1:  238:            CFE_ES_Global.CDSVars.MemPoolSize = 0;
        1:  239:            return Status;
        -:  240:        }
        -:  241:    }
        -:  242:    else /* Error getting the size of the CDS from the BSP */
        -:  243:    {
        1:  244:        CFE_ES_WriteToSysLog("CFE_CDS:EarlyInit-Unable to obtain CDS Size from BSP (Err=0x%08X)\n", Status);
        1:  245:        CFE_ES_Global.CDSVars.MemPoolSize = 0;
        1:  246:        return Status;
        -:  247:    }
        -:  248:    
        -:  249:    
       12:  250:    return(CFE_SUCCESS);
        -:  251:    
        -:  252:}   /* End of CFE_ES_CDS_EarlyInit() */
        -:  253:
        -:  254:/*******************************************************************
        -:  255:**
        -:  256:** CFE_ES_RegisterCDSEx
        -:  257:**
        -:  258:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  259:********************************************************************/
        -:  260:
        -:  261:int32 CFE_ES_RegisterCDSEx(CFE_ES_CDSHandle_t *HandlePtr, int32 BlockSize, const char *Name, boolean CriticalTbl)
        6:  262:{
        6:  263:    int32   Status = CFE_SUCCESS;
        6:  264:    uint32  RegIndx = CFE_ES_CDS_NOT_FOUND;
        6:  265:    CFE_ES_CDS_RegRec_t *RegRecPtr = NULL;
        -:  266:    
        -:  267:    /* Lock Registry for update.  This prevents two applications from */
        -:  268:    /* trying to register CDSs at the same location at the same time  */
        6:  269:    CFE_ES_LockCDSRegistry();
        -:  270:
        -:  271:    /* Check for duplicate CDS name */
        6:  272:    RegIndx = CFE_ES_FindCDSInRegistry(Name);
        -:  273:
        -:  274:    /* Check to see if CDS is already in the registry */
        6:  275:    if (RegIndx != CFE_ES_CDS_NOT_FOUND)
        -:  276:    {
        -:  277:        /* Get pointer to Registry Record Entry to speed up processing */
        2:  278:        RegRecPtr = &CFE_ES_Global.CDSVars.Registry[RegIndx];
        -:  279:
        -:  280:        /* If the new CDS is the same size as the old, then no need to reallocate memory */
        2:  281:        if (BlockSize != RegRecPtr->Size)
        -:  282:        {
        -:  283:            /* If the new size is different, the old CDS must be deleted first  */
        -:  284:            /* Free the old memory */
        1:  285:            Status = CFE_ES_PutCDSBlock(RegRecPtr->MemHandle);
        -:  286:        }
        -:  287:        else
        -:  288:        {
        -:  289:            /* Warn calling application that this is a duplicate registration */
        1:  290:            Status = CFE_ES_CDS_ALREADY_EXISTS;
        -:  291:               
        -:  292:            /* Return the index into the registry as the handle to the CDS */
        1:  293:            *HandlePtr = RegIndx;
        -:  294:        }
        -:  295:    }
        -:  296:    else  /* CDS not already in registry */
        -:  297:    {
        -:  298:        /* Locate empty slot in table registry */
        4:  299:        RegIndx = CFE_ES_FindFreeCDSRegistryEntry();
        -:  300:        
        -:  301:        /* Check to make sure we found a free entry in registry */
        4:  302:        if (RegIndx == CFE_ES_CDS_NOT_FOUND)
        -:  303:        {
        1:  304:            Status = CFE_ES_CDS_REGISTRY_FULL;
        1:  305:            CFE_ES_WriteToSysLog("CFE_CDS:Register-Registry full\n");
        -:  306:        }
        -:  307:        else
        -:  308:        {
        3:  309:            RegRecPtr = &CFE_ES_Global.CDSVars.Registry[RegIndx];
        -:  310:        }
        -:  311:    }
        -:  312:
        -:  313:    /* If no errors, then initialize the CDS registry entry     */
        6:  314:    if (Status == CFE_SUCCESS)
        -:  315:    {
        -:  316:        /* Allocate the memory buffer for the CDS */
        4:  317:        Status = CFE_ES_GetCDSBlock((CFE_ES_CDSBlockHandle_t *)&RegRecPtr->MemHandle, BlockSize);
        -:  318:            
        4:  319:        if (Status == CFE_SUCCESS)
        -:  320:        {
        4:  321:           RegRecPtr->Taken = TRUE;
        -:  322:        
        -:  323:           /* Save the size of the CDS */
        4:  324:           RegRecPtr->Size = BlockSize;
        -:  325:        
        -:  326:           /* Save flag indicating whether it is a Critical Table or not */
        4:  327:           RegRecPtr->Table = CriticalTbl;
        -:  328:
        -:  329:           /* Save CDS Name in Registry */
        4:  330:           strncpy(RegRecPtr->Name, Name, CFE_TBL_MAX_FULL_NAME_LEN);
        -:  331:               
        -:  332:           /* Return the index into the registry as the handle to the CDS */
        4:  333:           *HandlePtr = RegIndx;
        -:  334:        
        -:  335:           /* If we succeeded at creating a CDS, save updated registry in the CDS */
        4:  336:           Status = CFE_ES_UpdateCDSRegistry();
        -:  337:                
        4:  338:           if (Status != CFE_SUCCESS)
        -:  339:           {
        1:  340:              CFE_ES_WriteToSysLog("CFE_CDS:RegCDS-Failed to update CDS Registry (Stat=0x%08X)\n", Status);
        -:  341:           }
        -:  342:        }
        -:  343:    }
        -:  344:
        -:  345:    /* Unlock Registry for update */
        6:  346:    CFE_ES_UnlockCDSRegistry();
        -:  347:    
        6:  348:    return (Status);
        -:  349:
        -:  350:}  /* End of CFE_ES_RegisterCDSEx() */
        -:  351:
        -:  352:/*******************************************************************
        -:  353:**
        -:  354:** CFE_ES_ValidateCDS
        -:  355:**
        -:  356:** NOTE: For complete prolog information, see prototype above
        -:  357:********************************************************************/
        -:  358:
        -:  359:int32 CFE_ES_ValidateCDS(void)
       15:  360:{
        -:  361:    /* Assume the CDS is invalid */
       15:  362:    int32 Status = CFE_ES_CDS_INVALID;
        -:  363:    
        -:  364:    /* Perform 2 checks to validate the CDS Memory Pool */
        -:  365:    /* First, determine if the first validity check field is correct */
       15:  366:    Status = CFE_PSP_ReadFromCDS(&CFE_ES_Global.CDSVars.ValidityField, 0, sizeof(CFE_ES_Global.CDSVars.ValidityField));
        -:  367:
       15:  368:    if (Status == OS_SUCCESS)
        -:  369:    {
       14:  370:        if (strncmp(CFE_ES_Global.CDSVars.ValidityField, "_CDSBeg_", sizeof(CFE_ES_Global.CDSVars.ValidityField)) == 0)
        -:  371:        {
        3:  372:            Status = CFE_PSP_ReadFromCDS(&CFE_ES_Global.CDSVars.ValidityField, 
        -:  373:                                       (CFE_ES_Global.CDSVars.CDSSize-sizeof(CFE_ES_Global.CDSVars.ValidityField)), 
        -:  374:                                       sizeof(CFE_ES_Global.CDSVars.ValidityField));
        -:  375:        
        3:  376:            if (Status == OS_SUCCESS)
        -:  377:            {
        2:  378:                if (strncmp(CFE_ES_Global.CDSVars.ValidityField, "_CDSEnd_", sizeof(CFE_ES_Global.CDSVars.ValidityField)) == 0)
        -:  379:                {
        1:  380:                    Status = CFE_SUCCESS;
        -:  381:                }
        -:  382:                else /* Validity Field failed */
        -:  383:                {
        1:  384:                    Status = CFE_ES_CDS_INVALID;
        -:  385:                }
        -:  386:            }
        -:  387:            else /* BSP reported an error reading from CDS */
        -:  388:            {
        1:  389:                CFE_ES_WriteToSysLog("CFE_CDS:Validate-2nd ReadFromCDS Failed. Status=0x%X\n", Status);   
        -:  390:            }
        -:  391:        }
        -:  392:        else /* Validity Field failed */
        -:  393:        {
       11:  394:            Status = CFE_ES_CDS_INVALID;
        -:  395:        }
        -:  396:    }
        -:  397:    else /* BSP reported an error reading from CDS */
        -:  398:    {
        1:  399:        CFE_ES_WriteToSysLog("CFE_CDS:Validate-1st ReadFromCDS Failed. Status=0x%X\n", Status);   
        -:  400:    }
        -:  401:    
       15:  402:    return Status;
        -:  403:}   /* End of CFE_ES_ValidateCDS() */
        -:  404:
        -:  405:/*******************************************************************
        -:  406:**
        -:  407:** CFE_ES_InitializeCDS
        -:  408:**
        -:  409:** NOTE: For complete prolog information, see prototype above
        -:  410:********************************************************************/
        -:  411:
        -:  412:int32 CFE_ES_InitializeCDS(uint32 CDSSize)
       15:  413:{
       15:  414:    int32  Status = CFE_SUCCESS;
        -:  415:    uint32 MemBlock[32];
       15:  416:    uint32 NumWritten=0;
       15:  417:    uint32 Uint32Zero=0;
        -:  418:    
        -:  419:    /* Clear the CDS to ensure everything is gone */
        -:  420:    /* Create a block of zeros to write to the CDS */
       15:  421:    CFE_PSP_MemSet(MemBlock, 0, sizeof(MemBlock));
        -:  422:    
        -:  423:    /* While there is space to write another block of zeros, then do so */
    12307:  424:    while (((NumWritten + sizeof(MemBlock)) < CDSSize) && (Status == OS_SUCCESS))
        -:  425:    {
    12277:  426:        Status = CFE_PSP_WriteToCDS(MemBlock, NumWritten, sizeof(MemBlock));
        -:  427:        
    12277:  428:        if (Status == OS_SUCCESS)
        -:  429:        {
    12276:  430:            NumWritten += sizeof(MemBlock);
        -:  431:        }
        -:  432:    }
        -:  433:    
        -:  434:    /* While there is space to write a uint32 of zeros, then do so */
       15:  435:    if ((Status == OS_SUCCESS) && (NumWritten < CDSSize))
        -:  436:    {
      396:  437:        while (((NumWritten + sizeof(uint32)) < CDSSize) && (Status == OS_SUCCESS))
        -:  438:        {
      372:  439:            Status = CFE_PSP_WriteToCDS(&Uint32Zero, NumWritten, sizeof(uint32));
        -:  440:            
      372:  441:            if (Status == OS_SUCCESS)
        -:  442:            {
      372:  443:                NumWritten += sizeof(uint32);
        -:  444:            }
        -:  445:        }
        -:  446:    }
        -:  447:
       15:  448:    if (Status != OS_SUCCESS)
        -:  449:    {
        1:  450:        CFE_ES_WriteToSysLog("CFE_CDS:Init-Clear CDS failed @ Offset=%d Status=0x%08X\n", NumWritten, Status);   
        -:  451:    }
        -:  452:    else
        -:  453:    {
        -:  454:        /* Initialize the Validity Check strings */
       14:  455:        Status = CFE_PSP_WriteToCDS("_CDSBeg_", 0, sizeof(CFE_ES_Global.CDSVars.ValidityField));
       14:  456:        if (Status == OS_SUCCESS)
        -:  457:        {
       13:  458:            Status = CFE_PSP_WriteToCDS("_CDSEnd_", 
        -:  459:                                      (CDSSize-sizeof(CFE_ES_Global.CDSVars.ValidityField)), 
        -:  460:                                      sizeof(CFE_ES_Global.CDSVars.ValidityField));
       13:  461:            if (Status != OS_SUCCESS)
        -:  462:            {
        1:  463:                CFE_ES_WriteToSysLog("CFE_CDS:Init-'_CDSEnd_' write failed. Status=0x%08X\n", Status);   
        -:  464:            }
        -:  465:            else
        -:  466:            {
        -:  467:                /* Determine the amount of CDS memory is available for the CDS Memory Pool */
        -:  468:                /* Total CDS Size minus the validity fields and the space for the registry and the registry size */
       12:  469:                CFE_ES_Global.CDSVars.MemPoolSize = CDSSize - CDS_POOL_OFFSET - sizeof(CFE_ES_Global.CDSVars.ValidityField); 
        -:  470:                
        -:  471:                /* Initialize the variables for managing the CDS Memory Pool */
       12:  472:                Status = CFE_ES_CreateCDSPool(CFE_ES_Global.CDSVars.MemPoolSize, CDS_POOL_OFFSET);
        -:  473:                
       12:  474:                if (Status == CFE_SUCCESS)
        -:  475:                {
       12:  476:                    Status = CFE_ES_InitCDSRegistry();
        -:  477:                }
        -:  478:            }
        -:  479:        }
        -:  480:        else /* BSP reported an error writing to CDS */
        -:  481:        {
        1:  482:            CFE_ES_WriteToSysLog("CFE_CDS:Init-'_CDSBeg_' write failed. Status=0x%08X\n", Status);   
        -:  483:        }
        -:  484:    }
        -:  485:    
       15:  486:    return Status;
        -:  487:}   /* End of CFE_ES_InitializeCDS() */
        -:  488:
        -:  489:/*******************************************************************
        -:  490:**
        -:  491:** CFE_ES_InitCDSRegistry
        -:  492:**
        -:  493:** NOTE: For complete prolog information, see prototype above
        -:  494:********************************************************************/
        -:  495:
        -:  496:int32 CFE_ES_InitCDSRegistry(void)
       13:  497:{
       13:  498:    int32 Status = CFE_SUCCESS;
       13:  499:    int32 i = 0;
        -:  500:    
        -:  501:    /* Initialize the local CDS Registry */
       13:  502:    CFE_ES_Global.CDSVars.MaxNumRegEntries = CFE_ES_CDS_MAX_NUM_ENTRIES;
     6669:  503:    for (i=0; i<CFE_ES_Global.CDSVars.MaxNumRegEntries; i++)
        -:  504:    {
     6656:  505:        CFE_ES_Global.CDSVars.Registry[i].Name[0] = '\0';
     6656:  506:        CFE_ES_Global.CDSVars.Registry[i].Size = 0;
     6656:  507:        CFE_ES_Global.CDSVars.Registry[i].MemHandle = 0;
     6656:  508:        CFE_ES_Global.CDSVars.Registry[i].Taken = FALSE;
     6656:  509:        CFE_ES_Global.CDSVars.Registry[i].Table = FALSE;
        -:  510:    }
        -:  511:    
        -:  512:    /* Copy the number of registry entries to the CDS */
       13:  513:    Status = CFE_PSP_WriteToCDS(&CFE_ES_Global.CDSVars.MaxNumRegEntries, 
        -:  514:                               CDS_REG_SIZE_OFFSET, 
        -:  515:                               sizeof(CFE_ES_Global.CDSVars.MaxNumRegEntries));
        -:  516:    
       13:  517:    if (Status == OS_SUCCESS)
        -:  518:    {
       12:  519:        Status = CFE_ES_UpdateCDSRegistry();
        -:  520:    }
        -:  521:    else
        -:  522:    {
        1:  523:        CFE_ES_WriteToSysLog("CFE_CDS:InitReg-Failed to write Reg Size. Status=0x%08X\n", Status);
        -:  524:    }
        -:  525:    
       13:  526:    return Status;
        -:  527:}   /* End of CFE_ES_InitCDSRegistry() */
        -:  528:
        -:  529:/*******************************************************************
        -:  530:**
        -:  531:** CFE_ES_UpdateCDSRegistry
        -:  532:**
        -:  533:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  534:********************************************************************/
        -:  535:
        -:  536:int32 CFE_ES_UpdateCDSRegistry(void)
       18:  537:{
       18:  538:    int32 Status = CFE_SUCCESS;
        -:  539:    
        -:  540:    /* Copy the contents of the local registry to the CDS */
       18:  541:    Status = CFE_PSP_WriteToCDS(CFE_ES_Global.CDSVars.Registry, 
        -:  542:                              CDS_REG_OFFSET,
        -:  543:                              sizeof(CFE_ES_Global.CDSVars.Registry));
        -:  544:    
       18:  545:    if (Status != OS_SUCCESS)
        -:  546:    {
        2:  547:        CFE_ES_WriteToSysLog("CFE_CDS:UpdateReg-Failed to write CDS Registry. Status=0x%08X\n", Status);
        -:  548:    }
        -:  549:    
       18:  550:    return Status;
        -:  551:}
        -:  552:
        -:  553:/*******************************************************************
        -:  554:**
        -:  555:** CFE_ES_CDS_ValidateAppID
        -:  556:**
        -:  557:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  558:********************************************************************/
        -:  559:
        -:  560:int32 CFE_ES_CDS_ValidateAppID(uint32 *AppIdPtr)
       11:  561:{
       11:  562:    int32 Status = CFE_ES_GetAppID(AppIdPtr);
        -:  563:
       11:  564:    if (Status == CFE_SUCCESS)
        -:  565:    {
       10:  566:        if (*AppIdPtr >= CFE_ES_MAX_APPLICATIONS)
        -:  567:        {
        1:  568:            Status = CFE_ES_ERR_APPID;
        -:  569:
        1:  570:            CFE_ES_WriteToSysLog("CFE_CDS:ValidateAppID-AppId=%d > Max Apps (%d)\n",
        -:  571:                                 *AppIdPtr, CFE_ES_MAX_APPLICATIONS);
        -:  572:        }
        -:  573:    }
        -:  574:    else
        -:  575:    {
        1:  576:        CFE_ES_WriteToSysLog("CFE_CDS:ValidateAppID-GetAppID failed (Stat=0x%08X)\n", Status);
        -:  577:    }
        -:  578:
       11:  579:    return Status;
        -:  580:}   /* End of CFE_ES_CDS_ValidateAppID() */
        -:  581:
        -:  582:
        -:  583:/*******************************************************************
        -:  584:**
        -:  585:** CFE_ES_FormCDSName
        -:  586:**
        -:  587:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  588:********************************************************************/
        -:  589:
        -:  590:void CFE_ES_FormCDSName(char *FullCDSName, const char *CDSName, uint32 ThisAppId)
        7:  591:{
        -:  592:    char AppName[OS_MAX_API_NAME];
        -:  593:
        7:  594:    CFE_ES_GetAppName(AppName, ThisAppId, OS_MAX_API_NAME);
        -:  595:
        -:  596:    /* Ensure that AppName is null terminated */
        7:  597:    AppName[OS_MAX_API_NAME-1] = '\0';
        -:  598:
        -:  599:    /* Complete formation of processor specific table name */
        7:  600:    sprintf(FullCDSName, "%s.%s", AppName, CDSName);
        -:  601:
        -:  602:    return;
        -:  603:}   /* End of CFE_ES_FormCDSName() */
        -:  604:
        -:  605:
        -:  606:/*******************************************************************
        -:  607:**
        -:  608:** CFE_ES_LockCDSRegistry
        -:  609:**
        -:  610:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  611:********************************************************************/
        -:  612:
        -:  613:int32 CFE_ES_LockCDSRegistry(void)
       15:  614:{
        -:  615:    int32   Status;
        -:  616:
       15:  617:    Status = OS_MutSemTake(CFE_ES_Global.CDSVars.RegistryMutex);
        -:  618:
        -:  619:    if (Status == OS_SUCCESS)
        -:  620:    {
        -:  621:        Status = CFE_SUCCESS;
        -:  622:    }
        -:  623:
       15:  624:    return Status;
        -:  625:
        -:  626:}   /* End of CFE_ES_LockCDSRegistry() */
        -:  627:
        -:  628:
        -:  629:/*******************************************************************
        -:  630:**
        -:  631:** CFE_ES_UnlockCDSRegistry
        -:  632:**
        -:  633:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  634:********************************************************************/
        -:  635:
        -:  636:int32 CFE_ES_UnlockCDSRegistry(void)
       15:  637:{
        -:  638:    int32   Status;
        -:  639:
       15:  640:    Status = OS_MutSemGive(CFE_ES_Global.CDSVars.RegistryMutex);
        -:  641:
        -:  642:    if (Status == OS_SUCCESS)
        -:  643:    {
        -:  644:        Status = CFE_SUCCESS;
        -:  645:    }
        -:  646:
       15:  647:    return Status;
        -:  648:
        -:  649:}   /* End of CFE_ES_UnlockCDSRegistry() */
        -:  650:
        -:  651:
        -:  652:/*******************************************************************
        -:  653:**
        -:  654:** CFE_ES_FindCDSInRegistry
        -:  655:**
        -:  656:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  657:********************************************************************/
        -:  658:
        -:  659:int32 CFE_ES_FindCDSInRegistry(const char *CDSName)
       15:  660:{
       15:  661:    int32 RegIndx = CFE_ES_CDS_NOT_FOUND;
       15:  662:    int32 i = -1;
        -:  663:
        -:  664:    do
        -:  665:    {
        -:  666:        /* Point to next record in the CDS Registry */
     2572:  667:        i++;
        -:  668:
        -:  669:        /* Check to see if the record is currently being used */
     2572:  670:        if (CFE_ES_Global.CDSVars.Registry[i].Taken == TRUE)
        -:  671:        {
        -:  672:            /* Perform a case sensitive name comparison */
      525:  673:            if (strcmp(CDSName, CFE_ES_Global.CDSVars.Registry[i].Name) == 0)
        -:  674:            {
        -:  675:                /* If the names match, then return the index */
       10:  676:                RegIndx = i;
        -:  677:            }
        -:  678:        }
     2572:  679:    } while ( (RegIndx == CFE_ES_CDS_NOT_FOUND) && (i < (CFE_ES_Global.CDSVars.MaxNumRegEntries-1)) );
        -:  680:
       15:  681:    return RegIndx;
        -:  682:}   /* End of CFE_ES_FindCDSInRegistry() */
        -:  683:
        -:  684:
        -:  685:/*******************************************************************
        -:  686:**
        -:  687:** CFE_ES_FindFreeCDSRegistryEntry
        -:  688:**
        -:  689:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  690:********************************************************************/
        -:  691:
        -:  692:int32 CFE_ES_FindFreeCDSRegistryEntry(void)
        4:  693:{
        4:  694:    int32 RegIndx = CFE_ES_CDS_NOT_FOUND;
        4:  695:    int32 i = 0;
        -:  696:
      524:  697:    while ( (RegIndx == CFE_ES_CDS_NOT_FOUND) && (i < CFE_ES_Global.CDSVars.MaxNumRegEntries) )
        -:  698:    {
      516:  699:        if (CFE_ES_Global.CDSVars.Registry[i].Taken == FALSE)
        -:  700:        {
        3:  701:            RegIndx = i;
        -:  702:        }
        -:  703:        else
        -:  704:        {
      513:  705:            i++;
        -:  706:        }
        -:  707:    }
        -:  708:
        4:  709:    return RegIndx;
        -:  710:}   /* End of CFE_ES_FindFreeCDSRegistryEntry() */
        -:  711:
        -:  712:
        -:  713:/*******************************************************************
        -:  714:**
        -:  715:** CFE_ES_RebuildCDS
        -:  716:**
        -:  717:** NOTE: For complete prolog information, see above
        -:  718:********************************************************************/
        -:  719:
        -:  720:int32 CFE_ES_RebuildCDS(void)
        5:  721:{
        5:  722:    int32 Status = CFE_SUCCESS;
        -:  723:    int32 PoolOffset;
        -:  724:    
        -:  725:    /* First, determine if the CDS registry stored in the CDS is smaller or equal */
        -:  726:    /* in size to the CDS registry we are currently configured for                */
        -:  727:    /* Copy the number of registry entries to the CDS */
        5:  728:    Status = CFE_PSP_ReadFromCDS(&CFE_ES_Global.CDSVars.MaxNumRegEntries, 
        -:  729:                               CDS_REG_SIZE_OFFSET, 
        -:  730:                               sizeof(CFE_ES_Global.CDSVars.MaxNumRegEntries));
        -:  731:                               
        5:  732:    if (CFE_ES_Global.CDSVars.MaxNumRegEntries <= CFE_ES_CDS_MAX_NUM_ENTRIES)
        -:  733:    {
        2:  734:        Status = CFE_PSP_ReadFromCDS(&CFE_ES_Global.CDSVars.Registry,
        -:  735:                                   CDS_REG_OFFSET,
        -:  736:                                   (CFE_ES_Global.CDSVars.MaxNumRegEntries * sizeof(CFE_ES_CDS_RegRec_t)));
        -:  737:                            
        2:  738:        if (Status == OS_SUCCESS)
        -:  739:        {
        -:  740:            /* Calculate the starting offset of the memory pool */
        1:  741:            PoolOffset = (CDS_REG_OFFSET + (CFE_ES_Global.CDSVars.MaxNumRegEntries * sizeof(CFE_ES_CDS_RegRec_t)) + 3) & 0xfffffffc;;
        -:  742:
        -:  743:            /* Calculate the size of the memory pool */
        1:  744:            CFE_ES_Global.CDSVars.MemPoolSize = CFE_ES_Global.CDSVars.CDSSize - PoolOffset - sizeof(CFE_ES_Global.CDSVars.ValidityField);
        -:  745:            
        -:  746:            /* Scan the memory pool and identify the created but currently unused memory blocks */
        1:  747:            Status = CFE_ES_RebuildCDSPool(CFE_ES_Global.CDSVars.MemPoolSize, PoolOffset);
        -:  748:        }
        -:  749:        else
        -:  750:        {
        -:  751:            /* Registry in CDS is unreadable */
        1:  752:            Status = CFE_ES_CDS_INVALID;
        1:  753:            CFE_ES_WriteToSysLog("CFE_CDS:Rebuild-Registry in CDS is unreadable\n");
        -:  754:        }
        -:  755:    }
        -:  756:    else
        -:  757:    {
        -:  758:        /* Registry in CDS is too large to recover */
        3:  759:        Status = CFE_ES_CDS_INVALID;
        3:  760:        CFE_ES_WriteToSysLog("CFE_CDS:Rebuild-Registry in CDS too large to recover\n");
        -:  761:    }
        -:  762:           
        5:  763:    return Status;    
        -:  764:}
        -:  765:
        -:  766:
        -:  767:/*******************************************************************
        -:  768:**
        -:  769:** CFE_ES_DeleteCDS
        -:  770:**
        -:  771:** NOTE: For complete prolog information, see 'cfe_es_cds.h'
        -:  772:********************************************************************/
        -:  773:
        -:  774:int32 CFE_ES_DeleteCDS(const char *CDSName, boolean CalledByTblServices)
        9:  775:{
        -:  776:    int32                Status;
        -:  777:    int32                RegIndx;
        9:  778:    CFE_ES_CDS_RegRec_t *RegRecPtr = NULL;
        -:  779:    char                 OwnerName[OS_MAX_API_NAME];
        -:  780:    uint32               AppId;
        -:  781:    uint32               i;
        -:  782:    
        -:  783:    /* Lock Registry for update.  This prevents two applications from */
        -:  784:    /* trying to change the CDS registry at the same time  */
        9:  785:    CFE_ES_LockCDSRegistry();
        -:  786:
        -:  787:    /* Find CDS name in registry */
        9:  788:    RegIndx = CFE_ES_FindCDSInRegistry(CDSName);
        -:  789:
        -:  790:    /* Check to see if CDS is already in the registry */
        9:  791:    if (RegIndx != CFE_ES_CDS_NOT_FOUND)
        -:  792:    {
        -:  793:        /* Get pointer to Registry Record Entry to speed up processing */
        8:  794:        RegRecPtr = &CFE_ES_Global.CDSVars.Registry[RegIndx];
        -:  795:        
        -:  796:        /* Critical tables are not allowed to be deleted via an ES Command. */
        -:  797:        /* They must be deleted by a Table Services Command */
        8:  798:        if (RegRecPtr->Table != CalledByTblServices)
        -:  799:        {
        3:  800:            Status = CFE_ES_CDS_WRONG_TYPE_ERR;
        -:  801:        }
        -:  802:        else
        -:  803:        {
        -:  804:            /* Check to see if the owning application is still active */
        -:  805:            /* First, extract the owning application name */
        5:  806:            i=0;
       40:  807:            while ((RegRecPtr->Name[i] != '.') && (i < (OS_MAX_API_NAME-1)))
        -:  808:            {
       30:  809:                OwnerName[i] = RegRecPtr->Name[i];
       30:  810:                i++;
        -:  811:            }
        -:  812:            
        -:  813:            /* Null terminate the application name */
        5:  814:            OwnerName[i] = '\0';
        -:  815:            
        -:  816:            /* Check to see if the Application Name is in the Registered Apps list */
        5:  817:            Status = CFE_ES_GetAppIDByName(&AppId, OwnerName);
        -:  818:            
        -:  819:            /* If we can't find the name, then things are good */
        5:  820:            if (Status == CFE_ES_ERR_APPNAME)
        -:  821:            {
        -:  822:                /* Free the registry entry and the CDS memory block associated with it */
        3:  823:                Status = CFE_ES_PutCDSBlock(RegRecPtr->MemHandle);
        -:  824:    
        -:  825:                /* Report any errors incurred while freeing the CDS Memory Block */
        3:  826:                if (Status < 0)
        -:  827:                {
        1:  828:                    CFE_ES_WriteToSysLog("CFE_ES:DeleteCDS-Failed to free CDS Mem Block (Handle=0x%08X)(Stat=0x%08X)\n",
        -:  829:                                         RegRecPtr->MemHandle, Status);
        -:  830:                }
        -:  831:                else
        -:  832:                {
        -:  833:                    /* Remove entry from the CDS Registry */
        2:  834:                    RegRecPtr->Taken = FALSE;
        -:  835:        
        2:  836:                    Status = CFE_ES_UpdateCDSRegistry();
        -:  837:            
        2:  838:                    if (Status != CFE_SUCCESS)
        -:  839:                    {
        1:  840:                        CFE_ES_WriteToSysLog("CFE_ES:DeleteCDS-Failed to update CDS Registry (Stat=0x%08X)\n", Status);
        -:  841:                    }
        -:  842:                }
        -:  843:            }
        -:  844:            else
        -:  845:            {
        2:  846:                Status = CFE_ES_CDS_OWNER_ACTIVE_ERR;
        -:  847:            }
        -:  848:        }
        -:  849:    }
        -:  850:    else  /* Error - CDS not in registry */
        -:  851:    {
        1:  852:        Status = CFE_ES_CDS_NOT_FOUND_ERR;
        -:  853:    }
        -:  854:
        -:  855:    /* Unlock Registry for future updates */
        9:  856:    CFE_ES_UnlockCDSRegistry();
        -:  857:
        9:  858:    return Status;
        -:  859:}   /* End of CFE_ES_DeleteCDS() */
        -:  860:
        -:  861:/* end of file */
