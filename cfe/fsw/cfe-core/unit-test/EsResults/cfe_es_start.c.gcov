        -:    0:Source:/home/acudmore/Projects/cFE-6.4-development/cfe/fsw/cfe-core/src/es/cfe_es_start.c
        -:    0:Programs:10
        -:    1:/*
        -:    2:**  File: 
        -:    3:**  cfe_es_start.c
        -:    4:**
        -:    5:**
        -:    6:**
        -:    7:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    8:**      administrator of the National Aeronautics Space Administration.  
        -:    9:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:   10:**      Space Flight Center pursuant to government contracts.
        -:   11:**
        -:   12:**      This is governed by the NASA Open Source Agreement and may be used, 
        -:   13:**      distributed and modified only pursuant to the terms of that agreement.
        -:   14:**
        -:   15:**  Purpose:
        -:   16:**  This file contains the Main entrypoint and startup code for the cFE core.
        -:   17:**  The entry point is called by the board support package for the OS. When the
        -:   18:**  entry point is finished, the cFE should be fully initialized and running.
        -:   19:**
        -:   20:**  References:
        -:   21:**     Flight Software Branch C Coding Standard Version 1.0a
        -:   22:**     cFE Flight Software Application Developers Guide
        -:   23:**
        -:   24:**  $Log: cfe_es_start.c.gcov  $
        -:   24:**  Revision 1.5 2014/09/23 15:04:44GMT-05:00 acudmore 
        -:   24:**  Updated ES unit test results for cFE build 6.4.0
        -:   25:**  Revision 1.16 2014/09/05 11:39:05GMT-05:00 acudmore 
        -:   26:**  Updated CFE_ES_SetupResetVariables to correctly log the Boot Source ( bank ) and clarify ERLog and Syslog text for restarts.
        -:   27:**  Revision 1.15 2014/08/22 15:50:11GMT-05:00 lwalling 
        -:   28:**  Changed signed loop counters to unsigned
        -:   29:**  Revision 1.14 2014/07/23 15:39:42EDT acudmore 
        -:   30:**  Changed where processor reset count is incremented to make it more consistent.
        -:   31:**  Removed 2nd ERLog entry when a processor reset reverts to a power on reset.
        -:   32:**  Clarified ERlog entry text.
        -:   33:**  Revision 1.13 2012/10/01 16:29:46GMT-05:00 aschoeni 
        -:   34:**  Fixed missing parenthesis issue
        -:   35:**  Revision 1.12 2012/07/16 16:18:21EDT lwalling 
        -:   36:**  Added code to release stuck startup sync semaphore
        -:   37:**  Revision 1.11 2012/01/13 08:50:04PST acudmore 
        -:   38:**  Changed license text to reflect open source
        -:   39:**  Revision 1.10 2010/11/08 12:33:04EST acudmore 
        -:   40:**  Updated logic that checks for max processor reset count during a non-cfe caused reset ( watchdog ).
        -:   41:**  Revision 1.9 2010/11/05 15:54:34EDT aschoeni 
        -:   42:**  Added Generic Counter API to ES
        -:   43:**  Revision 1.8 2010/11/04 14:05:56EDT acudmore 
        -:   44:**  Added ram disk mount path configuration option.
        -:   45:**  Revision 1.7 2010/09/21 15:52:17EDT jmdagost 
        -:   46:**  Replaced syslog argument RetStatus with BlocksFree.
        -:   47:**  Revision 1.6 2009/07/30 16:06:55EDT acudmore 
        -:   48:**  Fixed check for blocks free in RAM disk ( > vs >= )
        -:   49:**  Revision 1.5 2009/07/28 16:33:19EDT jmdagost 
        -:   50:**  Replaced 3 references to filename with references to function name.
        -:   51:**  Revision 1.4 2009/06/10 09:09:01EDT acudmore 
        -:   52:**  Converted OS_Mem* and OS_BSP* API to CFE_PSP_* API
        -:   53:**  Revision 1.3 2008/07/30 14:53:30EDT apcudmore 
        -:   54:**  Updated init code for startup sync support.
        -:   55:**  Revision 1.2 2008/06/20 15:40:32EDT apcudmore 
        -:   56:**  Added support for OSAL based module loader
        -:   57:**   - Removed calls and references to the BSP based module loader
        -:   58:**  Revision 1.1 2008/04/17 08:05:08EDT ruperera 
        -:   59:**  Initial revision
        -:   60:**  Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/src/es/project.pj
        -:   61:**  Revision 1.46 2007/09/21 15:40:20EDT David Kobe (dlkobe) 
        -:   62:**  Modified pointer type definitions to eliminate Linux gcc compile warnings
        -:   63:**  Revision 1.45 2007/05/31 10:13:56EDT apcudmore 
        -:   64:**  Fixed Syslog message text for Volatile Disk initialization
        -:   65:**  Revision 1.44 2007/05/30 10:26:06EDT apcudmore 
        -:   66:**  Added Exception handler support:
        -:   67:**   - BSP routine to attach processor exceptions
        -:   68:**   - context datatype and size define
        -:   69:**   - added default exception init for each app+task
        -:   70:**  Revision 1.43 2007/05/25 14:20:10EDT apcudmore 
        -:   71:**  Fixed compiler warnings
        -:   72:**  Revision 1.42 2007/05/25 10:38:12EDT apcudmore 
        -:   73:**  Added OS_rmfs call to remove file system before reformatting it.
        -:   74:**  Revision 1.41 2007/05/25 10:02:42EDT apcudmore 
        -:   75:**  Fixed Typo and Moved WriteToSysLog call
        -:   76:**  Revision 1.40 2007/05/24 15:09:23EDT apcudmore 
        -:   77:**  App-Decompression updates:
        -:   78:**    - Added verify macros for PERCENT_FREE config parameter
        -:   79:**    - Updated comments in config files
        -:   80:**    - Updated logic to turn off check if RAM_DISK_PERCENT_FREE is 0
        -:   81:**  Revision 1.39 2007/05/24 10:57:48EDT apcudmore 
        -:   82:**  Application Decompression Support:
        -:   83:**   - Added configuration parameter for Percent of space free in Volatile disk on a P.R.
        -:   84:**   - Added logic to check for amount of free space and reformat RAM disk if needed on a P.R.
        -:   85:**   - Fixed warnings in decompression code.
        -:   86:**  Revision 1.38 2007/05/22 14:56:55EDT apcudmore 
        -:   87:**  cFE Non-Volatile Disk/Startup File changes:
        -:   88:**    - cFE startup now passes in startup file path/name
        -:   89:**    - cFE startup code does not init non-volatile disk ( BSP does )
        -:   90:**    - BSPs now can map cFE paths without making the OS_initfs/OS_mount calls
        -:   91:**    - MCP750 vxWorks6.2 BSP inits/mounts CF disk
        -:   92:**    - Desktop ports pass in the same startup file path/name as before
        -:   93:**  Revision 1.37 2007/05/07 15:56:32EDT apcudmore 
        -:   94:**  Removed all ES startup semaphore code
        -:   95:**  Removed all ES startup delays.
        -:   96:**  Startup sync problems ( seem to be ) eliminated by protecting the ES global data tables with a mutex.
        -:   97:**  Revision 1.36 2007/05/04 15:58:36EDT apcudmore 
        -:   98:**  Implemented ES shared data protection. Eliminates Startup syncronization problem.
        -:   99:**  Revision 1.35 2007/04/13 16:28:52EDT apcudmore 
        -:  100:**  Changed function prototype to return int32 status on the ES Object table functions. 
        -:  101:**  ES will now call OS_BSPPanic when the function returns something other than CFE_SUCCESS
        -:  102:**  Revision 1.34 2007/04/10 13:50:46EDT rjmcgraw 
        -:  103:**  Renamed function setupAnalyzerVariables to SetupPerfVariables
        -:  104:**  Revision 1.33 2007/03/29 13:29:16EST apcudmore 
        -:  105:**  Updated global variables and housekeeping to count:
        -:  106:**  - Registered Core Apps
        -:  107:**  - Registered External Apps
        -:  108:**  - ALL Tasks 
        -:  109:**  Revision 1.32 2007/03/22 10:26:23EST apcudmore 
        -:  110:**  Implemented all code walkthrough items related to ES Application logic, commands, 
        -:  111:**  and telemetry.
        -:  112:**  Revision 1.31 2007/03/13 14:32:37EST apcudmore 
        -:  113:**  Fixed ES Startup code walkthrough items.
        -:  114:*/
        -:  115:
        -:  116:/*
        -:  117:** Includes
        -:  118:*/
        -:  119:
        -:  120:#include "cfe.h"
        -:  121:#include "cfe_platform_cfg.h"
        -:  122:#include "cfe_es.h"
        -:  123:#include "cfe_es_global.h"       
        -:  124:#include "cfe_es_start.h" 
        -:  125:#include "cfe_es_apps.h"
        -:  126:#include "cfe_es_log.h"
        -:  127:#include "cfe_psp.h"
        -:  128:
        -:  129:#include <stdio.h>
        -:  130:#include <string.h>
        -:  131:
        -:  132:/***************************************************************************/
        -:  133:
        -:  134:/*
        -:  135:** Defines for this module
        -:  136:*/
        -:  137:
        -:  138:/* 
        -:  139:** Number of msecs to delay before exiting cFE. Allows LogMsg to get through 
        -:  140:*/
        -:  141:#define CFE_ES_PANIC_DELAY  500
        -:  142:
        -:  143:
        -:  144:/*
        -:  145:** Global data for the ES startup code and Runtime library
        -:  146:*/
        -:  147:CFE_ES_Global_t     CFE_ES_Global;
        -:  148:
        -:  149:/*
        -:  150:** Pointer to the Reset data that is preserved on a processor reset
        -:  151:*/
        -:  152:CFE_ES_ResetData_t  *CFE_ES_ResetDataPtr;
        -:  153:
        -:  154:
        -:  155:/***************************************************************************/
        -:  156:
        -:  157:/*
        -:  158:** Code
        -:  159:*/
        -:  160:
        -:  161:/*
        -:  162:** Name: CFE_ES_Main
        -:  163:** Purpose: This is the entry point to the cFE application code.
        -:  164:**
        -:  165:*/
        5:  166:void CFE_ES_Main(uint32 StartType, uint32 StartSubtype, uint32 ModeId, uint8 *StartFilePath )
        -:  167:{
        -:  168:   uint32 i;
        -:  169:   int32 ReturnCode;
        -:  170:
        -:  171:   /*
        -:  172:   ** Initialize the Reset variables. This call is required
        -:  173:   ** Before most of the ES functions can be used including the 
        -:  174:   ** ES System log.
        -:  175:   */
        5:  176:   CFE_ES_SetupResetVariables(StartType, StartSubtype, ModeId);
        -:  177:
        -:  178:   /*
        -:  179:   ** Initialize the Logic Perf variables
        -:  180:   ** Because this is in the ES Reset area, it must be called after
        -:  181:   ** CFE_ES_SetupResetVariables.
        -:  182:   */
        5:  183:   CFE_ES_SetupPerfVariables(StartType);
        -:  184:
        -:  185:   /*
        -:  186:   ** Announce the startup
        -:  187:   */
        5:  188:   CFE_ES_WriteToSysLog("ES Startup: CFE_ES_Main started\n");
        -:  189:
        -:  190:   /*
        -:  191:   ** Create and Mount the filesystems needed
        -:  192:   */
        5:  193:   CFE_ES_InitializeFileSystems(StartType);
        -:  194:   
        -:  195:   /*
        -:  196:   ** Install exception Handlers ( Placeholder )
        -:  197:   */
        5:  198:   CFE_PSP_AttachExceptions();
        -:  199:
        -:  200:   /*
        -:  201:   ** Initialize the ES Application Table
        -:  202:   ** to mark all entries as unused.
        -:  203:   */
      165:  204:   for ( i = 0; i < CFE_ES_MAX_APPLICATIONS; i++ )
        -:  205:   {
      160:  206:      CFE_ES_Global.AppTable[i].RecordUsed = FALSE;
        -:  207:   }
        -:  208:   
        -:  209:   /*
        -:  210:   ** Initialize the ES Task Table
        -:  211:   ** to mark all entries as unused.
        -:  212:   */
      325:  213:   for ( i = 0; i < OS_MAX_TASKS; i++ )
        -:  214:   {
      320:  215:      CFE_ES_Global.TaskTable[i].RecordUsed = FALSE;
        -:  216:   }
        -:  217:
        -:  218:   /*
        -:  219:   ** Initialize the ES Generic Counter Table
        -:  220:   ** to mark all entries as unused.
        -:  221:   */
       45:  222:   for ( i = 0; i < CFE_ES_MAX_GEN_COUNTERS; i++ )
        -:  223:   {
       40:  224:      CFE_ES_Global.CounterTable[i].RecordUsed = FALSE;
        -:  225:   }
        -:  226:
        -:  227:   /*
        -:  228:   ** Create the ES Shared Data Mutex
        -:  229:   */
        5:  230:   ReturnCode = OS_MutSemCreate(&(CFE_ES_Global.SharedDataMutex), "ES_DATA_MUTEX", 0 );
        5:  231:   if(ReturnCode != OS_SUCCESS)
        -:  232:   {
        1:  233:      CFE_ES_WriteToSysLog("ES Startup: Error: ES Shared Data Mutex could not be created. RC=0x%08X\n",
        -:  234:                            ReturnCode);
        -:  235:         
        -:  236:      /*
        -:  237:      ** Delay to allow the message to be read
        -:  238:      */
        1:  239:      OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  240:      
        -:  241:      /* 
        -:  242:      ** cFE Cannot continue to start up. 
        -:  243:      */
        1:  244:      CFE_PSP_Panic(CFE_PSP_PANIC_STARTUP_SEM);
        -:  245:         
        -:  246:   } /* end if */
        -:  247:
        -:  248:   /*
        -:  249:   ** Create the ES Startup Sync Semaphore
        -:  250:   */
        5:  251:   ReturnCode = OS_BinSemCreate(&(CFE_ES_Global.StartupSyncSemaphore),"ES_SYNC_SEM", 0, 0 );
        5:  252:   if(ReturnCode != OS_SUCCESS)
        -:  253:   {
        1:  254:      CFE_ES_WriteToSysLog("ES Startup: Error: ES Startup Sync Semaphore could not be created. RC=0x%08X\n",
        -:  255:                            ReturnCode);
        -:  256:         
        -:  257:      /*
        -:  258:      ** Delay to allow the message to be read
        -:  259:      */
        1:  260:      OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  261:      
        -:  262:      /* 
        -:  263:      ** cFE Cannot continue to start up. 
        -:  264:      */
        1:  265:      CFE_PSP_Panic(CFE_PSP_PANIC_STARTUP_SEM);
        -:  266:         
        -:  267:   } /* end if */
        -:  268:
        -:  269:
        -:  270:   /*
        -:  271:   ** Create the tasks, OS objects, and initialize hardware
        -:  272:   */
        5:  273:   CFE_ES_CreateObjects();
        -:  274:
        -:  275:   /*
        -:  276:   ** Before the Applications are loaded, set up the state
        -:  277:   ** variables that allow the startup syncronization to work.
        -:  278:   ** This depends on a couple of things:
        -:  279:   **  1. The fact that the cFE applications all use the CFE_ES_RunLoop Call
        -:  280:   **  2. The StartupSyncSemaphore has been created ( see above )
        -:  281:   **  3. The App(s) that wish to wait calls CFE_ES_WaitForStartupSync
        -:  282:   */
        5:  283:   CFE_ES_Global.AppStartupCounter = 0;
        5:  284:   CFE_ES_Global.StartupFileComplete = FALSE;
        5:  285:   CFE_ES_Global.StartupSemaphoreReleased = FALSE;
        -:  286:   
        -:  287:   /*
        -:  288:   ** Start the cFE Applications from the disk using the file
        -:  289:   ** specified in the CFE_ES_NONVOL_STARTUP_FILE or CFE_ES_VOLATILE_STARTUP_FILE 
        -:  290:   ** ( defined in the cfe_platform_cfg.h file )
        -:  291:   */   
        5:  292:   CFE_ES_StartApplications(StartType, StartFilePath );
        -:  293:
        -:  294:   /*
        -:  295:   ** Indicate that the startup file is complete. This avoids
        -:  296:   ** certain race conditions.
        -:  297:   */
        5:  298:   CFE_ES_Global.StartupFileComplete = TRUE;
        -:  299:
        -:  300:   /*
        -:  301:   ** Check for "stuck" startup sync semaphore
        -:  302:   */
        5:  303:   CFE_ES_LockSharedData(__func__,__LINE__);
        5:  304:   if (( CFE_ES_Global.StartupSemaphoreReleased == FALSE) && ( CFE_ES_Global.AppStartupCounter <= 0 ))
        -:  305:   {
    #####:  306:      CFE_ES_Global.AppStartupCounter = 0;
    #####:  307:      CFE_ES_Global.StartupSemaphoreReleased = TRUE;
    #####:  308:      OS_BinSemFlush(CFE_ES_Global.StartupSyncSemaphore);  
        -:  309:   }
        5:  310:   CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  311:
        -:  312:   /*
        -:  313:   ** Startup is complete
        -:  314:   */
        5:  315:   CFE_ES_WriteToSysLog("ES Startup: CFE Core Startup Complete\n");
        5:  316:}
        -:  317:
        -:  318:/*
        -:  319:** Name: CFE_ES_SetupResetVariables
        -:  320:**
        -:  321:** Purpose: This function initializes the ES reset variables depending on the reset type.
        -:  322:**          It will also initiate a power on reset when too many processor resets
        -:  323:**           have happened.
        -:  324:**
        -:  325:*/
       12:  326:void CFE_ES_SetupResetVariables(uint32 StartType, uint32 StartSubtype, uint32 BootSource )
        -:  327:{
        -:  328:
        -:  329:   int32  status;
        -:  330:   uint32 resetAreaSize;
        -:  331:   
        -:  332:   /*
        -:  333:   ** Get the pointer to the Reset area from the BSP
        -:  334:   */
       12:  335:   status = CFE_PSP_GetResetArea (&(CFE_ES_ResetDataPtr), &(resetAreaSize));
        -:  336:      
        -:  337:   /*
        -:  338:   ** Make sure the status is OK or size is big enough
        -:  339:   */
       12:  340:   if ( status == OS_ERROR )
        -:  341:   {
        -:  342:      /*
        -:  343:      ** Cannot use the ES System log without the Reset Area
        -:  344:      */
        1:  345:      OS_printf("ES Startup: CFE_PSP_GetResetArea call Failed!\n");
        -:  346:      
        -:  347:      /*
        -:  348:      ** Delay to allow the message to be read
        -:  349:      */
        1:  350:      OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  351:      
        -:  352:      /* 
        -:  353:      ** cFE Cannot continue to start up. 
        -:  354:      */
        1:  355:      CFE_PSP_Panic(CFE_PSP_PANIC_MEMORY_ALLOC);
        -:  356:      
        -:  357:   }
       11:  358:   else if ( resetAreaSize < sizeof(CFE_ES_ResetData_t))
        -:  359:   {
        -:  360:      /*
        -:  361:      ** Cannot use the ES system log without the Reset Area
        -:  362:      */
        1:  363:      OS_printf("ES Startup: Error: ES Reset area not big enough. Needed: %d, Given: %d.\n",
        -:  364:              sizeof(CFE_ES_ResetData_t),
        -:  365:              resetAreaSize);      
        -:  366:      /*
        -:  367:      ** Delay to allow the message to be read
        -:  368:      */
        1:  369:      OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  370:      
        -:  371:      /* 
        -:  372:      ** cFE Cannot continue to start up. 
        -:  373:      */
        1:  374:      CFE_PSP_Panic(CFE_PSP_PANIC_MEMORY_ALLOC);
        -:  375:      
        -:  376:   }
        -:  377:
        -:  378:   /*
        -:  379:   ** Record the BootSource (bank) so it will be valid in the ER log entries.
        -:  380:   */
       12:  381:   CFE_ES_ResetDataPtr->ResetVars.BootSource   = BootSource;
        -:  382:
        -:  383:   /*
        -:  384:   ** Determine how the system was started. The choices are:
        -:  385:   **   CFE_ES_POWER_ON_RESET, or CFE_ES_PROCESSOR_RESET
        -:  386:   ** The subtypes include:
        -:  387:   **   CFE_ES_POWER_CYCLE, CFE_ES_PUSH_BUTTON, CFE_ES_HW_SPECIAL_COMMAND,
        -:  388:   **   CFE_ES_HW_WATCHDOG, CFE_ES_RESET_COMMAND, or CFE_ES_EXCEPTION.
        -:  389:   ** Some of these reset types are logged before the system is restarted.
        -:  390:   **  ( CFE_ES_RESET_COMMAND, CFE_ES_EXCEPTION ) while others occur
        -:  391:   **  without the knowledge of the software and must be logged here.
        -:  392:   */
       12:  393:   if ( StartType == CFE_ES_POWERON_RESET )
        -:  394:   {
        -:  395:      /*
        -:  396:      ** Record the reset type and subtype
        -:  397:      */
        5:  398:      CFE_ES_ResetDataPtr->ResetVars.ResetSubtype = StartSubtype;
        5:  399:      CFE_ES_ResetDataPtr->ResetVars.ResetType = CFE_ES_POWERON_RESET;
        -:  400:
        -:  401:      /*
        -:  402:      ** Log the power-on reset. 
        -:  403:      */
        5:  404:      if ( StartSubtype == CFE_ES_POWER_CYCLE )
        -:  405:      {
        3:  406:         CFE_ES_WriteToSysLog("POWER ON RESET due to Power Cycle (Power Cycle).\n");
        3:  407:         status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_POWERON_RESET, StartSubtype,
        -:  408:                                    "POWER ON RESET due to Power Cycle (Power Cycle)", NULL,0 );
        -:  409:      }
        2:  410:      else if ( StartSubtype == CFE_ES_HW_SPECIAL_COMMAND )
        -:  411:      {
        1:  412:         CFE_ES_WriteToSysLog("POWER ON RESET due to HW Special Cmd (Hw Spec Cmd).\n");
        1:  413:         status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_POWERON_RESET, StartSubtype,
        -:  414:                                    "POWER ON RESET due to HW Special Cmd (Hw Spec Cmd)", NULL,0 );
        -:  415:      }
        -:  416:      else
        -:  417:      {
        1:  418:         CFE_ES_WriteToSysLog("POWER ON RESET due to other cause (See Subtype).\n");
        1:  419:         status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_POWERON_RESET, StartSubtype,
        -:  420:                                    "POWER ON RESET due to other cause (See Subtype)", NULL,0 );
        -:  421:      }
        -:  422:
        -:  423:      /*
        -:  424:      ** Initialize all reset counters.
        -:  425:      */
        5:  426:      CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount = 0;
        5:  427:      CFE_ES_ResetDataPtr->ResetVars.MaxProcessorResetCount = CFE_ES_MAX_PROCESSOR_RESETS;
        5:  428:      CFE_ES_Global.DebugVars.DebugFlag = 0;
        -:  429:      
        -:  430:   }
        7:  431:   else if ( StartType == CFE_ES_PROCESSOR_RESET )
        -:  432:   {
        -:  433:      /*
        -:  434:      ** If a Processor reset was not commanded, it must be a watchdog or other non-commanded reset
        -:  435:      ** Log the reset before updating any reset variables.
        -:  436:      */
        7:  437:      if ( CFE_ES_ResetDataPtr->ResetVars.ES_CausedReset != TRUE )
        -:  438:      {
        6:  439:         CFE_ES_ResetDataPtr->ResetVars.ResetType = CFE_ES_PROCESSOR_RESET;
        6:  440:         CFE_ES_ResetDataPtr->ResetVars.ResetSubtype = StartSubtype; 
        6:  441:         CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount++;
        -:  442:         
        -:  443:         /*
        -:  444:         ** When coming up from a Processor reset that was not caused by ES, check to see 
        -:  445:         ** if the maximum number has been exceeded
        -:  446:         */
       12:  447:         if ( CFE_ES_ResetDataPtr->ResetVars.ProcessorResetCount > 
        6:  448:              CFE_ES_ResetDataPtr->ResetVars.MaxProcessorResetCount )
        -:  449:         {
        3:  450:             if ( StartSubtype == CFE_ES_HW_SPECIAL_COMMAND )
        -:  451:             {
        1:  452:                 CFE_ES_ResetDataPtr->ResetVars.ResetSubtype = CFE_ES_HW_SPECIAL_COMMAND;
        1:  453:                 CFE_ES_WriteToSysLog("POWER ON RESET due to max proc resets (HW Spec Cmd).\n");
        -:  454:
        -:  455:                 /*
        -:  456:                 ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -:  457:                 ** the entry just in case something fails.
        -:  458:                 */
        1:  459:                 status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_POWERON_RESET, StartSubtype,
        -:  460:                                       "POWER ON RESET due to max proc resets (HW Spec Cmd).", NULL,0 );
        -:  461:             }
        -:  462:             else
        -:  463:             {
        2:  464:                 CFE_ES_ResetDataPtr->ResetVars.ResetSubtype = CFE_ES_HW_WATCHDOG;
        2:  465:                 CFE_ES_WriteToSysLog("POWER ON RESET due to max proc resets (Watchdog).\n");
        -:  466:
        -:  467:                 /*
        -:  468:                 ** Log the reset in the ER Log. The log will be wiped out, but it's good to have
        -:  469:                 ** the entry just in case something fails.
        -:  470:                 */
        2:  471:                 status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_POWERON_RESET, StartSubtype,
        -:  472:                                       "POWER ON RESET due to max proc resets (Watchdog).", NULL,0 );
        -:  473:             } 
        -:  474:             /*
        -:  475:             ** Call the BSP reset routine 
        -:  476:             */
        3:  477:             CFE_PSP_Restart(CFE_ES_POWERON_RESET);
        -:  478:             
        -:  479:             /*
        -:  480:             ** Should not return here.
        -:  481:             */
        3:  482:             CFE_ES_WriteToSysLog("ES Startup: Error: CFE_PSP_Restart returned.\n");
        -:  483:           
        -:  484:         }
        -:  485:         else /* Maximum processor reset not exceeded */
        -:  486:         {
        3:  487:             if ( StartSubtype == CFE_ES_HW_SPECIAL_COMMAND )
        -:  488:             {
        1:  489:                CFE_ES_ResetDataPtr->ResetVars.ResetSubtype = CFE_ES_HW_SPECIAL_COMMAND;
        1:  490:                CFE_ES_WriteToSysLog("PROCESSOR RESET due to Hardware Special Command (HW Spec Cmd).\n");
        -:  491:
        -:  492:                /*
        -:  493:                ** Log the watchdog reset 
        -:  494:                */
        1:  495:                status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_PROCESSOR_RESET, StartSubtype,
        -:  496:                                       "PROCESSOR RESET due to Hardware Special Command (Hw Spec Cmd).", NULL,0 );
        -:  497: 
        -:  498:             }
        -:  499:             else
        -:  500:             {
        2:  501:                CFE_ES_ResetDataPtr->ResetVars.ResetSubtype = CFE_ES_HW_WATCHDOG;
        2:  502:                CFE_ES_WriteToSysLog("PROCESSOR RESET due to Watchdog (Watchdog).\n");
        -:  503:
        -:  504:                /*
        -:  505:                ** Log the watchdog reset 
        -:  506:                */
        2:  507:                status =  CFE_ES_WriteToERLog(CFE_ES_CORE_LOG_ENTRY, CFE_ES_PROCESSOR_RESET, StartSubtype,
        -:  508:                                       "PROCESSOR RESET due to Watchdog (Watchdog).", NULL,0 );
        -:  509:
        -:  510:             }
        -:  511: 
        -:  512:         } /* end if */
        -:  513:         
        -:  514:      }
        -:  515:      /*
        -:  516:      ** If a processor reset is due to a command or exception, the reset has already been logged.
        -:  517:      ** Update the reset variables only.
        -:  518:      ** The logic for detecting maximum resets is done on the command/exception side
        -:  519:      ** on the "way down" when the command or exception handler is executed.
        -:  520:      */
        -:  521:      else
        -:  522:      {
        1:  523:         CFE_ES_ResetDataPtr->ResetVars.ResetType    = CFE_ES_PROCESSOR_RESET;
        1:  524:         CFE_ES_ResetDataPtr->ResetVars.ResetSubtype = StartSubtype;
        -:  525:      }
        -:  526:
        -:  527:      /*
        -:  528:      ** Initialize processor reset counters.
        -:  529:      */
        7:  530:      CFE_ES_Global.DebugVars.DebugFlag = 0;
        -:  531:   }
        -:  532:   
        -:  533:   /*
        -:  534:   ** Clear the commanded reset flag, in case a watchdog happens.
        -:  535:   */
       12:  536:   CFE_ES_ResetDataPtr->ResetVars.ES_CausedReset = FALSE;
        -:  537:      
       12:  538:}
        -:  539:
        -:  540:/*
        -:  541:** Name: CFE_ES_InitializeFileSystems
        -:  542:**
        -:  543:** Purpose: This function initializes the file systems used in the cFE core.
        -:  544:**
        -:  545:*/
       14:  546:void CFE_ES_InitializeFileSystems(uint32 start_type)
        -:  547:{
        -:  548:   int32   RetStatus;
        -:  549:   uint32 *RamDiskMemoryAddress;
        -:  550:   uint32  RamDiskMemorySize;
        -:  551:   int32   BlocksFree;
        -:  552:   int32   PercentFree;
        -:  553: 
        -:  554:   /* 
        -:  555:   ** Get the memory area for the RAM disk 
        -:  556:   */
       14:  557:   RetStatus = CFE_PSP_GetVolatileDiskMem(&(RamDiskMemoryAddress), &(RamDiskMemorySize));
        -:  558:
       14:  559:   if ( RetStatus != OS_FS_SUCCESS )
        -:  560:   {
        1:  561:      CFE_ES_WriteToSysLog("ES Startup: Cannot Get Memory for Volatile Disk. EC = 0x%08X\n",RetStatus);
        -:  562:
        -:  563:      /*
        -:  564:      ** Delay to allow the message to be read
        -:  565:      */
        1:  566:      OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  567:      
        -:  568:      /* 
        -:  569:      ** cFE Cannot continue to start up.  
        -:  570:      */
        1:  571:      CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  572:
        -:  573:   }      
        -:  574:   
        -:  575:   /*
        -:  576:   ** Next, either format, or just initialize the RAM disk depending on
        -:  577:   ** the reset type
        -:  578:   */
       14:  579:   if ( start_type == CFE_ES_POWERON_RESET )
        -:  580:   {
        6:  581:      RetStatus = OS_mkfs((void *)RamDiskMemoryAddress, "/ramdev0", "RAM", CFE_ES_RAM_DISK_SECTOR_SIZE, CFE_ES_RAM_DISK_NUM_SECTORS );
        6:  582:      if ( RetStatus != OS_FS_SUCCESS )
        -:  583:      {
        1:  584:         CFE_ES_WriteToSysLog("ES Startup: Error Creating Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        -:  585:
        -:  586:         /*
        -:  587:         ** Delay to allow the message to be read
        -:  588:         */
        1:  589:         OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  590:      
        -:  591:         /* 
        -:  592:         ** cFE Cannot continue to start up.  
        -:  593:         */
        1:  594:         CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  595:      }
        -:  596:   }
        -:  597:   else
        -:  598:   {
        8:  599:      RetStatus = OS_initfs((void *)RamDiskMemoryAddress, "/ramdev0", "RAM", CFE_ES_RAM_DISK_SECTOR_SIZE, CFE_ES_RAM_DISK_NUM_SECTORS );
        8:  600:      if ( RetStatus != OS_FS_SUCCESS )
        -:  601:      {
        1:  602:         CFE_ES_WriteToSysLog("ES Startup: Error Initializing Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        1:  603:         CFE_ES_WriteToSysLog("ES Startup: Formatting Volatile(RAM) Volume.\n");
        -:  604:         
        1:  605:         RetStatus = OS_mkfs((void *)RamDiskMemoryAddress, "/ramdev0", "RAM", CFE_ES_RAM_DISK_SECTOR_SIZE, CFE_ES_RAM_DISK_NUM_SECTORS );
        1:  606:         if ( RetStatus != OS_SUCCESS )
        -:  607:         {
        1:  608:            CFE_ES_WriteToSysLog("ES Startup: Error Creating Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        -:  609:
        -:  610:            /*
        -:  611:            ** Delay to allow the message to be read
        -:  612:            */
        1:  613:            OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  614:      
        -:  615:            /* 
        -:  616:            ** cFE Cannot continue to start up.  
        -:  617:            */
        1:  618:            CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  619:         }
        -:  620:         
        -:  621:      }
        -:  622:   }
        -:  623:
        -:  624:   /*
        -:  625:   ** Now, mount the RAM disk
        -:  626:   */
       14:  627:   RetStatus = OS_mount("/ramdev0", CFE_ES_RAM_DISK_MOUNT_STRING);
       14:  628:   if ( RetStatus != OS_FS_SUCCESS )
        -:  629:   {
        4:  630:      CFE_ES_WriteToSysLog("ES Startup: Error Mounting Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        -:  631:      /*
        -:  632:      ** Delay to allow the message to be read
        -:  633:      */
        4:  634:      OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  635:      
        -:  636:      /* 
        -:  637:      ** cFE Cannot continue to start up.  
        -:  638:      */
        4:  639:      CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  640:   }
        -:  641:
        -:  642:
        -:  643:   /*
        -:  644:   ** During a Processor reset, if the RAM disk has less than a defined 
        -:  645:   ** amount of free space, reformat and re-mount it.
        -:  646:   ** The parameter being checked is CFE_ES_RAM_DISK_PERCENT_RESERVED
        -:  647:   ** Note: When CFE_ES_RAM_DISK_PERCENT_RESERVED is set to 0, this feature is 
        -:  648:   **       disabled.
        -:  649:   */
       14:  650:   if ((start_type == CFE_ES_PROCESSOR_RESET) && (CFE_ES_RAM_DISK_PERCENT_RESERVED > 0))
        -:  651:   {
        -:  652:      /*
        -:  653:      ** See how many blocks are free in the RAM disk
        -:  654:      */
        7:  655:      BlocksFree = OS_fsBlocksFree(CFE_ES_RAM_DISK_MOUNT_STRING);   
        7:  656:      if ( BlocksFree >= 0 )
        -:  657:      {
        -:  658:         /*
        -:  659:         ** Need a sanity check for the desktop systems.
        -:  660:         ** Because the desktop ports map the volatile disk to the host 
        -:  661:         ** hard disk, it will report more free blocks than the defined number
        -:  662:         ** of sectors ( blocks ). Therefore it must be truncated.
        -:  663:         */
        6:  664:         if ( BlocksFree > CFE_ES_RAM_DISK_NUM_SECTORS )
        -:  665:         {
        1:  666:             BlocksFree = CFE_ES_RAM_DISK_NUM_SECTORS - 1;
        -:  667:         }
        -:  668:         
        -:  669:         /*
        -:  670:         ** Determine if the disk is too full 
        -:  671:         */
        6:  672:         BlocksFree = BlocksFree * 100;
        6:  673:         PercentFree = BlocksFree / CFE_ES_RAM_DISK_NUM_SECTORS;
        6:  674:         CFE_ES_WriteToSysLog("Volatile Disk has %d Percent free space.\n",PercentFree);
        -:  675:
        6:  676:         if ( PercentFree < CFE_ES_RAM_DISK_PERCENT_RESERVED )
        -:  677:         {
        5:  678:            CFE_ES_WriteToSysLog("ES Startup: Insufficent Free Space on Volatile Disk, Reformatting.\n");
        -:  679:          
        -:  680:            /*
        -:  681:            ** First, unmount the disk
        -:  682:            */
        5:  683:            RetStatus = OS_unmount(CFE_ES_RAM_DISK_MOUNT_STRING);
        5:  684:            if ( RetStatus == OS_FS_SUCCESS )
        -:  685:            {
        -:  686:
        -:  687:               /*
        -:  688:               ** Remove the file system from the OSAL
        -:  689:               */
        4:  690:               RetStatus = OS_rmfs("/ramdev0");
        4:  691:               if ( RetStatus == OS_FS_SUCCESS )
        -:  692:               {
        -:  693:               
        -:  694:                  /*
        -:  695:                  ** Next, make a new file system on the disk
        -:  696:                  */
        3:  697:                  RetStatus = OS_mkfs((void *)RamDiskMemoryAddress, "/ramdev0", 
        -:  698:                                      "RAM", CFE_ES_RAM_DISK_SECTOR_SIZE, 
        -:  699:                                       CFE_ES_RAM_DISK_NUM_SECTORS );
        3:  700:                  if ( RetStatus == OS_FS_SUCCESS )
        -:  701:                  {
        -:  702:                     /*
        -:  703:                     ** Last, remount the disk
        -:  704:                     */
        2:  705:                     RetStatus = OS_mount("/ramdev0", CFE_ES_RAM_DISK_MOUNT_STRING);
        2:  706:                     if ( RetStatus != OS_FS_SUCCESS )
        -:  707:                     {
        1:  708:                        CFE_ES_WriteToSysLog("ES Startup: Error Re-Mounting Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        -:  709:                        /*
        -:  710:                        ** Delay to allow the message to be read
        -:  711:                        */
        1:  712:                        OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  713:                     
        -:  714:                        /* 
        -:  715:                        ** cFE Cannot continue to start up.  
        -:  716:                        */
        1:  717:                        CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  718:                     
        -:  719:                     } /* end if mount */
        -:  720:                  }
        -:  721:                  else
        -:  722:                  {
        -:  723:
        1:  724:                     CFE_ES_WriteToSysLog("ES Startup: Error Re-Formating Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        -:  725:                     /*
        -:  726:                     ** Delay to allow the message to be read
        -:  727:                     */
        1:  728:                     OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  729:      
        -:  730:                     /* 
        -:  731:                     ** cFE Cannot continue to start up.  
        -:  732:                     */
        1:  733:                     CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  734:                                 
        -:  735:                  } /* end if mkfs */
        -:  736:
        -:  737:              }
        -:  738:              else /* could not Remove File system */
        -:  739:              {
        -:  740:
        1:  741:                  CFE_ES_WriteToSysLog("ES Startup: Error Removing Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        -:  742:                  /*
        -:  743:                  ** Delay to allow the message to be read
        -:  744:                  */
        1:  745:                  OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  746:      
        -:  747:                  /* 
        -:  748:                  ** cFE Cannot continue to start up.  
        -:  749:                  */
        1:  750:                  CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  751:
        -:  752:              } /* end if OS_rmfs */
        -:  753:
        -:  754:            }
        -:  755:            else /* could not un-mount disk */
        -:  756:            {
        1:  757:               CFE_ES_WriteToSysLog("ES Startup: Error Un-Mounting Volatile(RAM) Volume. EC = 0x%08X\n",RetStatus);
        -:  758:               /*
        -:  759:               ** Delay to allow the message to be read
        -:  760:               */
        1:  761:               OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  762:               
        -:  763:               /* 
        -:  764:               ** cFE Cannot continue to start up.  
        -:  765:               */
        1:  766:               CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);            
        -:  767:            }
        -:  768:            
        -:  769:         } /* end if enough free space */
        -:  770:         
        -:  771:      }
        -:  772:      else  /* could not determine free blocks */
        -:  773:      {         
        -:  774:         /* Log error message -- note that BlocksFree returns the error code in this case */
        1:  775:         CFE_ES_WriteToSysLog("ES Startup: Error Determining Blocks Free on Volume. EC = 0x%08X\n",BlocksFree);
        -:  776:
        -:  777:         /*
        -:  778:         ** Delay to allow the message to be read
        -:  779:         */
        1:  780:         OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  781:
        -:  782:         /* 
        -:  783:         ** cFE Cannot continue to start up.  
        -:  784:         */
        1:  785:         CFE_PSP_Panic(CFE_PSP_PANIC_VOLATILE_DISK);
        -:  786:         
        -:  787:      } /* end if BlocksFree */
        -:  788:   
        -:  789:   } /* end if processor reset */
        -:  790:     
       14:  791:} /* end function */
        -:  792:
        -:  793:/*-------------------------------------------------------------------------
        -:  794:**
        -:  795:**                  Functional Prolog
        -:  796:**
        -:  797:**   Name: CFE_ES_CreateObjects
        -:  798:**
        -:  799:**   Purpose: This function reads the es_object_table and performs all of the
        -:  800:**            application layer initialization.
        -:  801:**----------------------------------------------------------------------------
        -:  802:*/
       10:  803:void  CFE_ES_CreateObjects(void)
        -:  804:{
        -:  805:    int32     ReturnCode;
        -:  806:    boolean   AppSlotFound;
        -:  807:    uint16    i;
        -:  808:    uint16    j;
        -:  809:
       10:  810:    CFE_ES_WriteToSysLog("ES Startup: Starting Object Creation calls.\n");
        -:  811:
      310:  812:    for ( i = 0; i < CFE_ES_OBJECT_TABLE_SIZE; i++ )
        -:  813:    {
      300:  814:        switch ( CFE_ES_ObjectTable[i].ObjectType )
        -:  815:        {
        -:  816:            case CFE_ES_DRIVER_TASK:
        -:  817:            case CFE_ES_CORE_TASK:
        -:  818:
        -:  819:            /*
        -:  820:            ** Allocate an ES AppTable entry
        -:  821:            */
       50:  822:            AppSlotFound = FALSE;
      635:  823:            for ( j = 0; j < CFE_ES_MAX_APPLICATIONS; j++ )
        -:  824:            {
      625:  825:               if ( CFE_ES_Global.AppTable[j].RecordUsed == FALSE )
        -:  826:               {
       40:  827:                  AppSlotFound = TRUE;
       40:  828:                  break;
        -:  829:               }
        -:  830:            }
        -:  831:
        -:  832:            /*
        -:  833:            ** If a slot was found, create the application
        -:  834:            */
       50:  835:            if ( AppSlotFound == TRUE )
        -:  836:            {
        -:  837:            
       40:  838:               CFE_ES_LockSharedData(__func__,__LINE__);
        -:  839:
        -:  840:               /*
        -:  841:               ** Allocate and populate the ES_AppTable entry
        -:  842:               */
       40:  843:               CFE_PSP_MemSet ( (void *)&(CFE_ES_Global.AppTable[j]), 0, sizeof(CFE_ES_AppRecord_t));
       40:  844:               CFE_ES_Global.AppTable[j].RecordUsed = TRUE;
       40:  845:               CFE_ES_Global.AppTable[j].Type = CFE_ES_APP_TYPE_CORE;
        -:  846:               
        -:  847:               /*
        -:  848:               ** Fill out the parameters in the AppStartParams sub-structure
        -:  849:               */         
       40:  850:               strncpy((char *)CFE_ES_Global.AppTable[j].StartParams.Name, (char *)CFE_ES_ObjectTable[i].ObjectName, OS_MAX_API_NAME);
       40:  851:               CFE_ES_Global.AppTable[j].StartParams.Name[OS_MAX_API_NAME - 1] = '\0';
        -:  852:               /* EntryPoint field is not valid here for base apps */
        -:  853:               /* FileName is not valid for base apps, either */
       40:  854:               CFE_ES_Global.AppTable[j].StartParams.StackSize = CFE_ES_ObjectTable[i].ObjectSize;
       40:  855:               CFE_ES_Global.AppTable[j].StartParams.StartAddress = (uint32)CFE_ES_ObjectTable[i].FuncPtrUnion.FunctionPtr;
       40:  856:               CFE_ES_Global.AppTable[j].StartParams.ExceptionAction = CFE_ES_APP_EXCEPTION_PROC_RESTART;
       40:  857:               CFE_ES_Global.AppTable[j].StartParams.Priority = CFE_ES_ObjectTable[i].ObjectPriority;
        -:  858:               
        -:  859:               
        -:  860:               /*
        -:  861:               ** Fill out the Task Info
        -:  862:               */
       40:  863:               strncpy((char *)CFE_ES_Global.AppTable[j].TaskInfo.MainTaskName, (char *)CFE_ES_ObjectTable[i].ObjectName, OS_MAX_API_NAME);
       40:  864:               CFE_ES_Global.AppTable[j].TaskInfo.MainTaskName[OS_MAX_API_NAME - 1] = '\0';
       40:  865:               CFE_ES_Global.AppTable[j].TaskInfo.NumOfChildTasks = 0;
        -:  866:               
        -:  867:               /*
        -:  868:               ** Since this is a Core app, the AppStateRecord does not need to be filled out.
        -:  869:               */
        -:  870:               
        -:  871:               
        -:  872:               /*
        -:  873:               ** Create the task
        -:  874:               */
       80:  875:               ReturnCode = OS_TaskCreate(&CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId, /* task id */
        -:  876:                                  CFE_ES_ObjectTable[i].ObjectName,              /* task name */
       40:  877:                                  CFE_ES_ObjectTable[i].FuncPtrUnion.VoidPtr,    /* task function pointer */
        -:  878:                                  NULL,                                          /* stack pointer */
        -:  879:                                  CFE_ES_ObjectTable[i].ObjectSize,              /* stack size */
        -:  880:                                  CFE_ES_ObjectTable[i].ObjectPriority,          /* task priority */
        -:  881:                                  OS_FP_ENABLED);                                /* task options */
        -:  882:
       40:  883:               if(ReturnCode != OS_SUCCESS)
        -:  884:               {
        5:  885:                  CFE_ES_Global.AppTable[j].RecordUsed = FALSE;
        5:  886:                  CFE_ES_WriteToSysLog("ES Startup: OS_TaskCreate error creating core App: %s: EC = 0x%08X\n",
        -:  887:                                        CFE_ES_ObjectTable[i].ObjectName, ReturnCode);
        -:  888:      
        -:  889:                                        
        5:  890:                  CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  891:
        -:  892:                  /*
        -:  893:                  ** Delay to allow the message to be read
        -:  894:                  */
        5:  895:                  OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  896:      
        -:  897:                  /* 
        -:  898:                  ** cFE Cannot continue to start up.  
        -:  899:                  */
        5:  900:                  CFE_PSP_Panic(CFE_PSP_PANIC_CORE_APP);
        -:  901:                                              
        -:  902:               }
        -:  903:               else
        -:  904:               {
       35:  905:                  CFE_ES_ObjectTable[i].ObjectKey = CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId;
        -:  906:
        -:  907:                  /*
        -:  908:                  ** Allocate and populate the CFE_ES_Global.TaskTable entry
        -:  909:                  */
       35:  910:                  if ( CFE_ES_Global.TaskTable[CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId].RecordUsed == TRUE )
        -:  911:                  {
       30:  912:                     CFE_ES_WriteToSysLog("ES Startup: CFE_ES_Global.TaskTable record used error for App: %s, continuing.\n",
        -:  913:                                           CFE_ES_ObjectTable[i].ObjectName);
        -:  914:                  }
        -:  915:                  else
        -:  916:                  {
        5:  917:                     CFE_ES_Global.TaskTable[CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId].RecordUsed = TRUE;
        -:  918:                  }
       35:  919:                  CFE_ES_Global.TaskTable[CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId].AppId = j;
       35:  920:                  CFE_ES_Global.TaskTable[CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId].TaskId = CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId;
       35:  921:                  strncpy((char *)CFE_ES_Global.TaskTable[CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId].TaskName, (char *)CFE_ES_Global.AppTable[j].TaskInfo.MainTaskName, OS_MAX_API_NAME);
       35:  922:                  CFE_ES_Global.TaskTable[CFE_ES_Global.AppTable[j].TaskInfo.MainTaskId].TaskName[OS_MAX_API_NAME - 1] = '\0';
        -:  923:
       35:  924:                  CFE_ES_WriteToSysLog("ES Startup: Core App: %s created. App ID: %d\n",
        -:  925:                                       CFE_ES_ObjectTable[i].ObjectName,j);
        -:  926:                                       
        -:  927:                  /*
        -:  928:                  ** Increment the registered App and Registered External Task variables.
        -:  929:                  */
       35:  930:                  CFE_ES_Global.RegisteredTasks++;
       35:  931:                  CFE_ES_Global.RegisteredCoreApps++;
        -:  932:                  
       35:  933:                  CFE_ES_UnlockSharedData(__func__,__LINE__);
        -:  934:                                                                                                      
        -:  935:               }
        -:  936:            }
        -:  937:            else /* appSlot not found -- This should never happen!*/
        -:  938:            {
       10:  939:               CFE_ES_WriteToSysLog("ES Startup: Error, No free application slots available for CORE App!\n");
        -:  940:               /*
        -:  941:               ** Delay to allow the message to be read
        -:  942:               */
       10:  943:               OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  944:      
        -:  945:               /* 
        -:  946:               ** cFE Cannot continue to start up.  
        -:  947:               */
       10:  948:               CFE_PSP_Panic(CFE_PSP_PANIC_CORE_APP);
        -:  949:            
        -:  950:            }
       50:  951:            break;
        -:  952:
        -:  953:            case CFE_ES_FUNCTION_CALL: /*----------------------------------------------------------*/
        -:  954:
       61:  955:               if ( CFE_ES_ObjectTable[i].FuncPtrUnion.FunctionPtr != NULL )
        -:  956:               {
       60:  957:                  CFE_ES_WriteToSysLog("ES Startup: Calling %s\n",CFE_ES_ObjectTable[i].ObjectName);
        -:  958:                  /*
        -:  959:                  ** Call the function
        -:  960:                  */
       60:  961:                  ReturnCode = (*CFE_ES_ObjectTable[i].FuncPtrUnion.FunctionPtr)();
       60:  962:                  if(ReturnCode != CFE_SUCCESS)
        -:  963:                  {
        1:  964:                     CFE_ES_WriteToSysLog("ES Startup: Error returned when calling function: %s: EC = 0x%08X\n",
        -:  965:                                           CFE_ES_ObjectTable[i].ObjectName, ReturnCode);
        -:  966:                                        
        -:  967:                     /*
        -:  968:                     ** Delay to allow the message to be read
        -:  969:                     */
        1:  970:                     OS_TaskDelay(CFE_ES_PANIC_DELAY);
        -:  971:      
        -:  972:                     /* 
        -:  973:                     ** cFE Cannot continue to start up.  
        -:  974:                     */
        1:  975:                     CFE_PSP_Panic(CFE_PSP_PANIC_CORE_APP);
        -:  976:                                              
        -:  977:                  } /* end if */
        -:  978:                  
        -:  979:               }
        -:  980:               else
        -:  981:               {
        1:  982:                  CFE_ES_WriteToSysLog("ES Startup: bad function pointer ( table entry = %d).\n",i);
        -:  983:               }
        -:  984:               break;
        -:  985:
        -:  986:            case CFE_ES_NULL_ENTRY: /*-------------------------------------------------------*/
        -:  987:               break;
        -:  988:            default:
        -:  989:               break;
        -:  990:       } /* end switch */
        -:  991:
        -:  992:    } /* end for */
        -:  993:
       10:  994:    CFE_ES_WriteToSysLog("ES Startup: Finished ES CreateObject table entries.\n");
       10:  995:}
