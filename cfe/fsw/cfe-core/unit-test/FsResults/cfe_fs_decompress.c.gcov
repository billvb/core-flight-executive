        -:    0:Source:/home/sstrege/cFE650/cfe/fsw/cfe-core/src/fs/cfe_fs_decompress.c
        -:    0:Graph:cfe_fs_decompress.gcno
        -:    0:Data:cfe_fs_decompress.gcda
        -:    0:Runs:1
        -:    0:Programs:2
        -:    1:/*
        -:    2:** $Id: cfe_fs_decompress.c 1.14 2014/04/14 15:21:52GMT-05:00 lwalling Exp  $
        -:    3:**
        -:    4:**   File: CFE_FS_decompress.c
        -:    5:**
        -:    6:**
        -:    7:**      Copyright (c) 2004-2012, United States government as represented by the 
        -:    8:**      administrator of the National Aeronautics Space Administration.  
        -:    9:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:   10:**      Space Flight Center pursuant to government contracts.
        -:   11:**
        -:   12:**      This is governed by the NASA Open Source Agreement and may be used, 
        -:   13:**      distributed and modified only pursuant to the terms of that agreement.
        -:   14:** 
        -:   15:**
        -:   16:**
        -:   17:**   Author:   A. Cudmore,    NASA/GSFC Code 582
        -:   18:**             Ported from JWST, which was ported from Swift/BAT, 
        -:   19:**             which was ported from the GNU zip sources.
        -:   20:**
        -:   21:**   Purpose: cFE Port of the gzunzip software ported from Triana->Swift->JWST 
        -:   22:**
        -:   23:** $Log: cfe_fs_decompress.c  $
        -:   24:** Revision 1.14 2014/04/14 15:21:52GMT-05:00 lwalling 
        -:   25:** Delete unsuccessful decompression output file
        -:   26:** Revision 1.13 2012/02/08 14:09:20EST lwalling 
        -:   27:** Remove unused variable
        -:   28:** Revision 1.12 2012/01/13 12:11:28EST acudmore 
        -:   29:** Changed license text to reflect open source
        -:   30:** Revision 1.11 2012/01/10 18:37:46EST aschoeni 
        -:   31:** CFE return codes set directly; FS_gz_huft_build return code is now properly redefined
        -:   32:** Revision 1.10 2011/09/02 14:59:15EDT jmdagost 
        -:   33:** Added new-line characters where missing in syslog calls.
        -:   34:** Revision 1.9 2011/07/13 18:24:32EDT lwalling 
        -:   35:** Initialized local variables r.b, r.e, r.v.n and r.v.t
        -:   36:** Revision 1.8 2011/07/13 17:42:22EDT lwalling 
        -:   37:** Initialized local variable huft_index_t
        -:   38:** Revision 1.7 2011/01/19 18:00:59EST lwalling 
        -:   39:** Restore use of heritage error codes
        -:   40:** Revision 1.6 2011/01/19 15:09:17EST lwalling 
        -:   41:** Change calls from memset() to CFE_PSP_MemSet()
        -:   42:** Revision 1.5 2010/10/25 18:26:06EDT jmdagost 
        -:   43:** Added test to while-loop to make sure array index does not go negative.
        -:   44:**
        -:   45:*/
        -:   46:
        -:   47:/* Original Credit:
        -:   48: *
        -:   49: * inflate.c -- Not copyrighted 1992 by Mark Adler version c10p1, 10 January
        -:   50: * 1993
        -:   51: *
        -:   52: * You can do whatever you like with this source file, though I would prefer
        -:   53: * that if you modify it and redistribute it that you include comments to
        -:   54: * that effect with your name and the date.  Thank you. [The history has been
        -:   55: * moved to the file ChangeLog.]
        -:   56: */
        -:   57:
        -:   58:/*
        -:   59:** Includes
        -:   60:*/
        -:   61:#include "cfe_fs_decompress.h"
        -:   62:
        -:   63:/*
        -:   64:** Global data -- Note: The following Global Data should be removed. The CFE_FS_Decompress API is not 
        -:   65:**                re-entrant! In order to make sure that two apps will not corrupt the data
        -:   66:**                the API is guarded with a Mutex. This will have serious implications on 
        -:   67:**                real time performance if an application blocks while another is in the API.
        -:   68:**               
        -:   69:*/
        -:   70:CFE_FS_Decompress_State_t CFE_FS_Decompress_State_NR;
        -:   71:
        -:   72:static uint32     trace[ 3 ];
        -:   73:
        -:   74:/*
        -:   75:** Code
        -:   76:*/
        -:   77:
        -:   78:/* Main API entry point to decompress a file -
        -:   79: * Uses a global state buffer but protects the global by a mutex, so it may block if
        -:   80: * more than one thread tries to do this at any given time.
        -:   81: */
        -:   82:int32 CFE_FS_Decompress( const char * srcFileName, const char * dstFileName )
        1:   83:{
        -:   84:
        -:   85:   int32 rc;
        -:   86:
        -:   87:   /*
        -:   88:   ** Lock the API with the FS Mutex
        -:   89:   */
        1:   90:   CFE_FS_LockSharedData(__func__);
        -:   91:
        1:   92:   rc = CFE_FS_Decompress_Reentrant(&CFE_FS_Decompress_State_NR, srcFileName, dstFileName );
        -:   93:
        -:   94:   /*
        -:   95:   ** Unlock FS Shared data mutex
        -:   96:   */
        1:   97:   CFE_FS_UnlockSharedData(__func__);
        -:   98:
        1:   99:   return rc;
        -:  100:}
        -:  101:
        -:  102:
        -:  103:int32 CFE_FS_Decompress_Reentrant(CFE_FS_Decompress_State_t *State, const char * srcFileName, const char * dstFileName )
        4:  104:{
        -:  105:
        -:  106:   int32 guzerror;
        -:  107:
        4:  108:   State->Error = CFE_SUCCESS; /*Initialize this variable.  */
        -:  109:
        -:  110:   /*
        -:  111:   ** initialize max number of Huffman tables allocated to zero 
        -:  112:   */
        4:  113:   State->max_hufts = 0;
        -:  114:
        -:  115:   /*  
        -:  116:   ** Open input file 
        -:  117:   */
        4:  118:   State->srcFile_fd = OS_open( srcFileName, OS_READ_ONLY, 0 );
        -:  119:
        -:  120:   /*
        -:  121:   ** if input file could not be opened, return cFE error code 
        -:  122:   */
        4:  123:   if ( State->srcFile_fd < 0 )
        -:  124:   {
        1:  125:      CFE_ES_WriteToSysLog("CFE_FS_Decompress: Cannot open source file: %s\n",
        -:  126:                            srcFileName);
        1:  127:      return (CFE_FS_GZIP_OPEN_INPUT);
        -:  128:   }
        -:  129:
        -:  130:   /*
        -:  131:   ** open output file 
        -:  132:   */
        3:  133:   State->dstFile_fd = OS_creat( dstFileName, OS_WRITE_ONLY);
        -:  134:
        -:  135:   /*
        -:  136:   ** if output file could not be opened, return cFE error code
        -:  137:   */ 
        3:  138:   if ( State->dstFile_fd < 0 )
        -:  139:   {
        1:  140:      CFE_ES_WriteToSysLog("CFE_FS_Decompress: Cannot open destination file: %s\n",
        -:  141:                            dstFileName);
        -:  142:
        -:  143:      /* close the source file before bailing out */
        1:  144:      OS_close( State->srcFile_fd );
        -:  145:
        1:  146:      return (CFE_FS_GZIP_OPEN_OUTPUT);
        -:  147:   }
        -:  148:
        2:  149:   CFE_PSP_MemSet( State->hufTable,  0, MAX_HUF_TABLES * sizeof(HufTable) );
        2:  150:   CFE_PSP_MemSet( State->window, 0, WSIZE_X2 );
        2:  151:   CFE_PSP_MemSet( trace,     0, 3 * sizeof(uint32) ); 
        -:  152:		
        -:  153:   /* 
        -:  154:   ** uncompress the file 
        -:  155:   */
        2:  156:   guzerror = FS_gz_unzip_Reentrant(State);
        -:  157:
        -:  158:   /* 
        -:  159:   ** close input and output files 
        -:  160:   */
        2:  161:   OS_close( State->dstFile_fd );
        2:  162:   OS_close( State->srcFile_fd );
        -:  163:
        -:  164:   /* 
        -:  165:   ** delete output file after error
        -:  166:   */
        2:  167:   if (guzerror != CFE_SUCCESS)
        -:  168:   {
        1:  169:      OS_remove(dstFileName);
        -:  170:   }
        -:  171:
        -:  172:
        -:  173:   /* 
        -:  174:   ** return cFE error code
        -:  175:   */
        2:  176:   return(guzerror);
        -:  177:}
        -:  178:
        -:  179:
        -:  180:void FS_gz_clear_bufs_Reentrant( CFE_FS_Decompress_State_t *State )
        2:  181:{
        2:  182:	State->outcnt = 0;
        2:  183:	State->insize = 0;
        2:  184:	State->inptr  = 0;
        -:  185:
        2:  186:	State->bytes_in  = 0L;
        2:  187:	State->bytes_out = 0L;
        2:  188:}
        -:  189:
        -:  190:
        -:  191:int32 FS_gz_eat_header_Reentrant( CFE_FS_Decompress_State_t *State )
        2:  192:{
        -:  193:	uint8   flags;                  /* compression flags */
        -:  194:	int8    magic[2];               /* magic header      */
        -:  195:	int8    thisByte;				     /* temporary holder for current byte in a string read */
        -:  196:	uint32  stamp;                  /* time stamp        */
        -:  197:	boolean keep_going;
        -:  198:
        -:  199:	/*  read input buffer (check for read error) */
        2:  200:	magic[0] = (int8)NEXTBYTE();
        2:  201:	if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  202:
        2:  203:	magic[1] = (int8)NEXTBYTE();
        2:  204:	if ( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  205:
        3:  206:	if ( memcmp( magic, GZIP_MAGIC, 2 ) == 0 || memcmp( magic, OLD_GZIP_MAGIC, 2 ) == 0 ) 
        -:  207:   {
        -:  208:		
        1:  209:		NEXTBYTE();
        1:  210:		if ( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  211:		
        1:  212:		flags = NEXTBYTE();
        1:  213:		if ( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  214:		
        1:  215:		stamp  = (uint32)NEXTBYTE();
        1:  216:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  217:		stamp |= (uint32)NEXTBYTE() <<  8;
        1:  218:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  219:		stamp |= (uint32)NEXTBYTE() << 16;
        1:  220:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  221:		stamp |= (uint32)NEXTBYTE() << 24;
        1:  222:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  223:		
        1:  224:		NEXTBYTE();		/* Ignore extra flags for the moment */
        1:  225:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  226:		NEXTBYTE();		/* Ignore OS type for the moment */ 
        1:  227:		if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  228:		
        1:  229:		if ( (flags & CONTINUATION) != 0 ) {
    #####:  230:			NEXTBYTE();
    #####:  231:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  232:			NEXTBYTE();
    #####:  233:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  234:		}
        -:  235:		
        1:  236:		if ( (flags & EXTRA_FIELD) != 0 ) {
        -:  237:			uint32 len;
    #####:  238:			len  = NEXTBYTE();
    #####:  239:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  240:			len |= NEXTBYTE() << 8;
    #####:  241:			if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  242:			while (len--) {
    #####:  243:				NEXTBYTE();
    #####:  244:				if( State->Error != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  245:			}
        -:  246:		}
        -:  247:		
        -:  248:		/* Get original file name if it was truncated */
        1:  249:		if ( (flags & ORIG_NAME) != 0 ) {
        1:  250:			keep_going = TRUE;
        8:  251:			while ( keep_going ) {
        -:  252:
        -:  253:				/* Get the next byte */
        6:  254:				thisByte = NEXTBYTE();
        -:  255:
        -:  256:				/* Header failure when end of file is reached or a read failure occurs */
        6:  257:				if ((thisByte == EOF) || (State->Error != CFE_SUCCESS)) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  258:
        -:  259:				/* End of string was found */
        6:  260:				if (thisByte == 0) keep_going = FALSE;
        -:  261:			}
        -:  262:		}
        -:  263:		
        -:  264:		/*  Discard file comment if any  */
        1:  265:		if ( (flags & COMMENT) != 0 ) {
    #####:  266:			keep_going = TRUE;
    #####:  267:			while ( keep_going ) {
        -:  268:
        -:  269:				/* Get the next byte */
    #####:  270:				thisByte = NEXTBYTE();
        -:  271:
        -:  272:				/* Header failure when end of file is reached or a read failure occurs */
    #####:  273:				if ((thisByte == EOF) || (State->Error != CFE_SUCCESS)) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  274:
        -:  275:				/* End of string was found */
    #####:  276:				if (thisByte == 0) keep_going = FALSE;
        -:  277:			}
        -:  278:		}
        -:  279:	}
        -:  280:	else
        -:  281:	{
        1:  282:		State->Error = CFE_FS_GZIP_NON_ZIP_FILE;
        -:  283:	}
        -:  284:
        2:  285:	return State->Error;
        -:  286:}
        -:  287:
        -:  288:/*
        -:  289:** Fill the input buffer. This is called only when the buffer is empty. 
        -:  290:*/
        -:  291:int16 FS_gz_fill_inbuf_Reentrant( CFE_FS_Decompress_State_t *State )
        4:  292:{
        -:  293:	int32 len;
        -:  294:
        -:  295:	/*  Read as much as possible */
        4:  296:	State->insize = 0;
        -:  297:
        -:  298:	do 
        -:  299:   {
        5:  300:		len = OS_read( State->srcFile_fd, (int8*)State->inbuf + State->insize, INBUFSIZ - State->insize );
        -:  301:		
        5:  302:		if ( len == 0 || len == EOF || len == OS_FS_ERROR ) break;
        -:  303:		
        4:  304:		State->insize += len;
        -:  305:		
        4:  306:	} while ( State->insize < INBUFSIZ );
        -:  307:
        -:  308:
        4:  309:	if ( State->insize == 0 ) return EOF;
        -:  310:
        3:  311:	if ( len == OS_FS_ERROR ) 
        -:  312:   {
    #####:  313:		State->Error = CFE_FS_GZIP_READ_ERROR;
    #####:  314:		return EOF;
        -:  315:	}
        -:  316:
        3:  317:	State->bytes_in += (uint32)State->insize;
        3:  318:	State->inptr = 1;
        -:  319:
        3:  320:	return State->inbuf[0];
        -:  321:}
        -:  322:
        -:  323:
        -:  324:/*  Write the output window window[0..State->outcnt-1] and update crc and */
        -:  325:/*   State->bytes_out. (Used for the decompressed data only.) */
        -:  326:/*  merged original State->flush_window & State->write_buf together - glw */
        -:  327:/* fix for infinite loop when file store is full -dds */
        -:  328:void FS_gz_flush_window_Reentrant( CFE_FS_Decompress_State_t *State )
        5:  329:{
        -:  330:
        -:  331:	int32  n;
        -:  332:	uint32  cnt;
        -:  333:	uint8   *gz_window_position;
        -:  334:
        5:  335:	if ( State->outcnt == 0 ) return;
        -:  336:
        5:  337:	FS_gz_updcrc( State->window, State->outcnt );
        -:  338:
        5:  339:	cnt = State->outcnt;
        5:  340:	gz_window_position = State->window;
        -:  341:
       11:  342:	while ( State->Error != CFE_FS_GZIP_WRITE_ERROR  &&
        -:  343:		    ( n = OS_write(State->dstFile_fd, (int8 *)gz_window_position, cnt) ) != cnt )
        -:  344:	{ 
        1:  345:		if ( n <= 0 ) State->Error = CFE_FS_GZIP_WRITE_ERROR;
        -:  346:		
        1:  347:		cnt -= n;
        1:  348:		gz_window_position += n;
        -:  349:	}
        -:  350:
        5:  351:	State->bytes_out += (uint32)State->outcnt;
        -:  352:
        5:  353:	State->outcnt = 0;
        -:  354:}
        -:  355:
        -:  356:
        -:  357:/*  Given a list of code lengths and a maximum table size, make a set of */
        -:  358:/*  tables to decode that set of codes.  Return zero on success, one if the */
        -:  359:/*  given code set is incomplete (the tables are still built in this case), */
        -:  360:/*  two if the input is invalid (all zero length codes or an oversubscribed */
        -:  361:/*  set of lengths), and three if not enough memory. */
        -:  362:
        -:  363:/*  INPUT:  */
        -:  364:/*	uint32    *b;      */             /* code lengths in bits (all assumed <= BMAX) */
        -:  365:/*	uint32     n;      */             /* number of codes (assumed <= N_MAX)         */
        -:  366:/*	uint32     s;       */            /* number of simple-valued codes (0..s-1)     */
        -:  367:/*	uint16    *d;       */            /* list of base values for non-simple codes   */
        -:  368:/*	uint16    *e;       */            /* list of extra bits for non-simple codes    */
        -:  369:/*	int32     *m;       */            /* maximum lookup bits, returns actual        */
        -:  370:
        -:  371:int32 FS_gz_huft_build_Reentrant( CFE_FS_Decompress_State_t *State, uint32 * b, uint32 n, uint32 s, uint16 * d, uint16 * e, int32 * m )
       20:  372:{
        -:  373:
        -:  374:	uint32  a;              /* counter for codes of length k        */
        -:  375:	uint32  c[BMAX + 1];    /* bit length count table               */
        -:  376:	uint32  f;              /* i repeats in table every f entries   */
        -:  377:	int32   g;              /* maximum code length                  */
        -:  378:	int32   h;              /* table level                          */
        -:  379:	register uint32 i;      /* counter, current code                */
        -:  380:	register uint32 j;      /* counter                              */
        -:  381:	register int32  k;      /* number of bits in current code       */
        -:  382:	int32  l;               /* bits per table (returned in m)       */
        -:  383:	uint32 lu;              /* l unsigned                           */
        -:  384:	register uint32 *p;     /* pointer into c[], b[], or v[]        */
        -:  385:	register HufTable *q;   /* points to current table              */
        -:  386:	HufTable r;             /* table entry for structure assignment */
        -:  387:	HufTable *u[BMAX];      /* table stack                          */
        -:  388:	uint32 v[N_MAX];        /* values in order of bit length        */
        -:  389:	register int32 w;       /* bits before this table == (l * h)    */
        -:  390:	uint32 x[BMAX + 1];     /* bit offsets, then code stack         */
        -:  391:	uint32 *xp;             /* pointer into x                       */
        -:  392:	int32 y;                /* number of dummy codes added          */
        -:  393:	uint32 z;               /* number of entries in current table   */
        -:  394:
        -:  395:	uint32 huft_index_q;
       20:  396:	uint32 huft_index_t = 0;
       20:  397:	boolean   not_first_table = FALSE;
       20:  398:	huft_index_t = 0;
        -:  399:
        -:  400:	/*  Generate counts for each bit length  */
       20:  401:	CFE_PSP_MemSet( (void*)(c), 0, sizeof(c) );
       20:  402:	r.b=0;
       20:  403:	r.e=0;
       20:  404:	r.v.n=0;
       20:  405:	r.v.t=0;
       20:  406:	p = b;
       20:  407:	i = n;
        -:  408:	do 
        -:  409:   {
     2309:  410:		c[*p]++;
     2309:  411:		p++;
     2309:  412:	} while (--i);
        -:  413:	
       20:  414:   if (c[0] == n) 
        -:  415:   {			/* null input--all zero length codes */
    #####:  416:		*m = 0;
    #####:  417:		return CFE_SUCCESS;
        -:  418:	}
        -:  419:
        -:  420:
        -:  421:	/*  Find minimum and maximum length, bound *m by those */
       20:  422:	l = *m;
       20:  423:	for ( j = 1; j <= BMAX; j++ ) if ( c[j] ) break;
       20:  424:	k = j;
       20:  425:	lu = (uint32)l;				   		               /* minimum code length */
       20:  426:	if ( lu < j ) { l = j; lu = (uint32)l; }
       20:  427:	for ( i = BMAX; i; i-- ) if (c[i]) break;
       20:  428:	g = i;						                       /* maximum code length */
       20:  429:	if ( lu > i ) { l = i; lu = (uint32)l; }
       20:  430:	*m = l;
        -:  431:
        -:  432:
        -:  433:	/*  Adjust last length count to fill out codes, if needed */
      132:  434:	for ( y = 1 << j; j < i; j++, y <<= 1 )
      112:  435:	if ( ( y -= c[j] ) < 0 )  return CFE_FS_GZIP_BAD_CODE_BLOCK;    /* bad input: more codes than bits */
       20:  436:	if ( (y -= c[i] ) < 0 )  return CFE_FS_GZIP_BAD_CODE_BLOCK;
       20:  437:	c[i] += y;
        -:  438:
        -:  439:
        -:  440:	/*  Generate starting offsets into the value table for each length */
       20:  441:	x[1] = j = 0;
       20:  442:	p = c + 1;
       20:  443:	xp = x + 2;
      197:  444:	while (--i) {					/* note that i == g from above */
      157:  445:		j += *p++;
      157:  446:		*xp++ = j;
        -:  447:	}
        -:  448:
        -:  449:
        -:  450:	/*  Make a table of values in order of bit lengths */
       20:  451:	p = b;
       20:  452:	i = 0;
        -:  453:	do {
     2309:  454:		if ( (j = *p++) != 0 ) v[x[j]++] = i;
     2309:  455:	} while ( ++i < n );
        -:  456:
        -:  457:
        -:  458:	/*  Generate the Huffman codes and for each, make the table entries  */
       20:  459:	x[0] = i = 0;				  /* first Huffman code is zero   */
       20:  460:	p = v;						  /* grab values in bit order     */
       20:  461:	h = -1;						  /* no tables yet--level -1      */
       20:  462:	w = -l;						  /* bits decoded == (l * h)      */
       20:  463:	u[0] = (HufTable *)NULL;      /* just to keep compilers happy */
       20:  464:	q = (HufTable *)NULL;         /* ditto */
       20:  465:	z = 0;                        /* ditto */
        -:  466:
        -:  467:
        -:  468:	/*  go through the bit lengths (k already is bits in shortest code) */
      152:  469:	for (; k <= g; k++) {
      132:  470:		a = c[k];
     2461:  471:		while (a--) {
        -:  472:			
        -:  473:			/*      here i is the Huffman code of length k bits for value *p */
        -:  474:			/*      make tables up to required level */
     4794:  475:	        while (k > w + l) {
      400:  476:				h++;
      400:  477:				w += l;			/* previous table always l bits */
        -:  478:				
        -:  479:				/*        compute minimum size table less than or equal to l bits */
      400:  480:				z = g - w;
      400:  481:				z = ( z > lu ? l : z );                        /* upper limit on table size */
      400:  482:				j = k - w;
      400:  483:				f = 1<<j;
      400:  484:				if ( f > a + 1 )  {                            /* try a k-w bit table */
        -:  485:					
        -:  486:					/*          too few codes for k-w bit table  */
       30:  487:					f -= a + 1;                         /* deduct codes from patterns left */
       30:  488:					xp = c + k;
      121:  489:					while ( ++j < z )  {                /* try smaller tables up to z bits */
       63:  490:						f <<= 1;
       63:  491:						if ( f <= *++xp ) break;	        /* enough codes to use up j bits   */
       61:  492:						f -= *xp;                         /* else deduct codes from patterns */
        -:  493:					}
        -:  494:					
        -:  495:				}
      400:  496:				z = 1 << j;                           /* table entries for j-bit table   */
        -:  497:				
        -:  498:				/*        if space remains in the Huffman table memory array, "allocate" and link in new table */
      400:  499:				if ( State->hufts + (z + 1) > MAX_HUF_TABLES ) return CFE_FS_GZIP_NO_MEMORY;
        -:  500:				
      400:  501:				q = &State->hufTable[State->hufts];
      400:  502:				huft_index_q = State->hufts;
      400:  503:				State->hufts += z + 1;
      400:  504:				if ( State->hufts > State->max_hufts ) State->max_hufts = State->hufts;
        -:  505:				
      400:  506:				if ( not_first_table ) State->hufTable[huft_index_t].v.t = huft_index_q + 1;
       20:  507:				else                   not_first_table = TRUE;
        -:  508:				
      400:  509:				huft_index_t = huft_index_q;
      400:  510:				State->hufTable[huft_index_t].v.t = 0xffff;               /* stand-in for NULL */
        -:  511:				
      400:  512:				u[h] = ++q;		                        /* table starts after link */
      400:  513:				huft_index_q++;
        -:  514:				
        -:  515:				/*        connect to last table, if there is one */
      400:  516:				if ( h ) {
      380:  517:					x[h] = i;                /* save pattern for backing up    */
      380:  518:					r.b = (uint8)l;     	  /* bits to dump before this table */
      380:  519:					r.e = (uint8)(16 + j);	  /* bits in this table             */
        -:  520:					/*             r.t = q;  */               /* pointer to this table          */
      380:  521:					r.v.t = huft_index_q;    /* pointer to this table          */
      380:  522:					j = i >> (w - l);        /* (get around Turbo C bug)       */
      380:  523:					u[h - 1][j] = r;         /* connect to last table          */ 
        -:  524:				}
        -:  525:				
        -:  526:	        }
        -:  527:			
        -:  528:			/*      set up table entry in r */
     2197:  529:	        r.b = (uint8)(k - w);
     2197:  530:	        if (p >= v + n) {
        2:  531:				r.e = 99;                             /* out of values--invalid code     */
     2195:  532:	        } else if ( *p < s ) {
     1837:  533:				r.e = (uint8)( *p < 256 ? 16 : 15 );	/* 256 is end-of-block code        */
     1837:  534:				r.v.n = *p;          	                /* simple code is just the value   */
     1837:  535:				p++;                                  /* one compiler does not like *p++ */
        -:  536:	        } else {
      358:  537:				r.e = (uint8)( e[*p - s] );           /* non-simple--look up in lists */
      358:  538:				r.v.n = d[*p++ - s];
        -:  539:	        }
        -:  540:			
        -:  541:			/*      fill code-like entries with r */
     2197:  542:	        f = 1 << (k - w);
     2197:  543:			j = i >> w;
        -:  544:
     2197:  545:			if( (q == (HufTable *)NULL) && (j < z) )
        -:  546:			{
    #####:  547:				return CFE_FS_GZIP_BAD_CODE_BLOCK;
        -:  548:			}
        -:  549:			else
        -:  550:			{
     2197:  551:	        	for ( j = i >> w; j < z; j += f ) q[j] = r;
        -:  552:			}
        -:  553:			
        -:  554:			/*      backwards increment the k-bit code i */
     2197:  555:	        for ( j = 1 << (k - 1); i & j; j >>= 1 ) i ^= j;
     2197:  556:	        i ^= j;
        -:  557:			
        -:  558:			/*      backup over finished tables */
     4774:  559:	        while (( h >= 0 ) && ( ( i & ((1 << w) - 1) ) != x[h] )) {
      380:  560:				h--;                                       /* don't need to update q */
      380:  561:				w -= l;
        -:  562:	        }
        -:  563:			
        -:  564:		}
        -:  565:		
        -:  566:	}
        -:  567:
        -:  568:	/*  Return true (1) if we were given an incomplete table  */
       20:  569:	if((y != 0 && g != 1))
        -:  570:	{
        1:  571:		return CFE_FS_GZIP_BAD_DATA;
        -:  572:	}
        -:  573:
       19:  574:	return CFE_SUCCESS;
        -:  575:
        -:  576:}
        -:  577:
        -:  578:
        -:  579:
        -:  580:int32 FS_gz_inflate_Reentrant( CFE_FS_Decompress_State_t *State )
        1:  581:{
        -:  582:
        -:  583:	int32           e;        /* last block flag */
        -:  584:	int32   r;        /* result code     */
        -:  585:
        -:  586:	/*  initialize window, bit buffer */
        1:  587:	State->outcnt = 0;
        1:  588:	State->bk     = 0;
        1:  589:	State->bb     = 0;
        -:  590:
        -:  591:	/*  decompress until the last block */
        -:  592:	do {
        6:  593:		r = FS_gz_inflate_block_Reentrant( State, &e);
        6:  594:		if ( r != CFE_SUCCESS ) return r;
        6:  595:	} while (!e);
        -:  596:
        -:  597:	/*  Undo too much lookahead. The next read will be byte aligned so we can */
        -:  598:	/*  discard unused bits in the last meaningful byte. */
        2:  599:	while ( State->bk >= 8 ) {
    #####:  600:		State->bk -= 8;
    #####:  601:		State->inptr--;
        -:  602:	}
        -:  603:
        -:  604:	/*  flush out sliding window */
        1:  605:	FS_gz_flush_window_Reentrant(State);
        -:  606:
        -:  607:	/*  return success */
        1:  608:	return CFE_SUCCESS;
        -:  609:
        -:  610:}
        -:  611:
        -:  612:
        -:  613:/*  
        -:  614:** decompress an inflated block 
        -:  615:*/
        -:  616:int32 FS_gz_inflate_block_Reentrant( CFE_FS_Decompress_State_t *State, int32 * e )
        6:  617:{
        -:  618:
        -:  619:	uint32  t;          /* block type */
        -:  620:	uint32  b;          /* bit buffer */
        -:  621:	uint32  k;          /* number of bits in bit buffer */
        -:  622:
        -:  623:	int32 res;
        -:  624:
        -:  625:	/*  make local bit buffer */
        6:  626:	b = State->bb;
        6:  627:	k = State->bk;
        -:  628:
        -:  629:	/*  read in last block bit */
        6:  630:	NEEDBITS(1)
        6:  631:	*e = (int32)b & 1;
        6:  632:	DUMPBITS(1)
        -:  633:
        -:  634:
        -:  635:	/*  read in block type */
        6:  636:	NEEDBITS(2)
        6:  637:	t = (uint32)b & 3;
        6:  638:	DUMPBITS(2)
        -:  639:
        -:  640:
        -:  641:	/*  restore the global bit buffer */
        6:  642:	State->bb = b;
        6:  643:	State->bk = k;
        -:  644:
        -:  645:
        -:  646:	/*  inflate that block type */
        6:  647:	if      ( t == 0 ) { res = FS_gz_inflate_stored_Reentrant(State);  trace[0]++; }
        6:  648:	else if ( t == 1 ) { res = FS_gz_inflate_fixed_Reentrant(State);   trace[1]++; }
        6:  649:	else if ( t == 2 ) { res = FS_gz_inflate_dynamic_Reentrant(State); trace[2]++; }
        -:  650:
    #####:  651:	else               res = CFE_FS_GZIP_BAD_CODE_BLOCK;    
        -:  652:
        6:  653:	return res;
        -:  654:
        -:  655:}
        -:  656:
        -:  657:/* Inflate (decompress) the codes in a deflated (compressed) block.  */
        -:  658:/* Return an error code or zero if it all goes ok. */
        -:  659:int32 FS_gz_inflate_codes_Reentrant( CFE_FS_Decompress_State_t *State, HufTable * tl, HufTable * td, int32 bl, int32 bd )
        7:  660:{
        -:  661:
        -:  662:	static uint16 mask_bits[] = {
        -:  663:		0x0000,
        -:  664:			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -:  665:			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -:  666:	};
        -:  667:
        -:  668:
        -:  669:	uint32      e;          /* table entry flag/number of extra bits  */
        -:  670:	uint32      n, d;       /* length and index for copy              */
        -:  671:	uint32      w;          /* current window position                */
        -:  672:	HufTable   *t;          /* pointer to table entry                 */
        -:  673:	uint32      ml, md;     /* masks for bl and bd bits               */
        -:  674:	uint32      b;          /* bit buffer                             */
        -:  675:	uint32      k;          /* number of bits in bit buffer           */
        -:  676:
        -:  677:	uint32 index;
        -:  678:
        -:  679:	/*  make local copies of globals  */
        7:  680:	b = State->bb;					/* initialize bit buffer */
        7:  681:	k = State->bk;
        7:  682:	w = State->outcnt;				/* initialize window position */
        -:  683:
        -:  684:	/*  inflate the coded data */
        7:  685:	ml = mask_bits[bl];			/* precompute masks for speed */
        7:  686:	md = mask_bits[bd];
        -:  687:
        -:  688:	for (;;) 
        -:  689:   {					/* do until end of block */
        -:  690:		
    24135:  691:		NEEDBITS((uint32)bl);
    24135:  692:      t = tl + ((uint32)b & ml);
    24135:  693:		e = t->e;
    24135:  694:		if ( e > 16 ) 
        -:  695:      {
        -:  696:	        do 
        -:  697:           {
     2079:  698:              if (e == 99) return CFE_FS_GZIP_BAD_DATA;
     2079:  699:              DUMPBITS(t->b);
     2079:  700:              e -= 16;
     2079:  701:				  NEEDBITS(e);
     2079:  702:              index = t->v.t + ( (uint32)b & mask_bits[e] );
     2079:  703:				  if ( index >= 0  &&  index < State->hufts )
     2079:  704:                 t = &( State->hufTable[index] );
        -:  705:				  else  
    #####:  706:                 return CFE_FS_GZIP_INDEX_ERROR;
     2079:  707:				  e = t->e;
     2079:  708:	        } while ( e > 16 );
        -:  709:		}
        -:  710:		
    24135:  711:		DUMPBITS(t->b);
        -:  712:			
    24135:  713:      if ( e == 16 ) 
        -:  714:      {                 /* then it's a literal */
        -:  715:				
        -:  716:         /* gz_window[w++] = (uint8)(t->n); */
    14203:  717:         State->window[w++] = (uint8)(t->v.n);
    14203:  718:         if ( w == WSIZE ) 
        -:  719:         {
    #####:  720:            State->outcnt = w;
    #####:  721:            FS_gz_flush_window_Reentrant(State);
    #####:  722:            w = 0;
        -:  723:         }
        -:  724:				
        -:  725:      } 
        -:  726:      else 
        -:  727:      {                        /* it's an EOB or a length */
        -:  728:				
        -:  729:         /*  exit if end of block  */
     9932:  730:         if ( e == 15 ) break;
        -:  731:				
        -:  732:         /*  get length of block to copy */
     9925:  733:         NEEDBITS(e);
     9925:  734:         n = t->v.n + ( (uint32)b & mask_bits[e] );
     9925:  735:         DUMPBITS(e);
        -:  736:				
        -:  737:         /*  decode distance of block to copy  */
     9925:  738:         NEEDBITS((uint32)bd);
     9925:  739:         t = td + ((uint32)b & md);
     9925:  740:         e = t->e;
     9925:  741:         if ( e > 16 ) 
        -:  742:         {
        -:  743:            do 
        -:  744:            {
      337:  745:               if (e == 99) return CFE_FS_GZIP_BAD_DATA;
      337:  746:               DUMPBITS(t->b);
      337:  747:               e -= 16;
      337:  748:               NEEDBITS(e);
      337:  749:               index = t->v.t + ( (uint32)b & mask_bits[e] );
      337:  750:               if ( index >= 0  &&  index < State->hufts )
      337:  751:                  t = &( State->hufTable[index] );
        -:  752:               else  
    #####:  753:                  return CFE_FS_GZIP_INDEX_ERROR;
      337:  754:               e = t->e;
      337:  755:            } while ( e > 16 );
        -:  756:         }
     9925:  757:         DUMPBITS(t->b);
        -:  758:					
     9925:  759:         NEEDBITS(e);
     9925:  760:         d = w - t->v.n - ((uint32)b & mask_bits[e]);
     9925:  761:         DUMPBITS(e);
        -:  762:					
        -:  763:         /* do the copy */
        -:  764:         do 
        -:  765:         {
        -:  766:						
     9935:  767:            d &= WSIZE - 1;
     9935:  768:            e = WSIZE - ( d > w ? d : w);
     9935:  769:            e = ( e > n ? n : e );
     9935:  770:            n -= e;
        -:  771:						
     9935:  772:            if ( w - d >= e ) 
        -:  773:            { /* (this test assumes unsigned comparison) */
        -:  774:							
     9854:  775:               memcpy( State->window + w, State->window + d, e );
     9854:  776:               w += e;
     9854:  777:               d += e;
        -:  778:							
        -:  779:            } 
        -:  780:            else 
        -:  781:            { /* do it slow to avoid memcpy() overlap */
        -:  782:							
        -:  783:               do 
        -:  784:               {
     8124:  785:                  State->window[w++] = State->window[d++];
     8124:  786:               } while (--e);
        -:  787:							
        -:  788:            }
        -:  789:						
     9935:  790:            if ( w == WSIZE ) 
        -:  791:            {
        3:  792:               State->outcnt = w;
        3:  793:               FS_gz_flush_window_Reentrant(State);
        3:  794:               w = 0;
        -:  795:            }
        -:  796:						
     9935:  797:         } while (n);
        -:  798:					
        -:  799:      }
        -:  800:			
    24128:  801:   }
        -:  802:
        -:  803:	/*  restore the globals from the locals */
        7:  804:	State->outcnt = w;				/* restore global window pointer */
        7:  805:	State->bb = b;					/* restore global bit buffer */
        7:  806:	State->bk = k;
        -:  807:
        7:  808:	return CFE_SUCCESS;
        -:  809:}
        -:  810:
        -:  811:/*
        -:  812:** removed gz_huft_free, no longer needed - glw 
        -:  813:** -- decompress an inflated type 2 (dynamic Huffman codes) block. 
        -:  814:*/
        -:  815:int32 FS_gz_inflate_dynamic_Reentrant( CFE_FS_Decompress_State_t *State )
        6:  816:{
        -:  817:
        -:  818:	static int32 lbits = 9;      /* bits in base literal/length lookup table */
        -:  819:	static int32 dbits = 6;      /* bits in base distance lookup table */
        -:  820:
        -:  821:	/*  Order of the bit length code lengths */
        -:  822:	static uint32 border[] = {
        -:  823:		16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
        -:  824:	};
        -:  825:
        -:  826:	/*  Copy lengths for literal codes 257..285 */
        -:  827:	static uint16 cplens[] = {
        -:  828:		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -:  829:			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        -:  830:	};
        -:  831:
        -:  832:	/*  Extra bits for literal codes 257..285    ( 99==invalid ) */
        -:  833:	static uint16 cplext[] = {
        -:  834:		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -:  835:			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
        -:  836:	};
        -:  837: 
        -:  838:	/*  Copy offsets for distance codes 0..29 */
        -:  839:	static uint16 cpdist[] = {
        -:  840:		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -:  841:			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -:  842:			8193, 12289, 16385, 24577
        -:  843:	};
        -:  844:
        -:  845:	/*  Extra bits for distance codes */
        -:  846:	static uint16 cpdext[] = {
        -:  847:		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -:  848:			7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
        -:  849:	};
        -:  850:
        -:  851:	static uint16 mask_bits[] = {
        -:  852:		0x0000,
        -:  853:			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -:  854:			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -:  855:	};
        -:  856:
        -:  857:
        -:  858:	int32      i;               /* temporary variables                      */
        -:  859:	uint32     j;
        -:  860:	uint32     l;               /* last length                              */
        -:  861:	uint32     m;               /* mask for bit lengths table               */
        -:  862:	uint32     n;               /* number of lengths to get                 */
        -:  863:	HufTable  *tl;              /* literal/length code table                */
        -:  864:	HufTable  *td;              /* distance code table                      */
        -:  865:	int32      bl;              /* lookup bits for tl                       */
        -:  866:	int32      bd;              /* lookup bits for td                       */
        -:  867:	uint32     nb;              /* number of bit length codes               */
        -:  868:	uint32     nl;              /* number of literal/length codes           */
        -:  869:	uint32     nd;              /* number of distance codes                 */
        -:  870:	uint32     ll[286 + 30];    /* literal/length and distance code lengths */
        -:  871:
        -:  872:	uint32     b;               /* bit buffer                   */
        -:  873:	uint32     k;               /* number of bits in bit buffer */
        -:  874:
        -:  875:	int32 error_code;
        -:  876:
        -:  877:	/*  make local bit buffer */
        6:  878:	b = State->bb;
        6:  879:	k = State->bk;
        -:  880:
        -:  881:	/*  read in table lengths */ 
        6:  882:	NEEDBITS(5);
        6:  883:	nl = 257 + ((uint32)b & 0x1f);	/* number of literal/length codes */
        6:  884:	DUMPBITS(5);
        -:  885:
        6:  886:	NEEDBITS(5);
        6:  887:	nd = 1 + ((uint32) b & 0x1f);	/* number of distance codes */
        6:  888:	DUMPBITS(5);
        -:  889:
        6:  890:	NEEDBITS(4);
        6:  891:	nb = 4 + ((uint32) b & 0xf);	/* number of bit length codes */
        6:  892:	DUMPBITS(4);
        -:  893:
        6:  894:	if (nl > 286 || nd > 30)  return CFE_FS_GZIP_BAD_DATA;				/* bad lengths */
        -:  895:
        -:  896:	/*  read in bit-length-code lengths */
       91:  897:	for (j = 0; j < nb; j++) {
       85:  898:		NEEDBITS(3);
       85:  899:			ll[border[j]] = (uint32)b & 7;
       85:  900:		DUMPBITS(3);
        -:  901:	}
        6:  902:	for (; j < 19; j++) ll[border[j]] = 0;
        -:  903:
        -:  904:	/*  build decoding table for trees--single level, 7 bit lookup  */
        6:  905:	bl = 7;
        6:  906:	State->hufts = 0;             /* initialize Huff Table memory */
        6:  907:	tl = &State->hufTable[1];        /* set known position given alloc removed - glw */
        6:  908:	error_code = FS_gz_huft_build_Reentrant(State, ll, 19, 19, (uint16 *)NULL, (uint16 *)NULL, &bl );
        6:  909:	if ( error_code != CFE_SUCCESS )  return error_code; 
        -:  910:
        -:  911:	/*  read in literal and distance code lengths */
        6:  912:	n = nl + nd;
        6:  913:	m = mask_bits[bl];
        6:  914:	i = l = 0;
     1694:  915:	while ( (uint32)i < n ) 
        -:  916:   {
     1682:  917:		NEEDBITS((uint32)bl);
     1682:  918:      td = tl + ((uint32)b & m);
     1682:  919:		j = td->b;
     1682:  920:		DUMPBITS(j);
     1682:  921:      j = td->v.n;
     1682:  922:		if ( j < 16 ) 
        -:  923:      {            /* length of code in bits (0..15) */
     1617:  924:         ll[i++] = l = j;         /* save last length in l */
        -:  925:		} 
       65:  926:      else if ( j == 16 ) 
        -:  927:      {    /* repeat last length 3 to 6 times */
       59:  928:         NEEDBITS(2);
       59:  929:         j = 3 + ( (uint32)b & 3 );
       59:  930:         DUMPBITS(2);
       59:  931:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
       59:  932:         while (j--) ll[i++] = l;
        -:  933:		} 
        6:  934:      else if (j == 17) 
        -:  935:      {    /* 3 to 10 zero length codes */
        6:  936:         NEEDBITS(3);
        6:  937:         j = 3 + ( (uint32)b & 7 );
        6:  938:         DUMPBITS(3);
        6:  939:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
        6:  940:         while (j--) ll[i++] = 0;
        6:  941:         l = 0;
        -:  942:		} 
        -:  943:      else 
        -:  944:      {                 /* j == 18: 11 to 138 zero length codes */
    #####:  945:         NEEDBITS(7);
    #####:  946:         j = 11 + ( (uint32)b & 0x7f );
    #####:  947:         DUMPBITS(7);
    #####:  948:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
    #####:  949:         while (j--) ll[i++] = 0;
    #####:  950:         l = 0;
        -:  951:		}
        -:  952:	}
        -:  953:
        -:  954:	/*  restore the global bit buffer  */
        6:  955:	State->bb = b;
        6:  956:	State->bk = k;
        -:  957:
        -:  958:	/*  build the decoding tables for literal/length and distance codes */
        6:  959:	bl = lbits;
        6:  960:	State->hufts = 0;                 /* initialize Huff Table memory */
        6:  961:	tl = &State->hufTable[1];            /* set known position given alloc removed - glw */
        6:  962:	error_code = FS_gz_huft_build_Reentrant(State, ll, nl, 257, cplens, cplext, &bl );
        6:  963:	if ( error_code != CFE_SUCCESS ) return error_code;
        -:  964:
        6:  965:	bd = dbits;
        6:  966:	td = &State->hufTable[State->hufts+1];   /* set known position given alloc removed - glw */
        6:  967:	error_code = FS_gz_huft_build_Reentrant(State, ll + nl, nd, 0, cpdist, cpdext, &bd );
        6:  968:	if ( error_code != CFE_SUCCESS ) return error_code;
        -:  969:
        -:  970:	/*  decompress until an end-of-block code */
        6:  971:	error_code = FS_gz_inflate_codes_Reentrant(State, tl, td, bl, bd );
        -:  972:   
        6:  973:	return error_code;
        -:  974:}
        -:  975:
        -:  976:
        -:  977:/* Decompress an inflated type 1 (fixed Huffman codes) block.   */
        -:  978:/*  We should either replace this with a custom decoder,  */
        -:  979:/*  or at least precompute the Huffman tables. */
        -:  980:
        -:  981:/* removed gz_huft_free, no longer needed - glw */
        -:  982:int32 FS_gz_inflate_fixed_Reentrant( CFE_FS_Decompress_State_t *State )
        1:  983:{
        -:  984:	/*  Copy lengths for literal codes 257..285 */
        -:  985:	static uint16 cplens[] = {
        -:  986:		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -:  987:			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        -:  988:	};
        -:  989:
        -:  990:	/*  Extra bits for literal codes 257..285    ( 99==invalid ) */
        -:  991:	static uint16 cplext[] = {
        -:  992:		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -:  993:			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
        -:  994:	};
        -:  995:
        -:  996:	/*  Copy offsets for distance codes 0..29 */
        -:  997:	static uint16 cpdist[] = {
        -:  998:		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -:  999:			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -: 1000:			8193, 12289, 16385, 24577
        -: 1001:	};
        -: 1002:
        -: 1003:	/*  Extra bits for distance codes */
        -: 1004:	static uint16 cpdext[] = {
        -: 1005:		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -: 1006:			7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
        -: 1007:	};
        -: 1008:
        -: 1009:	int32     i;            /* temporary variable            */
        -: 1010:	HufTable *tl;           /* literal/length code table     */
        -: 1011:	HufTable *td;           /* distance code table           */
        -: 1012:	int32     bl;           /* lookup bits for tl            */
        -: 1013:	int32     bd;           /* lookup bits for td            */
        -: 1014:	uint32    l[288];       /* length list for gz_huft_build */
        -: 1015:
        -: 1016:	int32 error_code;
        -: 1017:
        -: 1018:	/*  set up literal table */
        1: 1019:	for (i = 0; i < 144; i++) l[i] = 8;
        1: 1020:	for (; i < 256; i++)      l[i] = 9;
        1: 1021:	for (; i < 280; i++)      l[i] = 7;
        1: 1022:	for (; i < 288; i++)      l[i] = 8;       /* make a complete, but wrong code set */
        -: 1023:
        1: 1024:	bl = 7;
        1: 1025:	State->hufts = 0;              /* initialize huff table "allocation" position  */
        1: 1026:	tl = &State->hufTable[1];         /* set known position given alloc removed - glw */
        1: 1027:	error_code = FS_gz_huft_build_Reentrant(State, l, 288, 257, cplens, cplext, &bl );
        -: 1028:
        1: 1029:	if ( error_code != CFE_SUCCESS ) return error_code;
        -: 1030:
        -: 1031:	/*  set up distance table */
        1: 1032:	for ( i = 0; i < 30; i++ ) l[i] = 5;      /* make an incomplete code set */
        1: 1033:	bd = 5;
        1: 1034:	td = &State->hufTable[State->hufts+1];               /* set known position given alloc removed - glw */
        1: 1035:	error_code = FS_gz_huft_build_Reentrant(State, l, 30, 0, cpdist, cpdext, &bd );
        -: 1036:
        1: 1037:	if ( error_code != CFE_SUCCESS && error_code != CFE_FS_GZIP_BAD_DATA ) return error_code;
        -: 1038:	/*  --- seems odd that BAD DATA is let through, but original did so --- */
        -: 1039:	/*  decompress until an end-of-block code  */
        1: 1040:	error_code = FS_gz_inflate_codes_Reentrant(State, tl, td, bl, bd );
        -: 1041:
        1: 1042:	return error_code;
        -: 1043:
        -: 1044:}
        -: 1045:
        -: 1046:/* 
        -: 1047:** "decompress" an inflated type 0 (stored) block. 
        -: 1048:*/
        -: 1049:int32 FS_gz_inflate_stored_Reentrant( CFE_FS_Decompress_State_t *State )
        1: 1050:{
        -: 1051:
        -: 1052:	uint32          n;     /* number of bytes in block */
        -: 1053:	uint32          w;     /* current window position */
        -: 1054:	register uint32 b;     /* bit buffer */
        -: 1055:	register uint16 k;     /* number of bits in bit buffer */
        -: 1056:
        -: 1057:
        -: 1058:	/*  make local copies of globals */
        1: 1059:	b = State->bb;             /* initialize bit buffer */
        1: 1060:	k = State->bk;
        1: 1061:	w = State->outcnt;         /* initialize window position */
        -: 1062:
        -: 1063:
        -: 1064:	/*  go to byte boundary */
        1: 1065:	n = k & 7;
        1: 1066:	DUMPBITS(n);
        -: 1067:
        -: 1068:	/*  get the length and its complement */
        1: 1069:	NEEDBITS(16);
    #####: 1070:	n = ( (uint32)b & 0xffff );
    #####: 1071:	DUMPBITS(16);
        -: 1072:
    #####: 1073:	NEEDBITS(16);
    #####: 1074:	if ( n != (uint32)( (~b) & 0xffff) )  return CFE_FS_GZIP_BAD_DATA;    /* error in compressed data */
    #####: 1075:	DUMPBITS(16);
        -: 1076:
        -: 1077:
        -: 1078:	/*  read and output the compressed data */
    #####: 1079:	while (n--) 
        -: 1080:   {
    #####: 1081:		NEEDBITS(8);
    #####: 1082:      State->window[w++] = (uint8)b;
    #####: 1083:		if ( w == WSIZE ) 
        -: 1084:      {
    #####: 1085:	        State->outcnt = w;
    #####: 1086:	        FS_gz_flush_window_Reentrant(State);
    #####: 1087:	        w = 0;
        -: 1088:		}
    #####: 1089:		DUMPBITS(8);
        -: 1090:	}
        -: 1091:
        -: 1092:	/*  restore the globals from the locals */
    #####: 1093:	State->outcnt = w;					/* restore global window pointer */
    #####: 1094:	State->bb     = b;					/* restore global bit buffer */
    #####: 1095:	State->bk     = k;
        -: 1096:
    #####: 1097:	return CFE_SUCCESS;
        -: 1098:
        -: 1099:}
        -: 1100:
        -: 1101:
        -: 1102:/* > merged original gunzip & unzip into a single routine */
        -: 1103:/* > replaced Read & Write indirection */
        -: 1104:
        -: 1105:int32 FS_gz_unzip_Reentrant( CFE_FS_Decompress_State_t *State )
        2: 1106:{
        -: 1107:	/*  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- */
        -: 1108:	/*  Unzip in to out.  This routine works on both gzip files. */
        -: 1109:
        -: 1110:	/*  IN assertions: the buffer State->inbuf contains already the beginning of the */
        -: 1111:	/*   compressed data, from offsets State->inptr to State->insize-1 included. The magic */
        -: 1112:	/*   header has already been checked. The output buffer is cleared. */
        -: 1113:
        -: 1114:	int32          guzerror;
        2: 1115:	uint32         orig_crc = 0;        /* original crc */
        2: 1116:	uint32         orig_len = 0;        /* original uncompressed length */
        -: 1117:	int32          n;
        -: 1118:	uint8          buf[EXTHDR];         /* extended local header */
        -: 1119:	int32          res;
        -: 1120:
        2: 1121:	FS_gz_clear_bufs_Reentrant(State);
        -: 1122:
        -: 1123:	/*  Snarf up the header for the zip file, check for read error */
        2: 1124:	guzerror = FS_gz_eat_header_Reentrant(State);
        -: 1125:
        2: 1126:	if( guzerror != CFE_SUCCESS ) return guzerror;
        -: 1127:
        1: 1128:	FS_gz_updcrc(NULL, 0);	                /* initialize crc */
        -: 1129:
        1: 1130:	res = FS_gz_inflate_Reentrant(State);
        -: 1131:
        1: 1132:	if ( res != CFE_SUCCESS ) return res;
        -: 1133:
        -: 1134:	/*  Get the crc and original length */
        -: 1135:	/*    crc32  (see algorithm.doc) uncompressed input size modulo 2^32 */
        9: 1136:	for ( n = 0; n < 8; n++ ) 
        -: 1137:   {
        8: 1138:		buf[n] = NEXTBYTE();      
        8: 1139:		if ( State->Error != CFE_SUCCESS ) return State->Error;
        -: 1140:	}
        1: 1141:	orig_crc = LG(buf);
        1: 1142:	orig_len = LG(buf + 4);
        -: 1143:
        -: 1144:	/*  Validate decompression */
        1: 1145:	if ( orig_crc != FS_gz_updcrc( State->outbuf, 0 ) ) return CFE_FS_GZIP_CRC_ERROR;
        1: 1146:	if ( orig_len != (uint32)State->bytes_out )      return CFE_FS_GZIP_LENGTH_ERROR;
        -: 1147:
        1: 1148:	return CFE_SUCCESS;
        -: 1149:
        -: 1150:}
        -: 1151:
        -: 1152:
        -: 1153:/*  Run a set of bytes through the crc shift register.  If s is a NULL */
        -: 1154:/*   pointer, then initialize the crc shift register contents instead. */ 
        -: 1155:/*   Return the current crc in either case. */
        -: 1156:
        -: 1157:/*  input: */
        -: 1158:/*	  s  pointer to bytes to pump through */
        -: 1159:/*	  n	 number of bytes in s[] */
        -: 1160:uint32 FS_gz_updcrc( uint8 * s, uint32 n )
        7: 1161:{
        -: 1162:	static uint32 crc_32_tab[] = {
        -: 1163:			0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        -: 1164:			0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        -: 1165:			0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        -: 1166:			0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        -: 1167:			0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        -: 1168:			0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        -: 1169:			0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        -: 1170:			0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        -: 1171:			0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        -: 1172:			0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        -: 1173:			0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        -: 1174:			0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        -: 1175:			0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        -: 1176:			0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        -: 1177:			0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        -: 1178:			0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        -: 1179:			0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        -: 1180:			0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        -: 1181:			0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        -: 1182:			0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        -: 1183:			0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        -: 1184:			0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        -: 1185:			0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        -: 1186:			0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        -: 1187:			0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        -: 1188:			0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        -: 1189:			0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        -: 1190:			0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        -: 1191:			0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        -: 1192:			0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        -: 1193:			0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        -: 1194:			0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        -: 1195:			0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        -: 1196:			0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        -: 1197:			0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        -: 1198:			0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        -: 1199:			0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        -: 1200:			0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        -: 1201:			0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        -: 1202:			0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        -: 1203:			0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        -: 1204:			0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        -: 1205:			0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        -: 1206:			0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        -: 1207:			0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        -: 1208:			0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        -: 1209:			0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        -: 1210:			0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        -: 1211:			0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        -: 1212:			0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        -: 1213:			0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        -: 1214:			0x2d02ef8dL
        -: 1215:	};
        -: 1216:
        -: 1217:	register uint32 c;                           /* temporary variable      */
        -: 1218:
        -: 1219:	static uint32 crc = (uint32)0xffffffffL;     /* shift register contents */
        -: 1220:
        7: 1221:	if (s == NULL) 
        -: 1222:   {
        1: 1223:		c = 0xffffffffL;
        -: 1224:	} 
        -: 1225:   else 
        -: 1226:   {
        -: 1227:		
        6: 1228:		c = crc;
        6: 1229:		if (n) 
        -: 1230:      {
        -: 1231:         do
        -: 1232:         {
   112727: 1233:				c = crc_32_tab[ ( (int16)c ^ (*s++) ) & 0xff ] ^ (c >> 8);
        -: 1234:				
   112727: 1235:         } while (--n);			
        -: 1236:		}		
        -: 1237:	}
        -: 1238:
        7: 1239:	crc = c;
        -: 1240:
        7: 1241:	return c ^ 0xffffffffL;      /* (instead of ~c for 64-bit machines) */
        -: 1242:
        -: 1243:}
        -: 1244:
        -: 1245:
