        -:    0:Source:/home/jdagostino/CProj/CFS/MKS/cfs-mission/cfe/fsw/cfe-core/src/fs/cfe_fs_decompress.c
        -:    0:Graph:cfe_fs_decompress.gcno
        -:    0:Data:cfe_fs_decompress.gcda
        -:    0:Runs:1
        -:    0:Programs:2
        -:    1:/*
        -:    2:** $Id: cfe_fs_decompress.c.gcov 1.1 2010/11/03 16:19:29EDT jmdagost Exp  $
        -:    3:**
        -:    4:**   File: CFE_FS_decompress.c
        -:    5:**
        -:    6:**
        -:    7:**      Copyright (c) 2004-2006, United States government as represented by the 
        -:    8:**      administrator of the National Aeronautics Space Administration.  
        -:    9:**      All rights reserved. This software(cFE) was created at NASA's Goddard 
        -:   10:**      Space Flight Center pursuant to government contracts.
        -:   11:**
        -:   12:**      This software may be used only pursuant to a United States government 
        -:   13:**      sponsored project and the United States government may not be charged
        -:   14:**      for use thereof. 
        -:   15:**
        -:   16:**
        -:   17:**   Author:   A. Cudmore,    NASA/GSFC Code 582
        -:   18:**             Ported from JWST, which was ported from Swift/BAT, 
        -:   19:**             which was ported from the GNU zip sources.
        -:   20:**
        -:   21:**   Purpose: cFE Port of the gzunzip software ported from Triana->Swift->JWST 
        -:   22:**
        -:   23:** $Log: cfe_fs_decompress.c.gcov  $
        -:   23:** Revision 1.1 2010/11/03 16:19:29EDT jmdagost 
        -:   23:** Initial revision
        -:   23:** Member added to project c:/MKSDATA/MKS-REPOSITORY/MKS-CFE-PROJECT/fsw/cfe-core/unit-test/FsResults/project.pj
        -:   24:** Revision 1.5 2010/10/25 18:26:06EDT jmdagost 
        -:   25:** Added test to while-loop to make sure array index does not go negative.
        -:   26:**
        -:   27:*/
        -:   28:
        -:   29:/* Original Credit:
        -:   30: *
        -:   31: * inflate.c -- Not copyrighted 1992 by Mark Adler version c10p1, 10 January
        -:   32: * 1993
        -:   33: *
        -:   34: * You can do whatever you like with this source file, though I would prefer
        -:   35: * that if you modify it and redistribute it that you include comments to
        -:   36: * that effect with your name and the date.  Thank you. [The history has been
        -:   37: * moved to the file ChangeLog.]
        -:   38: */
        -:   39:
        -:   40:/*
        -:   41:** Includes
        -:   42:*/
        -:   43:#include "cfe_fs_decompress.h"
        -:   44:
        -:   45:/*
        -:   46:** Global data -- Note: The following Global Data should be removed. The CFE_FS_Decompress API is not 
        -:   47:**                re-entrant! In order to make sure that two apps will not corrupt the data
        -:   48:**                the API is guarded with a Mutex. This will have serious implications on 
        -:   49:**                real time performance if an application blocks while another is in the API.
        -:   50:**               
        -:   51:*/
        -:   52:int        srcFile_fd;
        -:   53:int        dstFile_fd;
        -:   54:
        -:   55:uint32     gz_bb;
        -:   56:uint32     gz_bk;
        -:   57:uint32     gz_outcnt;
        -:   58:uint32     gz_insize;
        -:   59:uint32     gz_inptr;
        -:   60:int32      gz_bytes_in;
        -:   61:int32      gz_bytes_out;
        -:   62:
        -:   63:int32      gGuzError;
        -:   64:
        -:   65:uint8      gz_inbuf[ INBUFSIZ_EXTRA ];
        -:   66:uint8      gz_outbuf[ OUTBUFSIZ_EXTRA ];
        -:   67:uint8      gz_window[ WSIZE_X2 ];
        -:   68:uint32     gz_hufts;
        -:   69:uint32     gz_max_hufts;
        -:   70:uint32     trace[ 3 ];
        -:   71:
        -:   72:HufTable   hufTable[ MAX_HUF_TABLES ];
        -:   73:
        -:   74:/*
        -:   75:** Code
        -:   76:*/
        -:   77:
        -:   78:int32 CFE_FS_Decompress( char * srcFileName, char * dstFileName )
        4:   79:{
        -:   80:
        -:   81:   int32 guzerror;
        -:   82:
        -:   83:   /*
        -:   84:   ** Lock the API with the FS Mutex
        -:   85:   */
        4:   86:   CFE_FS_LockSharedData(__func__);
        -:   87:
        4:   88:   gGuzError = CFE_SUCCESS; /*Initialize this variable.  */
        -:   89:
        -:   90:   /*
        -:   91:   ** initialize max number of Huffman tables allocated to zero 
        -:   92:   */
        4:   93:   gz_max_hufts = 0;
        -:   94:
        -:   95:   /*  
        -:   96:   ** Open input file 
        -:   97:   */
        4:   98:   srcFile_fd = OS_open( srcFileName, OS_READ_ONLY, 0 );
        -:   99:
        -:  100:   /*
        -:  101:   ** if file could not be opened, return error code 
        -:  102:   */
        4:  103:   if ( srcFile_fd < 0 ) 
        -:  104:   {
        1:  105:      CFE_ES_WriteToSysLog("CFE_FS_Decompress: Cannot open source file: %s",
        -:  106:                            srcFileName);
        1:  107:      CFE_FS_UnlockSharedData(__func__);
        1:  108:      return (CFE_FS_GZIP_OPEN_INPUT);
        -:  109:   }
        -:  110:   /*
        -:  111:   ** open output file 
        -:  112:   */
        3:  113:   dstFile_fd = OS_creat( dstFileName, OS_WRITE_ONLY);
        -:  114:
        -:  115:   /*
        -:  116:   ** if file could not be opened 
        -:  117:   */ 
        3:  118:   if ( dstFile_fd < 0 ) 
        -:  119:   {
        1:  120:      CFE_ES_WriteToSysLog("CFE_FS_Decompress: Cannot open destination file: %s",
        -:  121:                            dstFileName);
        -:  122:
        1:  123:      CFE_FS_UnlockSharedData(__func__);
        -:  124:
        -:  125:      /* close the source file before bailing out */
        1:  126:      OS_close( srcFile_fd );
        -:  127:
        1:  128:      return (CFE_FS_GZIP_OPEN_OUTPUT);
        -:  129:   }
        -:  130:   else 
        -:  131:   {
        2:  132:      memset( hufTable,  0, MAX_HUF_TABLES * sizeof(HufTable) ); 
        2:  133:      memset( gz_window, 0, WSIZE_X2 ); 
        2:  134:      memset( trace,     0, 3 * sizeof(uint32) ); 
        -:  135:		
        -:  136:      /* 
        -:  137:      ** uncompress the file 
        -:  138:      */
        2:  139:      guzerror = FS_gz_unzip();
        -:  140:		
        -:  141:      /* 
        -:  142:      ** close output file 
        -:  143:      */
        2:  144:      OS_close( dstFile_fd );
        -:  145:   }
        -:  146:
        -:  147:   /*
        -:  148:   ** close input file 
        -:  149:   */
        2:  150:   OS_close( srcFile_fd );
        -:  151:
        -:  152:
        -:  153:   /*
        -:  154:   ** Unlock FS Shared data mutex
        -:  155:   */
        2:  156:   CFE_FS_UnlockSharedData(__func__);
        -:  157:
        -:  158:   /* 
        -:  159:   ** return error code 
        -:  160:   */
        2:  161:   return(guzerror);
        -:  162:
        -:  163:}
        -:  164:
        -:  165:
        -:  166:void FS_gz_clear_bufs( void )
        2:  167:{
        2:  168:	gz_outcnt = 0;
        2:  169:	gz_insize = 0;
        2:  170:	gz_inptr  = 0;
        -:  171:
        2:  172:	gz_bytes_in  = 0L;
        2:  173:	gz_bytes_out = 0L;
        2:  174:}
        -:  175:
        -:  176:
        -:  177:int32 FS_gz_eat_header( void )
        2:  178:{
        -:  179:	uint8   flags;                  /* compression flags */
        -:  180:	int8    magic[2];               /* magic header      */
        -:  181:	int8    thisByte;				     /* temporary holder for current byte in a string read */
        -:  182:	uint32  stamp;                  /* time stamp        */
        -:  183:	boolean keep_going;
        -:  184:
        -:  185:	/*  read input buffer (check for read error) */
        2:  186:	magic[0] = (int8)NEXTBYTE();
        2:  187:	if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  188:
        2:  189:	magic[1] = (int8)NEXTBYTE();
        2:  190:	if ( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  191:
        3:  192:	if ( memcmp( magic, GZIP_MAGIC, 2 ) == 0 || memcmp( magic, OLD_GZIP_MAGIC, 2 ) == 0 ) 
        -:  193:   {
        -:  194:		
        1:  195:		NEXTBYTE();
        1:  196:		if ( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  197:		
        1:  198:		flags = NEXTBYTE();
        1:  199:		if ( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  200:		
        1:  201:		stamp  = (uint32)NEXTBYTE();
        1:  202:		if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  203:		stamp |= (uint32)NEXTBYTE() <<  8;
        1:  204:		if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  205:		stamp |= (uint32)NEXTBYTE() << 16;
        1:  206:		if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  207:		stamp |= (uint32)NEXTBYTE() << 24;
        1:  208:		if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  209:		
        1:  210:		NEXTBYTE();		/* Ignore extra flags for the moment */
        1:  211:		if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        1:  212:		NEXTBYTE();		/* Ignore OS type for the moment */ 
        1:  213:		if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  214:		
        1:  215:		if ( (flags & CONTINUATION) != 0 ) {
        -:  216:			uint32 part;
    #####:  217:			part  = NEXTBYTE();
    #####:  218:			if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER; 
    #####:  219:			part |= NEXTBYTE() << 8;               /* <-- why is part used? -glw */
    #####:  220:			if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  221:		}
        -:  222:		
        1:  223:		if ( (flags & EXTRA_FIELD) != 0 ) {
        -:  224:			uint32 len;
    #####:  225:			len  = NEXTBYTE();
    #####:  226:			if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  227:			len |= NEXTBYTE() << 8;
    #####:  228:			if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
    #####:  229:			while (len--) {
    #####:  230:				NEXTBYTE();
    #####:  231:				if( gGuzError != CFE_SUCCESS ) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  232:			}
        -:  233:		}
        -:  234:		
        -:  235:		/* Get original file name if it was truncated */
        1:  236:		if ( (flags & ORIG_NAME) != 0 ) {
        1:  237:			keep_going = TRUE;
        8:  238:			while ( keep_going ) {
        -:  239:
        -:  240:				/* Get the next byte */
        6:  241:				thisByte = NEXTBYTE();
        -:  242:
        -:  243:				/* Header failure when end of file is reached or a read failure occurs */
        6:  244:				if ((thisByte == EOF) || (gGuzError != CFE_SUCCESS)) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  245:
        -:  246:				/* End of string was found */
        6:  247:				if (thisByte == 0) keep_going = FALSE;
        -:  248:			}
        -:  249:		}
        -:  250:		
        -:  251:		/*  Discard file comment if any  */
        1:  252:		if ( (flags & COMMENT) != 0 ) {
    #####:  253:			keep_going = TRUE;
    #####:  254:			while ( keep_going ) {
        -:  255:
        -:  256:				/* Get the next byte */
    #####:  257:				thisByte = NEXTBYTE();
        -:  258:
        -:  259:				/* Header failure when end of file is reached or a read failure occurs */
    #####:  260:				if ((thisByte == EOF) || (gGuzError != CFE_SUCCESS)) return CFE_FS_GZIP_READ_ERROR_HEADER;
        -:  261:
        -:  262:				/* End of string was found */
    #####:  263:				if (thisByte == 0) keep_going = FALSE;
        -:  264:			}
        -:  265:		}
        -:  266:	}
        -:  267:	else
        -:  268:	{
        1:  269:		gGuzError = CFE_FS_GZIP_NON_ZIP_FILE;
        -:  270:	}
        -:  271:
        2:  272:	return gGuzError;
        -:  273:}
        -:  274:
        -:  275:/*
        -:  276:** Fill the input buffer. This is called only when the buffer is empty. 
        -:  277:*/
        -:  278:int16 FS_gz_fill_inbuf( void )
        4:  279:{
        -:  280:	int32 len;
        -:  281:
        -:  282:	/*  Read as much as possible */
        4:  283:	gz_insize = 0;
        -:  284:
        -:  285:	do 
        -:  286:   {
        5:  287:		len = OS_read( srcFile_fd, (int8*)gz_inbuf + gz_insize, INBUFSIZ - gz_insize );
        -:  288:		
        5:  289:		if ( len == 0 || len == EOF || len == OS_FS_ERROR ) break;
        -:  290:		
        4:  291:		gz_insize += len;
        -:  292:		
        4:  293:	} while ( gz_insize < INBUFSIZ );
        -:  294:
        -:  295:
        4:  296:	if ( gz_insize == 0 ) return EOF;
        -:  297:
        4:  298:	if ( len == OS_FS_ERROR ) 
        -:  299:   {
        1:  300:		gGuzError = CFE_FS_GZIP_READ_ERROR;
        1:  301:		return EOF;
        -:  302:	}
        -:  303:
        3:  304:	gz_bytes_in += (uint32)gz_insize;
        3:  305:	gz_inptr = 1;
        -:  306:
        3:  307:	return gz_inbuf[0];
        -:  308:}
        -:  309:
        -:  310:
        -:  311:/*  Write the output window window[0..gz_outcnt-1] and update crc and */
        -:  312:/*   gz_bytes_out. (Used for the decompressed data only.) */
        -:  313:/*  merged original gz_flush_window & gz_write_buf together - glw */
        -:  314:/* fix for infinite loop when file store is full -dds */
        -:  315:void FS_gz_flush_window( void )
        5:  316:{
        -:  317:
        -:  318:	int  n;
        -:  319:	uint32  cnt;
        -:  320:	uint8   *gz_window_position;
        -:  321:
        5:  322:	if ( gz_outcnt == 0 ) return;
        -:  323:
        5:  324:	FS_gz_updcrc( gz_window, gz_outcnt );
        -:  325:
        5:  326:	cnt = gz_outcnt;
        5:  327:	gz_window_position = gz_window;
        -:  328:
       11:  329:	while ( gGuzError != CFE_FS_GZIP_WRITE_ERROR  &&
        -:  330:		    ( n = OS_write(dstFile_fd, (int8 *)gz_window_position, cnt) ) != cnt )
        -:  331:	{ 
        1:  332:		if ( n <= 0 ) gGuzError = CFE_FS_GZIP_WRITE_ERROR;
        -:  333:		
        1:  334:		cnt -= n;
        1:  335:		gz_window_position += n;
        -:  336:	}
        -:  337:
        5:  338:	gz_bytes_out += (uint32)gz_outcnt;
        -:  339:
        5:  340:	gz_outcnt = 0;
        -:  341:}
        -:  342:
        -:  343:
        -:  344:/*  Given a list of code lengths and a maximum table size, make a set of */
        -:  345:/*  tables to decode that set of codes.  Return zero on success, one if the */
        -:  346:/*  given code set is incomplete (the tables are still built in this case), */
        -:  347:/*  two if the input is invalid (all zero length codes or an oversubscribed */
        -:  348:/*  set of lengths), and three if not enough memory. */
        -:  349:
        -:  350:/*  INPUT:  */
        -:  351:/*	uint32    *b;      */             /* code lengths in bits (all assumed <= BMAX) */
        -:  352:/*	uint32     n;      */             /* number of codes (assumed <= N_MAX)         */
        -:  353:/*	uint32     s;       */            /* number of simple-valued codes (0..s-1)     */
        -:  354:/*	uint16    *d;       */            /* list of base values for non-simple codes   */
        -:  355:/*	uint16    *e;       */            /* list of extra bits for non-simple codes    */
        -:  356:/*	int32     *m;       */            /* maximum lookup bits, returns actual        */
        -:  357:
        -:  358:int32 FS_gz_huft_build( uint32 * b, uint32 n, uint32 s, uint16 * d, uint16 * e, int32 * m )
       20:  359:{
        -:  360:
        -:  361:	uint32  a;              /* counter for codes of length k        */
        -:  362:	uint32  c[BMAX + 1];    /* bit length count table               */
        -:  363:	uint32  f;              /* i repeats in table every f entries   */
        -:  364:	int32   g;              /* maximum code length                  */
        -:  365:	int32   h;              /* table level                          */
        -:  366:	register uint32 i;      /* counter, current code                */
        -:  367:	register uint32 j;      /* counter                              */
        -:  368:	register int32  k;      /* number of bits in current code       */
        -:  369:	int32  l;               /* bits per table (returned in m)       */
        -:  370:	uint32 lu;              /* l unsigned                           */
        -:  371:	register uint32 *p;     /* pointer into c[], b[], or v[]        */
        -:  372:	register HufTable *q;   /* points to current table              */
        -:  373:	HufTable r;             /* table entry for structure assignment */
        -:  374:	HufTable *u[BMAX];      /* table stack                          */
        -:  375:	uint32 v[N_MAX];        /* values in order of bit length        */
        -:  376:	register int32 w;       /* bits before this table == (l * h)    */
        -:  377:	uint32 x[BMAX + 1];     /* bit offsets, then code stack         */
        -:  378:	uint32 *xp;             /* pointer into x                       */
        -:  379:	int32 y;                /* number of dummy codes added          */
        -:  380:	uint32 z;               /* number of entries in current table   */
        -:  381:
        -:  382:	uint32 huft_index_t, huft_index_q;
       20:  383:	boolean   not_first_table = FALSE;
        -:  384:
        -:  385:	/*  Generate counts for each bit length  */
       20:  386:	memset( (void*)(c), 0, sizeof(c) );
       20:  387:	p = b;
       20:  388:	i = n;
        -:  389:	do 
        -:  390:   {
     2309:  391:		c[*p]++;
     2309:  392:		p++;
     2309:  393:	} while (--i);
        -:  394:	
       20:  395:   if (c[0] == n) 
        -:  396:   {			/* null input--all zero length codes */
    #####:  397:		*m = 0;
    #####:  398:		return CFE_SUCCESS;
        -:  399:	}
        -:  400:
        -:  401:
        -:  402:	/*  Find minimum and maximum length, bound *m by those */
       20:  403:	l = *m;
       20:  404:	for ( j = 1; j <= BMAX; j++ ) if ( c[j] ) break;
       20:  405:	k = j;
       20:  406:	lu = (uint32)l;				   		               /* minimum code length */
       20:  407:	if ( lu < j ) { l = j; lu = (uint32)l; }
       20:  408:	for ( i = BMAX; i; i-- ) if (c[i]) break;
       20:  409:	g = i;						                       /* maximum code length */
       20:  410:	if ( lu > i ) { l = i; lu = (uint32)l; }
       20:  411:	*m = l;
        -:  412:
        -:  413:
        -:  414:	/*  Adjust last length count to fill out codes, if needed */
      132:  415:	for ( y = 1 << j; j < i; j++, y <<= 1 )
      112:  416:	if ( ( y -= c[j] ) < 0 )  return CFE_FS_GZIP_BAD_CODE_BLOCK;    /* bad input: more codes than bits */
       20:  417:	if ( (y -= c[i] ) < 0 )  return CFE_FS_GZIP_BAD_CODE_BLOCK;
       20:  418:	c[i] += y;
        -:  419:
        -:  420:
        -:  421:	/*  Generate starting offsets into the value table for each length */
       20:  422:	x[1] = j = 0;
       20:  423:	p = c + 1;
       20:  424:	xp = x + 2;
      197:  425:	while (--i) {					/* note that i == g from above */
      157:  426:		j += *p++;
      157:  427:		*xp++ = j;
        -:  428:	}
        -:  429:
        -:  430:
        -:  431:	/*  Make a table of values in order of bit lengths */
       20:  432:	p = b;
       20:  433:	i = 0;
        -:  434:	do {
     2309:  435:		if ( (j = *p++) != 0 ) v[x[j]++] = i;
     2309:  436:	} while ( ++i < n );
        -:  437:
        -:  438:
        -:  439:	/*  Generate the Huffman codes and for each, make the table entries  */
       20:  440:	x[0] = i = 0;				  /* first Huffman code is zero   */
       20:  441:	p = v;						  /* grab values in bit order     */
       20:  442:	h = -1;						  /* no tables yet--level -1      */
       20:  443:	w = -l;						  /* bits decoded == (l * h)      */
       20:  444:	u[0] = (HufTable *)NULL;      /* just to keep compilers happy */
       20:  445:	q = (HufTable *)NULL;         /* ditto */
       20:  446:	z = 0;                        /* ditto */
        -:  447:
        -:  448:
        -:  449:	/*  go through the bit lengths (k already is bits in shortest code) */
      152:  450:	for (; k <= g; k++) {
      132:  451:		a = c[k];
     2461:  452:		while (a--) {
        -:  453:			
        -:  454:			/*      here i is the Huffman code of length k bits for value *p */
        -:  455:			/*      make tables up to required level */
     4794:  456:	        while (k > w + l) {
      400:  457:				h++;
      400:  458:				w += l;			/* previous table always l bits */
        -:  459:				
        -:  460:				/*        compute minimum size table less than or equal to l bits */
      400:  461:				z = g - w;
      400:  462:				z = ( z > lu ? l : z );                        /* upper limit on table size */
      400:  463:				j = k - w;
      400:  464:				f = 1<<j;
      400:  465:				if ( f > a + 1 )  {                            /* try a k-w bit table */
        -:  466:					
        -:  467:					/*          too few codes for k-w bit table  */
       30:  468:					f -= a + 1;                         /* deduct codes from patterns left */
       30:  469:					xp = c + k;
      121:  470:					while ( ++j < z )  {                /* try smaller tables up to z bits */
       63:  471:						f <<= 1;
       63:  472:						if ( f <= *++xp ) break;	        /* enough codes to use up j bits   */
       61:  473:						f -= *xp;                         /* else deduct codes from patterns */
        -:  474:					}
        -:  475:					
        -:  476:				}
      400:  477:				z = 1 << j;                           /* table entries for j-bit table   */
        -:  478:				
        -:  479:				/*        if space remains in the Huffman table memory array, "allocate" and link in new table */
      400:  480:				if ( gz_hufts + (z + 1) > MAX_HUF_TABLES ) return CFE_FS_GZIP_NO_MEMORY;
        -:  481:				
      400:  482:				q = &hufTable[gz_hufts];
      400:  483:				huft_index_q = gz_hufts;
      400:  484:				gz_hufts += z + 1; 
      400:  485:				if ( gz_hufts > gz_max_hufts ) gz_max_hufts = gz_hufts;
        -:  486:				
      400:  487:				if ( not_first_table ) hufTable[huft_index_t].v.t = huft_index_q + 1;
       20:  488:				else                   not_first_table = TRUE;
        -:  489:				
      400:  490:				huft_index_t = huft_index_q;
      400:  491:				hufTable[huft_index_t].v.t = 0xffff;               /* stand-in for NULL */
        -:  492:				
      400:  493:				u[h] = ++q;		                        /* table starts after link */
      400:  494:				huft_index_q++;
        -:  495:				
        -:  496:				/*        connect to last table, if there is one */
      400:  497:				if ( h ) {
      380:  498:					x[h] = i;                /* save pattern for backing up    */
      380:  499:					r.b = (uint8)l;     	  /* bits to dump before this table */
      380:  500:					r.e = (uint8)(16 + j);	  /* bits in this table             */
        -:  501:					/*             r.t = q;  */               /* pointer to this table          */
      380:  502:					r.v.t = huft_index_q;    /* pointer to this table          */
      380:  503:					j = i >> (w - l);        /* (get around Turbo C bug)       */
      380:  504:					u[h - 1][j] = r;         /* connect to last table          */ 
        -:  505:				}
        -:  506:				
        -:  507:	        }
        -:  508:			
        -:  509:			/*      set up table entry in r */
     2197:  510:	        r.b = (uint8)(k - w);
     2197:  511:	        if (p >= v + n) {
        2:  512:				r.e = 99;                             /* out of values--invalid code     */
     2195:  513:	        } else if ( *p < s ) {
     1837:  514:				r.e = (uint8)( *p < 256 ? 16 : 15 );	/* 256 is end-of-block code        */
     1837:  515:				r.v.n = *p;          	                /* simple code is just the value   */
     1837:  516:				p++;                                  /* one compiler does not like *p++ */
        -:  517:	        } else {
      358:  518:				r.e = (uint8)( e[*p - s] );           /* non-simple--look up in lists */
      358:  519:				r.v.n = d[*p++ - s];
        -:  520:	        }
        -:  521:			
        -:  522:			/*      fill code-like entries with r */
     2197:  523:	        f = 1 << (k - w);
     2197:  524:			j = i >> w;
        -:  525:
     2197:  526:			if( (q == (HufTable *)NULL) && (j < z) )
        -:  527:			{
    #####:  528:				return CFE_FS_GZIP_BAD_CODE_BLOCK;
        -:  529:			}
        -:  530:			else
        -:  531:			{
     2197:  532:	        	for ( j = i >> w; j < z; j += f ) q[j] = r;
        -:  533:			}
        -:  534:			
        -:  535:			/*      backwards increment the k-bit code i */
     2197:  536:	        for ( j = 1 << (k - 1); i & j; j >>= 1 ) i ^= j;
     2197:  537:	        i ^= j;
        -:  538:			
        -:  539:			/*      backup over finished tables */
     4774:  540:	        while (( h >= 0 ) && ( ( i & ((1 << w) - 1) ) != x[h] )) {
      380:  541:				h--;                                       /* don't need to update q */
      380:  542:				w -= l;
        -:  543:	        }
        -:  544:			
        -:  545:		}
        -:  546:		
        -:  547:	}
        -:  548:
        -:  549:	/*  Return true (1) if we were given an incomplete table  */
       20:  550:	return (int32)( y != 0 && g != 1 ) ;
        -:  551:}
        -:  552:
        -:  553:
        -:  554:
        -:  555:int32 FS_gz_inflate( void )
        1:  556:{
        -:  557:
        -:  558:	int32           e;        /* last block flag */
        -:  559:	int32   r;        /* result code     */
        -:  560:
        -:  561:	/*  initialize window, bit buffer */
        1:  562:	gz_outcnt = 0;
        1:  563:	gz_bk     = 0;
        1:  564:	gz_bb     = 0;
        -:  565:
        -:  566:	/*  decompress until the last block */
        -:  567:	do {
        6:  568:		r = FS_gz_inflate_block(&e);
        6:  569:		if ( r != CFE_SUCCESS ) return r;
        6:  570:	} while (!e);
        -:  571:
        -:  572:	/*  Undo too much lookahead. The next read will be byte aligned so we can */
        -:  573:	/*  discard unused bits in the last meaningful byte. */
        2:  574:	while ( gz_bk >= 8 ) {
    #####:  575:		gz_bk -= 8;
    #####:  576:		gz_inptr--;
        -:  577:	}
        -:  578:
        -:  579:	/*  flush out sliding window */
        1:  580:	FS_gz_flush_window();
        -:  581:
        -:  582:	/*  return success */
        1:  583:	return CFE_SUCCESS;
        -:  584:
        -:  585:}
        -:  586:
        -:  587:
        -:  588:/*  
        -:  589:** decompress an inflated block 
        -:  590:*/
        -:  591:int32 FS_gz_inflate_block( int32 * e )
        6:  592:{
        -:  593:
        -:  594:	uint32  t;          /* block type */
        -:  595:	uint32  b;          /* bit buffer */
        -:  596:	uint32  k;          /* number of bits in bit buffer */
        -:  597:
        -:  598:	int32 res;
        -:  599:
        -:  600:	/*  make local bit buffer */
        6:  601:	b = gz_bb;
        6:  602:	k = gz_bk;
        -:  603:
        -:  604:	/*  read in last block bit */
        6:  605:	NEEDBITS(1)
        6:  606:	*e = (int32)b & 1;
        6:  607:	DUMPBITS(1)
        -:  608:
        -:  609:
        -:  610:	/*  read in block type */
        6:  611:	NEEDBITS(2)
        6:  612:	t = (uint32)b & 3;
        6:  613:	DUMPBITS(2)
        -:  614:
        -:  615:
        -:  616:	/*  restore the global bit buffer */
        6:  617:	gz_bb = b;
        6:  618:	gz_bk = k;
        -:  619:
        -:  620:
        -:  621:	/*  inflate that block type */
        6:  622:	if      ( t == 0 ) { res = FS_gz_inflate_stored();  trace[0]++; }  
        6:  623:	else if ( t == 1 ) { res = FS_gz_inflate_fixed();   trace[1]++; }
        6:  624:	else if ( t == 2 ) { res = FS_gz_inflate_dynamic(); trace[2]++; }
        -:  625:
    #####:  626:	else               res = CFE_FS_GZIP_BAD_CODE_BLOCK;    
        -:  627:
        6:  628:	return res;
        -:  629:
        -:  630:}
        -:  631:
        -:  632:/* Inflate (decompress) the codes in a deflated (compressed) block.  */
        -:  633:/* Return an error code or zero if it all goes ok. */
        -:  634:int32 FS_gz_inflate_codes( HufTable * tl, HufTable * td, int32 bl, int32 bd )
        6:  635:{
        -:  636:
        -:  637:	static uint16 mask_bits[] = {
        -:  638:		0x0000,
        -:  639:			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -:  640:			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -:  641:	};
        -:  642:
        -:  643:
        -:  644:	uint32      e;          /* table entry flag/number of extra bits  */
        -:  645:	uint32      n, d;       /* length and index for copy              */
        -:  646:	uint32      w;          /* current window position                */
        -:  647:	HufTable   *t;          /* pointer to table entry                 */
        -:  648:	uint32      ml, md;     /* masks for bl and bd bits               */
        -:  649:	uint32      b;          /* bit buffer                             */
        -:  650:	uint32      k;          /* number of bits in bit buffer           */
        -:  651:
        -:  652:	uint32 index;
        -:  653:
        -:  654:	/*  make local copies of globals  */
        6:  655:	b = gz_bb;					/* initialize bit buffer */
        6:  656:	k = gz_bk;
        6:  657:	w = gz_outcnt;				/* initialize window position */ 
        -:  658:
        -:  659:	/*  inflate the coded data */
        6:  660:	ml = mask_bits[bl];			/* precompute masks for speed */
        6:  661:	md = mask_bits[bd];
        -:  662:
        -:  663:	for (;;) 
        -:  664:   {					/* do until end of block */
        -:  665:		
    24134:  666:		NEEDBITS((uint32)bl);
    24134:  667:      t = tl + ((uint32)b & ml);
    24134:  668:		e = t->e;
    24134:  669:		if ( e > 16 ) 
        -:  670:      {
        -:  671:	        do 
        -:  672:           {
     2079:  673:              if (e == 99) return CFE_FS_GZIP_BAD_DATA;
     2079:  674:              DUMPBITS(t->b);
     2079:  675:              e -= 16;
     2079:  676:				  NEEDBITS(e);
     2079:  677:              index = t->v.t + ( (uint32)b & mask_bits[e] );
     2079:  678:				  if ( index >= 0  &&  index < gz_hufts ) 
     2079:  679:                 t = &( hufTable[index] );
        -:  680:				  else  
    #####:  681:                 return CFE_FS_GZIP_INDEX_ERROR;
     2079:  682:				  e = t->e;
     2079:  683:	        } while ( e > 16 );
        -:  684:		}
        -:  685:		
    24134:  686:		DUMPBITS(t->b);
        -:  687:			
    24134:  688:      if ( e == 16 ) 
        -:  689:      {                 /* then it's a literal */
        -:  690:				
        -:  691:         /* gz_window[w++] = (uint8)(t->n); */
    14203:  692:         gz_window[w++] = (uint8)(t->v.n);
    14203:  693:         if ( w == WSIZE ) 
        -:  694:         {
    #####:  695:            gz_outcnt = w;
    #####:  696:            FS_gz_flush_window();
    #####:  697:            w = 0;
        -:  698:         }
        -:  699:				
        -:  700:      } 
        -:  701:      else 
        -:  702:      {                        /* it's an EOB or a length */
        -:  703:				
        -:  704:         /*  exit if end of block  */
     9931:  705:         if ( e == 15 ) break;
        -:  706:				
        -:  707:         /*  get length of block to copy */
     9925:  708:         NEEDBITS(e);
     9925:  709:         n = t->v.n + ( (uint32)b & mask_bits[e] );
     9925:  710:         DUMPBITS(e);
        -:  711:				
        -:  712:         /*  decode distance of block to copy  */
     9925:  713:         NEEDBITS((uint32)bd);
     9925:  714:         t = td + ((uint32)b & md);
     9925:  715:         e = t->e;
     9925:  716:         if ( e > 16 ) 
        -:  717:         {
        -:  718:            do 
        -:  719:            {
      337:  720:               if (e == 99) return CFE_FS_GZIP_BAD_DATA;
      337:  721:               DUMPBITS(t->b);
      337:  722:               e -= 16;
      337:  723:               NEEDBITS(e);
      337:  724:               index = t->v.t + ( (uint32)b & mask_bits[e] );
      337:  725:               if ( index >= 0  &&  index < gz_hufts ) 
      337:  726:                  t = &( hufTable[index] );
        -:  727:               else  
    #####:  728:                  return CFE_FS_GZIP_INDEX_ERROR;
      337:  729:               e = t->e;
      337:  730:            } while ( e > 16 );
        -:  731:         }
     9925:  732:         DUMPBITS(t->b);
        -:  733:					
     9925:  734:         NEEDBITS(e);
     9925:  735:         d = w - t->v.n - ((uint32)b & mask_bits[e]);
     9925:  736:         DUMPBITS(e);
        -:  737:					
        -:  738:         /* do the copy */
        -:  739:         do 
        -:  740:         {
        -:  741:						
     9935:  742:            d &= WSIZE - 1;
     9935:  743:            e = WSIZE - ( d > w ? d : w);
     9935:  744:            e = ( e > n ? n : e );
     9935:  745:            n -= e;
        -:  746:						
     9935:  747:            if ( w - d >= e ) 
        -:  748:            { /* (this test assumes unsigned comparison) */
        -:  749:							
     9854:  750:               memcpy( gz_window + w, gz_window + d, e );
     9854:  751:               w += e;
     9854:  752:               d += e;
        -:  753:							
        -:  754:            } 
        -:  755:            else 
        -:  756:            { /* do it slow to avoid memcpy() overlap */
        -:  757:							
        -:  758:               do 
        -:  759:               {
     8124:  760:                  gz_window[w++] = gz_window[d++];
     8124:  761:               } while (--e);
        -:  762:							
        -:  763:            }
        -:  764:						
     9935:  765:            if ( w == WSIZE ) 
        -:  766:            {
        3:  767:               gz_outcnt = w;
        3:  768:               FS_gz_flush_window();
        3:  769:               w = 0;
        -:  770:            }
        -:  771:						
     9935:  772:         } while (n);
        -:  773:					
        -:  774:      }
        -:  775:			
    24128:  776:   }
        -:  777:
        -:  778:	/*  restore the globals from the locals */
        6:  779:	gz_outcnt = w;				/* restore global window pointer */
        6:  780:	gz_bb = b;					/* restore global bit buffer */
        6:  781:	gz_bk = k;
        -:  782:
        6:  783:	return CFE_SUCCESS;
        -:  784:}
        -:  785:
        -:  786:/*
        -:  787:** removed gz_huft_free, no longer needed - glw 
        -:  788:** -- decompress an inflated type 2 (dynamic Huffman codes) block. 
        -:  789:*/
        -:  790:int32 FS_gz_inflate_dynamic( void )
        6:  791:{
        -:  792:
        -:  793:	static int32 lbits = 9;      /* bits in base literal/length lookup table */
        -:  794:	static int32 dbits = 6;      /* bits in base distance lookup table */
        -:  795:
        -:  796:	/*  Order of the bit length code lengths */
        -:  797:	static uint32 border[] = {
        -:  798:		16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
        -:  799:	};
        -:  800:
        -:  801:	/*  Copy lengths for literal codes 257..285 */
        -:  802:	static uint16 cplens[] = {
        -:  803:		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -:  804:			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        -:  805:	};
        -:  806:
        -:  807:	/*  Extra bits for literal codes 257..285    ( 99==invalid ) */
        -:  808:	static uint16 cplext[] = {
        -:  809:		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -:  810:			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
        -:  811:	};
        -:  812: 
        -:  813:	/*  Copy offsets for distance codes 0..29 */
        -:  814:	static uint16 cpdist[] = {
        -:  815:		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -:  816:			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -:  817:			8193, 12289, 16385, 24577
        -:  818:	};
        -:  819:
        -:  820:	/*  Extra bits for distance codes */
        -:  821:	static uint16 cpdext[] = {
        -:  822:		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -:  823:			7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
        -:  824:	};
        -:  825:
        -:  826:	static uint16 mask_bits[] = {
        -:  827:		0x0000,
        -:  828:			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
        -:  829:			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
        -:  830:	};
        -:  831:
        -:  832:
        -:  833:	int32      i;               /* temporary variables                      */
        -:  834:	uint32     j;
        -:  835:	uint32     l;               /* last length                              */
        -:  836:	uint32     m;               /* mask for bit lengths table               */
        -:  837:	uint32     n;               /* number of lengths to get                 */
        -:  838:	HufTable  *tl;              /* literal/length code table                */
        -:  839:	HufTable  *td;              /* distance code table                      */
        -:  840:	int32      bl;              /* lookup bits for tl                       */
        -:  841:	int32      bd;              /* lookup bits for td                       */
        -:  842:	uint32     nb;              /* number of bit length codes               */
        -:  843:	uint32     nl;              /* number of literal/length codes           */
        -:  844:	uint32     nd;              /* number of distance codes                 */
        -:  845:	uint32     ll[286 + 30];    /* literal/length and distance code lengths */
        -:  846:
        -:  847:	uint32     b;               /* bit buffer                   */
        -:  848:	uint32     k;               /* number of bits in bit buffer */
        -:  849:
        -:  850:	int32 error_code;
        -:  851:
        -:  852:	/*  make local bit buffer */
        6:  853:	b = gz_bb;
        6:  854:	k = gz_bk;
        -:  855:
        -:  856:	/*  read in table lengths */ 
        6:  857:	NEEDBITS(5);
        6:  858:	nl = 257 + ((uint32)b & 0x1f);	/* number of literal/length codes */
        6:  859:	DUMPBITS(5);
        -:  860:
        6:  861:	NEEDBITS(5);
        6:  862:	nd = 1 + ((uint32) b & 0x1f);	/* number of distance codes */
        6:  863:	DUMPBITS(5);
        -:  864:
        6:  865:	NEEDBITS(4);
        6:  866:	nb = 4 + ((uint32) b & 0xf);	/* number of bit length codes */
        6:  867:	DUMPBITS(4);
        -:  868:
        6:  869:	if (nl > 286 || nd > 30)  return CFE_FS_GZIP_BAD_DATA;				/* bad lengths */
        -:  870:
        -:  871:	/*  read in bit-length-code lengths */
       91:  872:	for (j = 0; j < nb; j++) {
       85:  873:		NEEDBITS(3);
       85:  874:			ll[border[j]] = (uint32)b & 7;
       85:  875:		DUMPBITS(3);
        -:  876:	}
        6:  877:	for (; j < 19; j++) ll[border[j]] = 0;
        -:  878:
        -:  879:	/*  build decoding table for trees--single level, 7 bit lookup  */
        6:  880:	bl = 7;
        6:  881:	gz_hufts = 0;             /* initialize Huff Table memory */
        6:  882:	tl = &hufTable[1];        /* set known position given alloc removed - glw */
        6:  883:	error_code = FS_gz_huft_build( ll, 19, 19, (uint16 *)NULL, (uint16 *)NULL, &bl );
        6:  884:	if ( error_code != CFE_SUCCESS )  return error_code; 
        -:  885:
        -:  886:	/*  read in literal and distance code lengths */
        6:  887:	n = nl + nd;
        6:  888:	m = mask_bits[bl];
        6:  889:	i = l = 0;
     1694:  890:	while ( (uint32)i < n ) 
        -:  891:   {
     1682:  892:		NEEDBITS((uint32)bl);
     1682:  893:      td = tl + ((uint32)b & m);
     1682:  894:		j = td->b;
     1682:  895:		DUMPBITS(j);
     1682:  896:      j = td->v.n;
     1682:  897:		if ( j < 16 ) 
        -:  898:      {            /* length of code in bits (0..15) */
     1617:  899:         ll[i++] = l = j;         /* save last length in l */
        -:  900:		} 
       65:  901:      else if ( j == 16 ) 
        -:  902:      {    /* repeat last length 3 to 6 times */
       59:  903:         NEEDBITS(2);
       59:  904:         j = 3 + ( (uint32)b & 3 );
       59:  905:         DUMPBITS(2);
       59:  906:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
       59:  907:         while (j--) ll[i++] = l;
        -:  908:		} 
        6:  909:      else if (j == 17) 
        -:  910:      {    /* 3 to 10 zero length codes */
        6:  911:         NEEDBITS(3);
        6:  912:         j = 3 + ( (uint32)b & 7 );
        6:  913:         DUMPBITS(3);
        6:  914:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
        6:  915:         while (j--) ll[i++] = 0;
        6:  916:         l = 0;
        -:  917:		} 
        -:  918:      else 
        -:  919:      {                 /* j == 18: 11 to 138 zero length codes */
    #####:  920:         NEEDBITS(7);
    #####:  921:         j = 11 + ( (uint32)b & 0x7f );
    #####:  922:         DUMPBITS(7);
    #####:  923:         if ( (uint32)i + j > n ) return CFE_FS_GZIP_BAD_DATA;
    #####:  924:         while (j--) ll[i++] = 0;
    #####:  925:         l = 0;
        -:  926:		}
        -:  927:	}
        -:  928:
        -:  929:	/*  restore the global bit buffer  */
        6:  930:	gz_bb = b;
        6:  931:	gz_bk = k;
        -:  932:
        -:  933:	/*  build the decoding tables for literal/length and distance codes */
        6:  934:	bl = lbits;
        6:  935:	gz_hufts = 0;                 /* initialize Huff Table memory */
        6:  936:	tl = &hufTable[1];            /* set known position given alloc removed - glw */
        6:  937:	error_code = FS_gz_huft_build( ll, nl, 257, cplens, cplext, &bl );
        6:  938:	if ( error_code != CFE_SUCCESS ) return error_code;
        -:  939:
        6:  940:	bd = dbits;
        6:  941:	td = &hufTable[gz_hufts+1];   /* set known position given alloc removed - glw */
        6:  942:	error_code = FS_gz_huft_build( ll + nl, nd, 0, cpdist, cpdext, &bd );
        6:  943:	if ( error_code != CFE_SUCCESS ) return error_code;
        -:  944:
        -:  945:	/*  decompress until an end-of-block code */
        6:  946:	error_code = FS_gz_inflate_codes( tl, td, bl, bd );
        -:  947:   
        6:  948:	return error_code;
        -:  949:}
        -:  950:
        -:  951:
        -:  952:/* Decompress an inflated type 1 (fixed Huffman codes) block.   */
        -:  953:/*  We should either replace this with a custom decoder,  */
        -:  954:/*  or at least precompute the Huffman tables. */
        -:  955:
        -:  956:/* removed gz_huft_free, no longer needed - glw */
        -:  957:int32 FS_gz_inflate_fixed( void )
        1:  958:{
        -:  959:	/*  Copy lengths for literal codes 257..285 */
        -:  960:	static uint16 cplens[] = {
        -:  961:		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        -:  962:			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        -:  963:	};
        -:  964:
        -:  965:	/*  Extra bits for literal codes 257..285    ( 99==invalid ) */
        -:  966:	static uint16 cplext[] = {
        -:  967:		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        -:  968:			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
        -:  969:	};
        -:  970:
        -:  971:	/*  Copy offsets for distance codes 0..29 */
        -:  972:	static uint16 cpdist[] = {
        -:  973:		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        -:  974:			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        -:  975:			8193, 12289, 16385, 24577
        -:  976:	};
        -:  977:
        -:  978:	/*  Extra bits for distance codes */
        -:  979:	static uint16 cpdext[] = {
        -:  980:		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        -:  981:			7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
        -:  982:	};
        -:  983:
        -:  984:	int32     i;            /* temporary variable            */
        -:  985:	HufTable *tl;           /* literal/length code table     */
        -:  986:	HufTable *td;           /* distance code table           */
        -:  987:	int32     bl;           /* lookup bits for tl            */
        -:  988:	int32     bd;           /* lookup bits for td            */
        -:  989:	uint32    l[288];       /* length list for gz_huft_build */
        -:  990:
        -:  991:	int32 error_code;
        -:  992:
        -:  993:	/*  set up literal table */
        1:  994:	for (i = 0; i < 144; i++) l[i] = 8;
        1:  995:	for (; i < 256; i++)      l[i] = 9;
        1:  996:	for (; i < 280; i++)      l[i] = 7;
        1:  997:	for (; i < 288; i++)      l[i] = 8;       /* make a complete, but wrong code set */
        -:  998:
        1:  999:	bl = 7;
        1: 1000:	gz_hufts = 0;              /* initialize huff table "allocation" position  */
        1: 1001:	tl = &hufTable[1];         /* set known position given alloc removed - glw */
        1: 1002:	error_code = FS_gz_huft_build( l, 288, 257, cplens, cplext, &bl );
        -: 1003:
        1: 1004:	if ( error_code != CFE_SUCCESS ) return error_code;
        -: 1005:
        -: 1006:	/*  set up distance table */
        1: 1007:	for ( i = 0; i < 30; i++ ) l[i] = 5;      /* make an incomplete code set */
        1: 1008:	bd = 5;
        1: 1009:	td = &hufTable[gz_hufts+1];               /* set known position given alloc removed - glw */
        1: 1010:	error_code = FS_gz_huft_build( l, 30, 0, cpdist, cpdext, &bd );
        -: 1011:
        1: 1012:	if ( error_code != CFE_SUCCESS && error_code != CFE_FS_GZIP_BAD_DATA ) return error_code;
        -: 1013:	/*  --- seems odd that BAD DATA is let through, but original did so --- */
        -: 1014:	/*  decompress until an end-of-block code  */
    #####: 1015:	error_code = FS_gz_inflate_codes( tl, td, bl, bd );
        -: 1016:
    #####: 1017:	return error_code;
        -: 1018:
        -: 1019:}
        -: 1020:
        -: 1021:/* 
        -: 1022:** "decompress" an inflated type 0 (stored) block. 
        -: 1023:*/
        -: 1024:int32 FS_gz_inflate_stored( void )
        1: 1025:{
        -: 1026:
        -: 1027:	uint32          n;     /* number of bytes in block */
        -: 1028:	uint32          w;     /* current window position */
        -: 1029:	register uint32 b;     /* bit buffer */
        -: 1030:	register uint16 k;     /* number of bits in bit buffer */
        -: 1031:
        -: 1032:
        -: 1033:	/*  make local copies of globals */
        1: 1034:	b = gz_bb;             /* initialize bit buffer */
        1: 1035:	k = gz_bk;
        1: 1036:	w = gz_outcnt;         /* initialize window position */
        -: 1037:
        -: 1038:
        -: 1039:	/*  go to byte boundary */
        1: 1040:	n = k & 7;
        1: 1041:	DUMPBITS(n);
        -: 1042:
        -: 1043:	/*  get the length and its complement */
        1: 1044:	NEEDBITS(16);
    #####: 1045:	n = ( (uint32)b & 0xffff );
    #####: 1046:	DUMPBITS(16);
        -: 1047:
    #####: 1048:	NEEDBITS(16);
    #####: 1049:	if ( n != (uint32)( (~b) & 0xffff) )  return CFE_FS_GZIP_BAD_DATA;    /* error in compressed data */
    #####: 1050:	DUMPBITS(16);
        -: 1051:
        -: 1052:
        -: 1053:	/*  read and output the compressed data */
    #####: 1054:	while (n--) 
        -: 1055:   {
    #####: 1056:		NEEDBITS(8);
    #####: 1057:      gz_window[w++] = (uint8)b;
    #####: 1058:		if ( w == WSIZE ) 
        -: 1059:      {
    #####: 1060:	        gz_outcnt = w;
    #####: 1061:	        FS_gz_flush_window();
    #####: 1062:	        w = 0;
        -: 1063:		}
    #####: 1064:		DUMPBITS(8);
        -: 1065:	}
        -: 1066:
        -: 1067:	/*  restore the globals from the locals */
    #####: 1068:	gz_outcnt = w;					/* restore global window pointer */
    #####: 1069:	gz_bb     = b;					/* restore global bit buffer */
    #####: 1070:	gz_bk     = k;
        -: 1071:
    #####: 1072:	return CFE_SUCCESS;
        -: 1073:
        -: 1074:}
        -: 1075:
        -: 1076:
        -: 1077:/* > merged original gunzip & unzip into a single routine */
        -: 1078:/* > replaced Read & Write indirection */
        -: 1079:
        -: 1080:int32 FS_gz_unzip( void )
        2: 1081:{
        -: 1082:	/*  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- */
        -: 1083:	/*  Unzip in to out.  This routine works on both gzip files. */
        -: 1084:
        -: 1085:	/*  IN assertions: the buffer gz_inbuf contains already the beginning of the */
        -: 1086:	/*   compressed data, from offsets gz_inptr to gz_insize-1 included. The magic */
        -: 1087:	/*   header has already been checked. The output buffer is cleared. */
        -: 1088:
        -: 1089:	int32          guzerror;
        2: 1090:	uint32         orig_crc = 0;        /* original crc */
        2: 1091:	uint32         orig_len = 0;        /* original uncompressed length */
        -: 1092:	int32          n;
        -: 1093:	uint8          buf[EXTHDR];         /* extended local header */
        -: 1094:	int32          res;
        -: 1095:
        2: 1096:	FS_gz_clear_bufs();
        -: 1097:
        -: 1098:	/*  Snarf up the header for the zip file, check for read error */
        2: 1099:	guzerror = FS_gz_eat_header();
        -: 1100:
        2: 1101:	if( guzerror != CFE_SUCCESS ) return guzerror;
        -: 1102:
        1: 1103:	FS_gz_updcrc(NULL, 0);	                /* initialize crc */
        -: 1104:
        1: 1105:	res = FS_gz_inflate();
        -: 1106:
        1: 1107:	if ( res != CFE_SUCCESS ) return res;
        -: 1108:
        -: 1109:	/*  Get the crc and original length */
        -: 1110:	/*    crc32  (see algorithm.doc) uncompressed input size modulo 2^32 */
        9: 1111:	for ( n = 0; n < 8; n++ ) 
        -: 1112:   {
        8: 1113:		buf[n] = NEXTBYTE();      
        8: 1114:		if ( gGuzError != CFE_SUCCESS ) return gGuzError;
        -: 1115:	}
        1: 1116:	orig_crc = LG(buf);
        1: 1117:	orig_len = LG(buf + 4);
        -: 1118:
        -: 1119:	/*  Validate decompression */
        1: 1120:	if ( orig_crc != FS_gz_updcrc( gz_outbuf, 0 ) ) return CFE_FS_GZIP_CRC_ERROR;
        1: 1121:	if ( orig_len != (uint32)gz_bytes_out )      return CFE_FS_GZIP_LENGTH_ERROR;
        -: 1122:
        1: 1123:	return CFE_SUCCESS;
        -: 1124:
        -: 1125:}
        -: 1126:
        -: 1127:
        -: 1128:/*  Run a set of bytes through the crc shift register.  If s is a NULL */
        -: 1129:/*   pointer, then initialize the crc shift register contents instead. */ 
        -: 1130:/*   Return the current crc in either case. */
        -: 1131:
        -: 1132:/*  input: */
        -: 1133:/*	  s  pointer to bytes to pump through */
        -: 1134:/*	  n	 number of bytes in s[] */
        -: 1135:uint32 FS_gz_updcrc( uint8 * s, uint32 n )
        7: 1136:{
        -: 1137:	static uint32 crc_32_tab[] = {
        -: 1138:			0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        -: 1139:			0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        -: 1140:			0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        -: 1141:			0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        -: 1142:			0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        -: 1143:			0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        -: 1144:			0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        -: 1145:			0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        -: 1146:			0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        -: 1147:			0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        -: 1148:			0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        -: 1149:			0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        -: 1150:			0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        -: 1151:			0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        -: 1152:			0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        -: 1153:			0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        -: 1154:			0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        -: 1155:			0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        -: 1156:			0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        -: 1157:			0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        -: 1158:			0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        -: 1159:			0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        -: 1160:			0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        -: 1161:			0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        -: 1162:			0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        -: 1163:			0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        -: 1164:			0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        -: 1165:			0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        -: 1166:			0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        -: 1167:			0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        -: 1168:			0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        -: 1169:			0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        -: 1170:			0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        -: 1171:			0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        -: 1172:			0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        -: 1173:			0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        -: 1174:			0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        -: 1175:			0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        -: 1176:			0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        -: 1177:			0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        -: 1178:			0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        -: 1179:			0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        -: 1180:			0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        -: 1181:			0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        -: 1182:			0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        -: 1183:			0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        -: 1184:			0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        -: 1185:			0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        -: 1186:			0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        -: 1187:			0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        -: 1188:			0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        -: 1189:			0x2d02ef8dL
        -: 1190:	};
        -: 1191:
        -: 1192:	register uint32 c;                           /* temporary variable      */
        -: 1193:
        -: 1194:	static uint32 crc = (uint32)0xffffffffL;     /* shift register contents */
        -: 1195:
        7: 1196:	if (s == NULL) 
        -: 1197:   {
        1: 1198:		c = 0xffffffffL;
        -: 1199:	} 
        -: 1200:   else 
        -: 1201:   {
        -: 1202:		
        6: 1203:		c = crc;
        6: 1204:		if (n) 
        -: 1205:      {
        -: 1206:         do
        -: 1207:         {
   112727: 1208:				c = crc_32_tab[ ( (int16)c ^ (*s++) ) & 0xff ] ^ (c >> 8);
        -: 1209:				
   112727: 1210:         } while (--n);			
        -: 1211:		}		
        -: 1212:	}
        -: 1213:
        7: 1214:	crc = c;
        -: 1215:
        7: 1216:	return c ^ 0xffffffffL;      /* (instead of ~c for 64-bit machines) */
        -: 1217:
        -: 1218:}
        -: 1219:
        -: 1220:
